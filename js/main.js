"use strict";

/**
 * @name account categorisation module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 06/17/2018
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.account-categorisation", ["binary.pages.account-categorisation.controllers"]);

  angular.module("binary.pages.account-categorisation.controllers", []);
})();
"use strict";

/**
 * @name Account management module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 10/28/2017
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.accounts-management", ["binary.pages.accounts-management.controllers"]);

  angular.module("binary.pages.accounts-management.controllers", []);
})();
"use strict";

/**
 * @name Asset Index module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 01/26/2017
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.asset-index", ["binary.pages.asset-index.controllers"]);

  angular.module("binary.pages.asset-index.controllers", []);
})();
"use strict";

/**
 * @name authentication module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 04/27/2017
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.authentication", ["binary.pages.authentication.controllers"]);

  angular.module("binary.pages.authentication.controllers", []);
})();
"use strict";

/**
 * @name Contact module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 04/29/2017
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.contact", ["binary.pages.contact.controllers"]);

  angular.module("binary.pages.contact.controllers", []);
})();
"use strict";

/**
 * @name Change Password module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 01/11/2017
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.change-password", ["binary.pages.change-password.controllers"]);

  angular.module("binary.pages.change-password.controllers", []);
})();
"use strict";

/**
 * @name Financial Assessment module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 01/15/2017
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.financial-assessment", ["binary.pages.financial-assessment.controllers"]);

  angular.module("binary.pages.financial-assessment.controllers", []);
})();
"use strict";

/**
 * @name Home Module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 8/10/2016
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.home", ["binary.pages.home.controllers"]);

  angular.module("binary.pages.home.controllers", []);
})();
"use strict";

/**
 * @name Limits module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 01/18/2017
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.limits", ["binary.pages.limits.controllers"]);

  angular.module("binary.pages.limits.controllers", []);
})();
"use strict";

/**
 * @name new-account-maltainvest module
 * @author Nazanin Reihanib Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.maltainvest-account-opening", []);

  angular.module("binary.pages.maltainvest-account-opening.controllers", []);
})();
"use strict";

/**
 * @name MetaTrader Module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 04/15/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.meta-trader", ["binary.pages.meta-trader.controllers", "binary.pages.meta-trader.directives"]);

    angular.module("binary.pages.meta-trader.controllers", []);

    angular.module("binary.pages.meta-trader.directives", []);
})();
"use strict";

/**
 * @name Notifications module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 05/02/2017
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.notifications", ["binary.pages.notifications.controllers"]);

  angular.module("binary.pages.notifications.controllers", []);
})();
"use strict";

/**
 * @name Profile Module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 11/21/2016
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.profile", ["binary.pages.profile.controllers"]);

  angular.module("binary.pages.profile.controllers", []);
})();
"use strict";

/**
 * @name profit-table module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.profit-table", ["binary.pages.profit-table.controllers", "binary.pages.profit-table.filters"]);

    angular.module("binary.pages.profit-table.controllers", []);

    angular.module("binary.pages.profit-table.filters", []);
})();
"use strict";

/**
 * @name new-account-real module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.real-account-opening", []);

  angular.module("binary.pages.real-account-opening.controllers", []);
})();
"use strict";

/**
 * @name Redirect Module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 03/03/2018
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.redirect", ["binary.pages.redirect.controllers"]);

  angular.module("binary.pages.redirect.controllers", []);
})();
"use strict";

/**
 * @name resources module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 01/24/2016
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.resources", ["binary.pages.resources.controllers"]);

  angular.module("binary.pages.resources.controllers", []);
})();
"use strict";

/**
 * @name self-exclusion module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 11/12/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.self-exclusion", ["binary.pages.self-exclusion.controllers", "binary.pages.self-exclusion.directives"]);

    angular.module("binary.pages.self-exclusion.controllers", []);

    angular.module("binary.pages.self-exclusion.directives", []);
})();
"use strict";

/**
 * @name set currency module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 10/18/2017
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.set-currency", ["binary.pages.set-currency.controllers"]);

  angular.module("binary.pages.set-currency.controllers", []);
})();
"use strict";

/**
 * @name settings module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 11/11/2016
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.settings", ["binary.pages.settings.controllers"]);

  angular.module("binary.pages.settings.controllers", []);
})();
"use strict";

/**
 * @name Singin Module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 8/10/2016
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.signin", ["binary.pages.signin.components", "binary.pages.signin.controllers"]);

  angular.module("binary.pages.signin.controllers", []);

  angular.module("binary.pages.signin.components", ["binary.pages.signin.components.oauth"]);
})();
"use strict";

/**
 * @name statement module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.statement", ["binary.pages.statement.controllers", "binary.pages.statement.filters"]);

  angular.module("binary.pages.statement.controllers", []);

  angular.module("binary.pages.statement.filters", []);
})();
"use strict";

/**
 * @name accept terms and conditions module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 12/14/2016
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.terms-and-conditions", ["binary.pages.terms-and-conditions.controllers"]);

  angular.module("binary.pages.terms-and-conditions.controllers", []);
})();
"use strict";

/**
 * @name options controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/21/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade", ["binary.pages.trade.components", "binary.pages.trade.controllers", "binary.pages.trade.services"]);

    angular.module("binary.pages.trade.components", ["binary.pages.trade.components.options", "binary.pages.trade.components.chart", "binary.pages.trade.components.payout", "binary.pages.trade.components.purchase", "binary.pages.trade.components.longcode"]);

    angular.module("binary.pages.trade.controllers", []);

    angular.module("binary.pages.trade.services", []);
})();
"use strict";

/**
 * @name Trading Times module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 01/24/2017
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.trading-times", ["binary.pages.trading-times.controllers"]);

  angular.module("binary.pages.trading-times.controllers", []);
})();
"use strict";

/**
 * @name transaction-detail module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.transaction-detail", ["binary.pages.transaction-detail.controllers"]);

  angular.module("binary.pages.transaction-detail.controllers", []);
})();
"use strict";

/**
 * @name update module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 12/26/2015
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.update", ["binary.pages.update.controllers"]);

  angular.module("binary.pages.update.controllers", []);
})();
"use strict";

/**
 * @name accounts module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/15/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.accounts", ["binary.share.components.accounts.controllers", "binary.share.components.accounts.directives"]);

    angular.module("binary.share.components.accounts.controllers", []);

    angular.module("binary.share.components.accounts.directives", []);
})();
"use strict";

/**
 * @name balance module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/15/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.balance", ["binary.share.components.balance.directives", "binary.share.components.balance.controllers"]);

    angular.module("binary.share.components.balance.controllers", []);

    angular.module("binary.share.components.balance.directives", []);
})();
"use strict";

/**
 * @name app version module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 12/19/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.app-version", ["binary.share.components.app-version.controllers", "binary.share.components.app-version.directives"]);

    angular.module("binary.share.components.app-version.controllers", []);

    angular.module("binary.share.components.app-version.directives", []);
})();
"use strict";

/**
 * @name big number Module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 06/09/2017
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.share.components.big-number", ["binary.share.components.big-number.directives"]);

  angular.module("binary.share.components.big-number.directives", []);
})();
"use strict";

/**
 * @name Check User Status module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 02/15/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.check-user-status", ["binary.share.components.check-user-status.controllers", "binary.share.components.check-user-status.directives"]);

    angular.module("binary.share.components.check-user-status.controllers", []);

    angular.module("binary.share.components.check-user-status.directives", []);
})();
"use strict";

/**
 * @name Connectivity Module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 10/22/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.connectivity", ["binary.share.components.connectivity.controllers", "binary.share.components.connectivity.directives"]);

    angular.module("binary.share.components.connectivity.controllers", []);

    angular.module("binary.share.components.connectivity.directives", []);
})();
'use strict';

/**
 * @name iOS PWA Prompt Module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 03/11/2018
 * @copyright Binary Ltd
 */

(function () {
    angular.module('binary.share.components.ios-pwa-prompt', ['binary.share.components.ios-pwa-prompt.controllers', 'binary.share.components.ios-pwa-prompt.directives']);

    angular.module('binary.share.components.ios-pwa-prompt.controllers', []);

    angular.module('binary.share.components.ios-pwa-prompt.directives', []);
})();
"use strict";

/**
 * @name language module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 * Application Header
 */

(function () {
    angular.module("binary.share.components.language", ["binary.share.components.language.directives", "binary.share.components.language.controllers"]);

    angular.module("binary.share.components.language.directives", []);

    angular.module("binary.share.components.language.controllers", []);
})();
"use strict";

/**
 * @name logout module
 * @author
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.logout", ["binary.share.components.logout.controllers", "binary.share.components.logout.directives"]);

    angular.module("binary.share.components.logout.controllers", []);

    angular.module("binary.share.components.logout.directives", []);
})();
"use strict";

/**
 * @name long-press module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 09/05/2016
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.share.components.long-press", ["binary.share.components.long-press.directives"]);

  angular.module("binary.share.components.long-press.directives", []);
})();
"use strict";

/**
 * @name Notification Icon module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 05/03/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.notification-icon", ["binary.share.components.notification-icon.controllers", "binary.share.components.notification-icon.directives"]);

    angular.module("binary.share.components.notification-icon.controllers", []);

    angular.module("binary.share.components.notification-icon.directives", []);
})();
"use strict";

/**
 * @name number Module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 12/02/2016
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.share.components.number", ["binary.share.components.number.directives"]);

  angular.module("binary.share.components.number.directives", []);
})();
"use strict";

/**
 * @name ping module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 * Application Header
 */

(function () {
    angular.module("binary.share.components.ping", ["binary.share.components.ping.controllers", "binary.share.components.ping.directives"]);

    angular.module("binary.share.components.ping.controllers", []);

    angular.module("binary.share.components.ping.directives", []);
})();
"use strict";

/**
 * @name reality-check module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.reality-check", ["binary.share.components.reality-check.controllers", "binary.share.components.reality-check.directives"]);

    angular.module("binary.share.components.reality-check.controllers", []);

    angular.module("binary.share.components.reality-check.directives", []);
})();
"use strict";

/**
 * @name Regex Validate Module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 11/02/2016
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.share.components.regex-validate", ["binary.share.components.regex-validate.directives"]);

  angular.module("binary.share.components.regex-validate.directives", []);
})();
"use strict";

/**
 * @name Service Outage Module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 05/06/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.service-outage", ["binary.share.components.service-outage.controllers", "binary.share.components.service-outage.directives"]);

    angular.module("binary.share.components.service-outage.controllers", []);

    angular.module("binary.share.components.service-outage.directives", []);
})();
"use strict";

/**
 * @name spinner-logo module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/17/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.spinner-logo", ["binary.share.components.spinner-logo.directives", "binary.share.components.spinner-logo.controllers"]);

    angular.module("binary.share.components.spinner-logo.directives", []);

    angular.module("binary.share.components.spinner-logo.controllers", []);
})();
"use strict";

/**
 * @name updater module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 12/20/2015
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.updater", ["binary.share.components.updater.controllers", "binary.share.components.updater.directives"]);

    angular.module("binary.share.components.updater.controllers", []);

    angular.module("binary.share.components.updater.directives", []);
})();
"use strict";

/**
 * @name Oauth module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 8/13/2016
 * @copyright Binary Ltd
 */

(function () {
  angular.module("binary.pages.signin.components.oauth", []);
})();
"use strict";

/**
 * @name chart module
 * @author morteza tavnarad
 * @contributors []
 * @since 08/29/2016
 * @copyright binary ltd
 */

(function () {
    angular.module("binary.pages.trade.components.chart", ["binary.pages.trade.components.chart.controllers", "binary.pages.trade.components.chart.directives", "binary.pages.trade.components.chart.services"]);

    angular.module("binary.pages.trade.components.chart.controllers", []);

    angular.module("binary.pages.trade.components.chart.directives", []);

    angular.module("binary.pages.trade.components.chart.services", []);
})();
"use strict";

/**
 * @name longcode module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 09/22/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.longcode", ["binary.pages.trade.components.longcode.controllers", "binary.pages.trade.components.longcode.directives"]);

    angular.module("binary.pages.trade.components.longcode.controllers", []);

    angular.module("binary.pages.trade.components.longcode.directives", []);
})();
"use strict";

/**
 * @name options module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/21/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.options", ["binary.pages.trade.components.options.controllers", "binary.pages.trade.components.options.directives", "binary.pages.trade.components.options.services"]);

    angular.module("binary.pages.trade.components.options.controllers", []);

    angular.module("binary.pages.trade.components.options.directives", []);

    angular.module("binary.pages.trade.components.options.services", []);
})();
"use strict";

/**
 * @name payout module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/27/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.payout", ["binary.pages.trade.components.payout.controllers", "binary.pages.trade.components.payout.directives"]);

    angular.module("binary.pages.trade.components.payout.controllers", []);

    angular.module("binary.pages.trade.components.payout.directives", []);
})();
"use strict";

/**
 * @name purchase module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/27/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.purchase", ["binary.pages.trade.components.purchase.controllers", "binary.pages.trade.components.purchase.directives"]);

    angular.module("binary.pages.trade.components.purchase.controllers", []);

    angular.module("binary.pages.trade.components.purchase.directives", []);
})();
"use strict";

// Ionic Starter App

// angular.module is a global place for creating, registering and retrieving Angular modules
// 'starter' is the name of this angular module example (also set in a <body> attribute in index.html)
// the 2nd parameter is an array of 'requires'

(function () {
    "use restrict";

    angular.module("binary", ["ionic", "ionic.native", "pascalprecht.translate", "hmTouchEvents", "ngIOS9UIWebViewPatch", "binary.share.components", "binary.share.services", "binary.pages", "ngMessages", "ngCordova"]);

    angular.module("binary.share.components", ["binary.share.components.language", "binary.share.components.ping", "binary.share.components.accounts", "binary.share.components.spinner-logo", "binary.share.components.balance", "binary.share.components.long-press", "binary.share.components.reality-check", "binary.share.components.logout", "binary.share.components.connectivity", "binary.share.components.regex-validate", "binary.share.components.number", "binary.share.components.app-version", "binary.share.components.updater", "binary.share.components.check-user-status", "binary.share.components.service-outage", "binary.share.components.notification-icon", "binary.share.components.big-number", "binary.share.components.ios-pwa-prompt"]);

    angular.module("binary.share.services", []);

    angular.module("binary.pages", ["binary.pages.home", "binary.pages.signin", "binary.pages.trade", "binary.pages.real-account-opening", "binary.pages.maltainvest-account-opening", "binary.pages.profit-table", "binary.pages.statement", "binary.pages.transaction-detail", "binary.pages.settings", "binary.pages.self-exclusion", "binary.pages.profile", "binary.pages.terms-and-conditions", "binary.pages.update", "binary.pages.change-password", "binary.pages.financial-assessment", "binary.pages.limits", "binary.pages.trading-times", "binary.pages.resources", "binary.pages.asset-index", "binary.pages.meta-trader", "binary.pages.authentication", "binary.pages.contact", "binary.pages.notifications", "binary.pages.set-currency", "binary.pages.accounts-management", "binary.pages.redirect", "binary.pages.account-categorisation"]);

    String.prototype.capitalize = function () {
        return this.charAt(0).toUpperCase() + this.slice(1);
    };
})();
"use strict";

(function () {
    angular.module("binary").run(["$rootScope", "$ionicPlatform", "$state", "alertService", "appStateService", "appVersionService", function ($rootScope, $ionicPlatform, $state, alertService, appStateService, appVersionService) {
        $ionicPlatform.ready(function () {
            if (window.CacheClear) {
                cordova.getAppVersion().then(function (version) {
                    if (version === localStorage.version) {
                        return;
                    }

                    var language = localStorage.language;
                    var accounts = localStorage.accounts;
                    window.CacheClear(function () {
                        localStorage.version = version;
                        localStorage.language = language || "en";
                        localStorage.accounts = accounts || null;

                        window.location.href = 'file:///android_asset/www/index.html';
                    }, function (e) {
                        console.log('Cannot clear cache!'); // eslint-disable-line no-console
                    });
                });
            }
            if (ionic.Platform.isIOS()) {
                setTimeout(function () {
                    navigator.splashscreen.hide();
                }, 3000 - 1000);
            }

            if (window.cordova && window.cordova.plugins.backgroundMode) {
                cordova.plugins.backgroundMode.setDefaults({
                    title: "Binary.com TickTrade",
                    text: "",
                    ticker: "TickTrade is running in background",
                    color: "#2A3052",
                    icon: "notification"
                });
                cordova.plugins.backgroundMode.enable();
            }

            if (typeof window.ga !== "undefined") {
                window.ga.startTrackerWithId("UA-40877026-7");
            } else {
                // eslint-disable-next-line
                console.log("Google Analytics is unavailable");
            }

            if (window.cordova && window.cordova.plugins.Keyboard) {
                // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard
                // for form inputs)
                cordova.plugins.Keyboard.hideKeyboardAccessoryBar(false);

                // Don't remove this line unless you know what you are doing. It stops the viewport
                // from snapping when text inputs are focused. Ionic handles this internally for
                // a much nicer keyboard experience.
                cordova.plugins.Keyboard.disableScroll(true);
            }
            if (window.cordova) {
                window.open = cordova.InAppBrowser.open;
            }

            // Handle the android's hardware button
            $ionicPlatform.registerBackButtonAction(function () {
                if (appStateService.isPopupOpen || appStateService.modalIsOpen) {
                    // Do nothing
                } else if (["signin", "home", "update"].indexOf($state.current.name) > -1) {
                    navigator.app.exitApp();
                } else if ($state.current.name === "trade" && appStateService.purchaseMode) {
                    // Do nothing
                } else if ($state.current.name === "trade" && !appStateService.purchaseMode && !appStateService.tradeMode) {
                    appStateService.tradeMode = true;
                    $rootScope.$broadcast("appState:tradeMode");
                    if (!$rootScope.$$phase) {
                        $rootScope.$apply();
                    }
                } else if (["trade", "profittable", "statement"].indexOf($state.current.name) > -1) {
                    alertService.confirmExit(function (res) {
                        if (res === 1) {
                            sessionStorage.removeItem("start");
                            sessionStorage.removeItem("_interval");
                            navigator.app.exitApp();
                        }
                    });
                } else if ($state.current.detailed) {
                    $state.go("trade");
                } else {
                    $state.goBack();
                }
            }, 500);
        });
    }]);
})();
"use strict";

angular.module("binary").controller("BodyController", ["$scope", "languageService", function ($scope, languageService) {
    var vm = this;
    vm.getLanguage = function () {
        return languageService.read();
    };
}]);
"use strict";

angular.module("binary").controller("MainLayoutController", ["$scope", "$state", "$timeout", "config", "websocketService", "appStateService", "accountService", "clientService", function ($scope, $state, $timeout, config, websocketService, appStateService, accountService, clientService) {
    var vm = this;
    vm.hasMTAccess = false;
    vm.hasNotSelectedCountry = false;
    var currentAccount = {};
    vm.serverUrl = websocketService.getServerURL;
    vm.defaultServerUrl = config.serverUrl;

    var isLandingCompanyOf = function isLandingCompanyOf(targetLandingCompany, accountLandingCompany) {
        return clientService.isLandingCompanyOf(targetLandingCompany, accountLandingCompany);
    };

    var getAccountInfo = function getAccountInfo() {
        vm.upgrade = {};
        vm.accounts = accountService.getAll();
        currentAccount = accountService.getDefault();
        if (!_.isEmpty(currentAccount)) {
            var landingCompany = currentAccount.landing_company_name;
            vm.showNetworkStatus = isLandingCompanyOf('iom', landingCompany) || isLandingCompanyOf('malta', landingCompany) || isLandingCompanyOf('maltainvest', landingCompany);
            if (currentAccount.country) {
                var country = currentAccount.country;
                $scope.$applyAsync(function () {
                    vm.hasNotSelectedCountry = false;
                });
                if (country !== 'jp') {
                    var reqId = 1;
                    websocketService.sendRequestFor.landingCompanySend(country, reqId);
                }
            } else {
                $scope.$applyAsync(function () {
                    vm.hasNotSelectedCountry = true;
                });
            }
        } else {
            $timeout(getAccountInfo, 1000);
        }
    };

    getAccountInfo();

    var hasShortCode = function hasShortCode(data, code) {
        return (data || {}).shortcode === code;
    };

    var hasMTfinancialCompany = function hasMTfinancialCompany(data) {
        return hasShortCode(data.financial_company, 'vanuatu');
    };

    var getExistingCurrencies = function getExistingCurrencies(accounts) {
        return clientService.getExistingCurrencies(accounts);
    };

    var getDividedCurrencies = function getDividedCurrencies(currencies) {
        return clientService.dividedCurrencies(currencies);
    };

    var getUpgradeInfo = function getUpgradeInfo(landingCompanyObj) {
        var upgradeableLandingCompanies = appStateService.upgradeableLandingCompanies;
        var currentLandingCompany = currentAccount.landing_company_name;
        var canUpgrade = !!(upgradeableLandingCompanies && upgradeableLandingCompanies.length);
        var canUpgradeMultiAccount = false;
        var multi = false;
        var typeOfNextAccount = void 0;
        var upgradeLink = void 0;
        var currencyOptions = void 0;
        var allowedMarkets = void 0;
        if (canUpgrade) {
            canUpgradeMultiAccount = !!_.find(upgradeableLandingCompanies, function (landingCompany) {
                return landingCompany === currentLandingCompany;
            });
        }

        var canUpgradeToLandingCompany = function canUpgradeToLandingCompany(arr_landing_company) {
            return !!_.find(arr_landing_company, function (landingCompany) {
                return landingCompany !== currentLandingCompany && upgradeableLandingCompanies.indexOf(landingCompany) > -1;
            });
        };

        if (canUpgradeToLandingCompany(['costarica', 'svg', 'malta', 'iom']) && !canUpgradeMultiAccount) {
            typeOfNextAccount = 'real';
            upgradeLink = 'real-account-opening';
            currencyOptions = landingCompanyObj.gaming_company ? landingCompanyObj.gaming_company.legal_allowed_currencies : landingCompanyObj.financial_company.legal_allowed_currencies;
            allowedMarkets = landingCompanyObj.gaming_company ? landingCompanyObj.gaming_company.legal_allowed_markets : landingCompanyObj.financial_company.legal_allowed_markets;
        } else if (canUpgradeToLandingCompany(['maltainvest'])) {
            typeOfNextAccount = 'financial';
            upgradeLink = 'maltainvest-account-opening';
            currencyOptions = landingCompanyObj.financial_company.legal_allowed_currencies;
            allowedMarkets = landingCompanyObj.financial_company.legal_allowed_markets;
        } else if (canUpgradeMultiAccount) {
            typeOfNextAccount = 'real';
            upgradeLink = '';
            allowedMarkets = landingCompanyObj.financial_company.legal_allowed_markets;
            var legalAllowedCurrencies = landingCompanyObj.financial_company.legal_allowed_currencies;
            var existingCurrencies = getExistingCurrencies(vm.accounts);
            if (existingCurrencies.length) {
                var dividedExistingCurrencies = getDividedCurrencies(existingCurrencies);
                var hasFiat = !!dividedExistingCurrencies.fiatCurrencies.length;
                if (hasFiat) {
                    var legalAllowedCryptoCurrencies = getDividedCurrencies(legalAllowedCurrencies).cryptoCurrencies;
                    var existingCryptoCurrencies = dividedExistingCurrencies.cryptoCurrencies;
                    currencyOptions = _.difference(legalAllowedCryptoCurrencies, existingCryptoCurrencies);
                    if (currencyOptions.length) {
                        canUpgrade = true;
                        multi = true;
                    }
                } else {
                    canUpgrade = true;
                    multi = true;
                    currencyOptions = _.difference(legalAllowedCurrencies, existingCurrencies);
                }
            } else {
                canUpgrade = true;
                multi = true;
                currencyOptions = legalAllowedCurrencies;
            }
        } else {
            canUpgrade = false;
        }
        return {
            typeOfNextAccount: typeOfNextAccount,
            upgradeLink: upgradeLink,
            canUpgrade: canUpgrade,
            currencyOptions: currencyOptions,
            allowedMarkets: allowedMarkets,
            multi: multi
        };
    };

    $scope.$on('authorize', function (e, authorize) {
        // check for upgrade info after changing account or user selects country in profile page and updates settings
        if (currentAccount && (currentAccount.id !== authorize.loginid || currentAccount.country !== authorize.country)) {
            getAccountInfo();
        }
    });

    $scope.$on('currency:changed', function (currency) {
        getAccountInfo();
    });

    $scope.$on('landing_company', function (e, landing_company, req_id) {
        var landingCompany = landing_company;
        vm.hasMTAccess = hasMTfinancialCompany(landingCompany);
        if (req_id === 1) {
            vm.upgrade = getUpgradeInfo(landingCompany);
            if (vm.upgrade.canUpgrade) {
                appStateService.upgrade = vm.upgrade;
            } else {
                appStateService.upgrade = {};
            }
            appStateService.checkingUpgradeDone = true;
        }
    });

    vm.goToRegulatory = function () {
        var linkToRegulatory = "https://www.binary.com/" + (localStorage.getItem("language") || "en") + "/regulation.html";
        window.open(linkToRegulatory, "_blank");
    };

    vm.goToNetworkStatus = function () {
        window.open("https://binarycom.statuspage.io/", "_blank");
    };

    vm.goToResponsbileTrading = function () {
        var linkToResponsibleTrading = "https://www.binary.com/" + (localStorage.getItem("language") || "en") + "/responsible-trading.html";
        window.open(linkToResponsibleTrading, "_blank");
    };
}]);
"use strict";

/**
 * ==================  angular-ios9-uiwebview.patch.js v1.1.1 ==================
 *
 * This patch works around iOS9 UIWebView regression that causes infinite digest
 * errors in Angular.
 *
 * The patch can be applied to Angular 1.2.0 – 1.4.5. Newer versions of Angular
 * have the workaround baked in.
 *
 * To apply this patch load/bundle this file with your application and add a
 * dependency on the "ngIOS9UIWebViewPatch" module to your main app module.
 *
 * For example:
 *
 * ```
 * angular.module('myApp', ['ngRoute'])`
 * ```
 *
 * becomes
 *
 * ```
 * angular.module('myApp', ['ngRoute', 'ngIOS9UIWebViewPatch'])
 * ```
 *
 *
 * More info:
 * - https://openradar.appspot.com/22186109
 * - https://github.com/angular/angular.js/issues/12241
 * - https://github.com/driftyco/ionic/issues/4082
 *
 *
 * @license AngularJS
 * (c) 2010-2015 Google, Inc. http://angularjs.org
 * License: MIT
 */

angular.module("ngIOS9UIWebViewPatch", ["ng"]).config(["$provide", function ($provide) {
    $provide.decorator("$browser", ["$delegate", "$window", function ($delegate, $window) {
        function isIOS9UIWebView(userAgent) {
            return (/(iPhone|iPad|iPod).* OS 9_\d/.test(userAgent) && !/Version\/9\./.test(userAgent)
            );
        }

        function applyIOS9Shim(browser) {
            var pendingLocationUrl = null;
            var originalUrlFn = browser.url;

            browser.url = function () {
                if (arguments.length) {
                    pendingLocationUrl = arguments[0];
                    return originalUrlFn.apply(browser, arguments);
                }

                return pendingLocationUrl || originalUrlFn.apply(browser, arguments);
            };

            window.addEventListener("popstate", clearPendingLocationUrl, false);
            window.addEventListener("hashchange", clearPendingLocationUrl, false);

            function clearPendingLocationUrl() {
                pendingLocationUrl = null;
            }

            return browser;
        }
        if (isIOS9UIWebView($window.navigator.userAgent)) {
            return applyIOS9Shim($delegate);
        }

        return $delegate;
    }]);
}]);
"use strict";

/**
 * @contributors []
 * @since 10/25/2015
 * @copyright Binary Ltd
 */

var isBinaryMe = window.location.host === 'ticktrade.binary.me';

angular.module("binary").constant("config", {
    app_id: isBinaryMe ? "15488" : "1396",
    serverUrl: "frontend.binaryws.com",
    serverCertFP: "",
    qaMachinesCertFP: "",
    wsUrl: "wss://frontend.binaryws.com/websockets/v3", // Don't set language value here
    oauthUrl: "https://oauth.binary." + (isBinaryMe ? 'me' : 'com') + "/oauth2/authorize",
    tradeCategories: [{
        name: "up_down",
        markets: ["forex", "volidx", "random"],
        value: "UP/DOWN"
    }, {
        name: "digit_matches_differs",
        value: "MATCH/DIFF",
        markets: ["volidx", "random"],
        digits: true
    }, {
        name: "digit_even_odd",
        markets: ["volidx", "random"],
        value: "EVEN/ODD"
    }, {
        name: "digit_over_under",
        value: "OVER/UNDER",
        markets: ["volidx", "random"],
        digits: true
    }, {
        name: "asians",
        value: "Asians",
        markets: ["volidx", "random"]
    }, {
        name: "high_low_ticks",
        value: "HIGH/LOW TICKS",
        markets: ["volidx"]
    }],
    tradeTypes: [{
        name: "Up",
        value: "CALL",
        digits: false,
        selected_tick: false,
        category: "UP/DOWN"
    }, {
        name: "Down",
        value: "PUT",
        digits: false,
        selected_tick: false,
        category: "UP/DOWN"
    }, {
        name: "Asians Up",
        value: "ASIANU",
        digits: false,
        selected_tick: false,
        category: "Asians"
    }, {
        name: "Asians Down",
        value: "ASIAND",
        digits: false,
        selected_tick: false,
        category: "Asians"
    }, {
        name: "Digit Match",
        value: "DIGITMATCH",
        digits: true,
        selected_tick: false,
        category: "MATCH/DIFF"
    }, {
        name: "Digit Differs",
        value: "DIGITDIFF",
        digits: true,
        selected_tick: false,
        category: "MATCH/DIFF"
    }, {
        name: "Digit Even",
        value: "DIGITEVEN",
        digits: true,
        selected_tick: false,
        category: "EVEN/ODD"
    }, {
        name: "Digit Odd",
        value: "DIGITODD",
        digits: true,
        selected_tick: false,
        category: "EVEN/ODD"
    }, {
        name: "Digit Over",
        value: "DIGITOVER",
        digits: true,
        selected_tick: false,
        category: "OVER/UNDER"
    }, {
        name: "Digit Under",
        value: "DIGITUNDER",
        digits: true,
        selected_tick: false,
        category: "OVER/UNDER"
    }, {
        name: "TICK HIGH",
        value: "TICKHIGH",
        digits: false,
        selected_tick: true,
        category: "HIGH/LOW TICKS"
    }, {
        name: "TICK LOW",
        value: "TICKLOW",
        digits: false,
        selected_tick: true,
        category: "HIGH/LOW TICKS"
    }],
    supportedTradeTypes: ["Digits Digit Matches/Digit Differs", "Digits Digit Odd/Digit Even", "Digits Digit Over/Digit Under", "Higher/Lower", "Rise/Fall", "Asians", "Up/Down", "High/Low Ticks"],
    language: "en",
    assetIndexes: {
        symbol: 0,
        displayName: 1,
        contracts: 2,
        contractName: 0,
        contractDisplayName: 1,
        contractFrom: 2,
        contractTo: 3
    },
    cryptoConfig: {
        BTC: { name: 'bitcoin' },
        BCH: { name: 'bitcoin_cash' },
        ETH: { name: 'ether' },
        ETC: { name: 'ether_classic' },
        LTC: { name: 'litecoin' },
        DAI: { name: 'dai' }
    },
    appSupportedLanguages: ["en", "id", "ru", "zh_tw", "zh_cn", "de", "fr", "pl", "it"]
});
"use strict";

/**
 * @name currency filter decorator
 * @author Morteza Tavanarad
 * @contributors []
 * @since 10/21/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary").config(Currency);

    Currency.$inject = ["$provide"];

    function Currency($provide) {
        $provide.decorator("currencyFilter", ["accountService", function (accountService) {
            // const srcFilter = $delegate;

            var extendsFilter = function extendsFilter() {
                var locale = (localStorage.language || "en").replace("_", "-").slice(0, 2);
                var currency = arguments[1] || (accountService.getDefault() ? accountService.getDefault().currency : null);

                if (isNaN(arguments[0])) {
                    return '--';
                }
                if (_.isEmpty(currency)) {
                    return "";
                }

                return formatMoney(locale, currency, arguments[0]);
            };

            function formatMoney(locale, currency, value) {
                var options = {
                    style: "currency",
                    currency: currency || "USD"
                };

                if (/btc|xbt|ltc|bch|eth/i.test(currency)) {
                    options.minimumFractionDigits = 8;
                    options.maximumFractionDigits = 8;
                }

                return Intl.NumberFormat(locale, options).format(value);
            }
            /*
            const moneySigns = {
                USD: "$",
                GBP: "£",
                AUD: "A$",
                EUR: "€",
                JPY: "¥"
            };
            */
            return extendsFilter;
        }]);
    }
})();
'use strict';

/**
 * @name deep-link.config
 * @author Morteza Tavanarad
 * @contributors []
 * @since 10/10/2017
 * @copyright Binary Ltd
 */

angular.module('binary').run(['$ionicPlatform', '$cordovaDeeplinks', '$state', '$timeout', function ($ionicPlatform, $cordovaDeeplinks, $state, $timeout) {
    $ionicPlatform.ready(function () {
        $cordovaDeeplinks.route({
            '/redirect': {},
            '/redirect.html': {}
        }).subscribe(function (match) {
            if (match.$args && !_.isEmpty(match.$args.action)) {
                if (match.$args.action === 'signup' && !_.isEmpty(match.$args.code)) {
                    $timeout(function () {
                        $state.go('signin', { verificationCode: match.$args.code });
                    }, 100);
                } else if (match.$args.action === 'oauth') {
                    var tokens = /action=oauth&(.*)/.exec(match.$link.queryString);

                    if (_.isEmpty(tokens)) {
                        return;
                    }

                    $timeout(function () {
                        $state.go('signin', { accountTokens: tokens[1] });
                    }, 100);
                }
            } else if (match.$link.path === '/redirect.html' && !!match.$link.queryString) {
                $timeout(function () {
                    $state.go('signin', { accountTokens: match.$link.queryString });
                }, 100);
            }
        }, function (nomatch) {});
    });
}]);
"use strict";

/**
 * @name angular-ui $state decorator
 * @author Morteza Tavanarad
 * @contributors []
 * @since 11/07/2016
 * @copyright Binary Ltd
 */

(function () {
    StateDecorator.$inject = ["$provide"];
    angular.module("binary").config(StateDecorator);

    function StateDecorator($provide) {
        $provide.decorator("$state", ["$delegate", "$rootScope", function ($delegate, $rootScope) {
            var $state = $delegate;
            $state.previous = undefined;

            $state.goBack = function () {
                if ($state.previous) {
                    $state.go($state.previous.name);
                }
            };

            $rootScope.$on("$stateChangeSuccess", function (e, to, toParams, from, fromParams) {
                $state.previous = {
                    name: from,
                    params: fromParams
                };
            });

            return $state;
        }]);
    }
})();
"use strict";

/**
 * @name states.config
 * @author Massih Hazrati
 * @contributors []
 * @since 11/4/2015
 * @copyright Binary Ltd
 */

angular.module("binary").config(["$locationProvider", "$stateProvider", "$urlRouterProvider", "$ionicConfigProvider", function ($locationProvider, $stateProvider, $urlRouterProvider, $ionicConfigProvider) {
    $ionicConfigProvider.views.swipeBackEnabled(false);
    $stateProvider.state("home", {
        url: "/",
        cache: false,
        templateUrl: "js/pages/home/home.template.html",
        controller: "HomeController"
    }).state("layout", {
        cache: false,
        templateUrl: "js/share/templates/layout/main-layout.template.html",
        abstract: true
    }).state("trade", {
        parent: "layout",
        cache: false,
        controller: "TradeController",
        controllerAs: "vm",
        templateUrl: "js/pages/trade/trade.template.html"
    }).state("signin", {
        params: {
            accountTokens: null,
            verificationCode: null
        },
        cache: false,
        templateUrl: "js/pages/sign-in/sign-in.template.html",
        controller: "SigninController",
        controllerAs: "vm"
    }).state("profit-table", {
        parent: "layout",
        cache: true,
        templateUrl: "js/pages/profit-table/profit-table.template.html",
        controller: "ProfitTableController",
        controllerAs: "vm",
        detailed: true
    }).state("statement", {
        parent: "layout",
        cache: true,
        templateUrl: "js/pages/statement/statement.template.html",
        controller: "StatementController",
        controllerAs: "vm",
        detailed: true
    }).state("transaction-detail", {
        parent: "layout",
        cache: false,
        templateUrl: "js/pages/transaction-detail/transaction-detail.template.html",
        controller: "TransactionDetailController",
        controllerAs: "vm",
        reloadOnSearch: false
    }).state("real-account-opening", {
        parent: "layout",
        cache: false,
        templateUrl: "js/pages/real-account-opening/real-account-opening.template.html",
        controller: "RealAccountOpeningController",
        controllerAs: "vm"
    }).state("maltainvest-account-opening", {
        parent: "layout",
        cache: false,
        templateUrl: "js/pages/maltainvest-account-opening/maltainvest-account-opening.template.html",
        controller: "MaltainvestAccountOpeningController",
        controllerAs: "vm"
    }).state("language", {
        parent: "layout",
        cache: false,
        templateUrl: "js/pages/language/language.template.html"
    }).state("settings", {
        parent: "layout",
        cache: false,
        templateUrl: "js/pages/settings/settings.template.html",
        controller: "SettingsController",
        controllerAs: "vm",
        detailed: true
    }).state("resources", {
        parent: "layout",
        cache: false,
        templateUrl: "js/pages/resources/resources.template.html",
        controller: "ResourcesController",
        controllerAs: "vm",
        detailed: true
    }).state("self-exclusion", {
        parent: "layout",
        cache: false,
        templateUrl: "js/pages/self-exclusion/self-exclusion.template.html",
        controller: "SelfExclusionController",
        controllerAs: "vm"
    }).state("no-connection", {
        templateUrl: "js/share/components/connectivity/connectivity.template.html"
    }).state("profile", {
        parent: "layout",
        cache: false,
        templateUrl: "js/pages/profile/profile.template.html",
        controller: "ProfileController",
        controllerAs: "vm"
    }).state("terms-and-conditions", {
        parent: "layout",
        cache: false,
        templateUrl: "js/pages/terms-and-conditions/terms-and-conditions.template.html",
        controller: "TermsAndConditionsController",
        controllerAs: "vm"
    }).state("update", {
        url: "/update",
        cache: false,
        templateUrl: "js/pages/update/update.template.html",
        controller: "UpdateController",
        controllerAs: "vm"
    }).state("change-password", {
        parent: "layout",
        cache: false,
        templateUrl: "js/pages/change-password/change-password.template.html",
        controller: "ChangePasswordController",
        controllerAs: "vm"
    }).state("financial-assessment", {
        parent: "layout",
        cache: false,
        templateUrl: "js/pages/financial-assessment/financial-assessment.template.html",
        controller: "FinancialAssessmentController",
        controllerAs: "vm"
    }).state("limits", {
        parent: "layout",
        cache: false,
        templateUrl: "js/pages/limits/limits.template.html",
        controller: "LimitsController",
        controllerAs: "vm"
    }).state("trading-times", {
        parent: "layout",
        cache: false,
        templateUrl: "js/pages/trading-times/trading-times.template.html",
        controller: "TradingTimesController",
        controllerAs: "vm"
    }).state("asset-index", {
        parent: "layout",
        cache: false,
        templateUrl: "js/pages/asset-index/asset-index.template.html",
        controller: "AssetIndexController",
        controllerAs: "vm"
    }).state("meta-trader", {
        parent: "layout",
        cache: false,
        templateUrl: "js/pages/meta-trader/meta-trader.template.html",
        controller: "MetaTraderController",
        controllerAs: "vm"
    }).state("mt5-web", {
        parent: "layout",
        params: {
            id: null
        },
        cache: false,
        templateUrl: "js/pages/meta-trader/mt5-web.template.html",
        controller: "MT5WebController",
        controllerAs: "vm"
    }).state("outage", {
        params: {
            message: null
        },
        controller: "ServiceOutagePageController",
        controllerAs: "vm",
        templateUrl: "js/share/components/service-outage/service-outage.template.html"
    }).state("authentication", {
        parent: "layout",
        cache: false,
        templateUrl: "js/pages/authentication/authentication.template.html",
        controller: "AuthenticationController",
        controllerAs: "vm",
        detailed: true
    }).state("contact", {
        parent: "layout",
        cache: true,
        templateUrl: "js/pages/contact/contact.template.html",
        controller: "ContactController",
        controllerAs: "vm"
    }).state("notifications", {
        parent: "layout",
        cache: false,
        templateUrl: "js/pages/notifications/notifications.template.html",
        controller: "NotificationsController",
        controllerAs: "vm",
        detailed: true
    }).state("set-currency", {
        parent: "layout",
        cache: false,
        templateUrl: "js/pages/set-currency/set-currency.template.html",
        controller: "SetCurrencyController",
        controllerAs: "vm"
    }).state("accounts-management", {
        parent: "layout",
        cache: false,
        templateUrl: "js/pages/accounts-management/accounts-management.template.html",
        controller: "AccountsManagementController",
        controllerAs: "vm"
    }).state('redirect', {
        url: "/redirect",
        cache: "false",
        templateUrl: "js/pages/redirect/redirect.template.html",
        controller: "RedirectController",
        controllerAs: "vm"
    }).state('account-categorisation', {
        parent: "layout",
        cache: "false",
        templateUrl: "js/pages/account-categorisation/account-categorisation.template.html",
        controller: "AccountCategorisationController",
        controllerAs: "vm"
    });

    $urlRouterProvider.otherwise("/");

    var baseElement = document.getElementsByTagName('base');

    if (baseElement.length) {
        $locationProvider.html5Mode(true);
    }
}]);
"use strict";

/**
 * @name translation.config
 * @author Morteza Tavanarad
 * @contributors []
 * @since 8/7/2016
 * @copyright Binary Ltd
 */

angular.module("binary").config(["$translateProvider", function ($translateProvider) {
    var language = localStorage.language || "en";
    $translateProvider.fallbackLanguage("en");
    $translateProvider.preferredLanguage(language);
    $translateProvider.useStaticFilesLoader({
        prefix: "i18n/",
        suffix: ".json"
    });
}]);
"use strict";

angular.module("binary").constant("accountOptions", {
    salutation: [{
        text: 'account-options.mr',
        value: 'Mr'
    }, {
        text: 'account-options.mrs',
        value: 'Mrs'
    }, {
        text: 'account-options.miss',
        value: 'Miss'
    }, {
        text: 'account-options.ms',
        value: 'Ms'
    }],
    account_opening_reason: [{
        text: 'account-options.speculative',
        value: 'Speculative'
    }, {
        text: 'account-options.income_earning',
        value: 'Income Earning'
    }, {
        text: 'account-options.hedging',
        value: 'Hedging'
    }],
    secret_question: [{
        text: 'account-options.secret_question_1',
        value: 'Mother\'s maiden name'
    }, {
        text: 'account-options.secret_question_2',
        value: 'Name of your pet'
    }, {
        text: 'account-options.secret_question_3',
        value: 'Name of first love'
    }, {
        text: 'account-options.secret_question_4',
        value: 'Memorable town/city'
    }, {
        text: 'account-options.secret_question_5',
        value: 'Memorable date'
    }, {
        text: 'account-options.secret_question_6',
        value: 'Favourite dish'
    }, {
        text: 'account-options.secret_question_7',
        value: 'Brand of first car'
    }, {
        text: 'account-options.secret_question_8',
        value: 'Favourite artist'
    }]
});
"use strict";

angular.module("binary").constant("financialInformationOptions", {
    experienceOptions: [{
        text: 'financial-information-options.under_1_year',
        value: '0-1 year'
    }, {
        text: 'financial-information-options.1_2_years',
        value: '1-2 years'
    }, {
        text: 'financial-information-options.over_3_years',
        value: 'Over 3 years'
    }],
    frequencyOptions: [{
        text: 'financial-information-options.0_5_transactions',
        value: '0-5 transactions in the past 12 months'
    }, {
        text: 'financial-information-options.6_10_transactions',
        value: '6-10 transactions in the past 12 months'
    }, {
        text: 'financial-information-options.transactions_more',
        value: '40 transactions or more in the past 12 months'
    }],
    employment_industry: [{
        text: 'financial-information-options.construction',
        value: 'Construction'
    }, {
        text: 'financial-information-options.education',
        value: 'Education'
    }, {
        text: 'financial-information-options.finance',
        value: 'Finance'
    }, {
        text: 'financial-information-options.health',
        value: 'Health'
    }, {
        text: 'financial-information-options.tourism',
        value: 'Tourism'
    }, {
        text: 'financial-information-options.other',
        value: 'Other'
    }],
    education_level: [{
        text: 'financial-information-options.primary',
        value: 'Primary'
    }, {
        text: 'financial-information-options.secondary',
        value: 'Secondary'
    }, {
        text: 'financial-information-options.tertiary',
        value: 'Tertiary'
    }],
    income_source: [{
        text: 'financial-information-options.salaried',
        value: 'Salaried Employee'
    }, {
        text: 'financial-information-options.self_employed',
        value: 'Self-Employed'
    }, {
        text: 'financial-information-options.investment',
        value: 'Investments & Dividends'
    }, {
        text: 'financial-information-options.pension',
        value: 'Pension'
    }, {
        text: 'financial-information-options.other',
        value: 'Other'
    }],
    employment_status: [{
        text: 'financial-information-options.employed',
        value: 'Employed'
    }, {
        text: 'financial-information-options.pensioner',
        value: 'Pensioner'
    }, {
        text: 'financial-information-options.self_employed',
        value: 'Self-Employed'
    }, {
        text: 'financial-information-options.student',
        value: 'Student'
    }, {
        text: 'financial-information-options.unemployed',
        value: 'Unemployed'
    }],
    occupation: [{
        text: 'financial-information-options.chief_executives',
        value: 'Chief Executives, Senior Officials and Legislators'
    }, {
        text: 'financial-information-options.managers',
        value: 'Managers'
    }, {
        text: 'financial-information-options.professionals',
        value: 'Professionals'
    }, {
        text: 'financial-information-options.clerks',
        value: 'Clerks'
    }, {
        text: 'financial-information-options.personal_care',
        value: 'Personal Care, Sales and Service Workers'
    }, {
        text: 'financial-information-options.agricultural',
        value: 'Agricultural, Forestry and Fishery Workers'
    }, {
        text: 'financial-information-options.craft',
        value: 'Craft, Metal, Electrical and Electronics Workers'
    }, {
        text: 'financial-information-options.machine',
        value: 'Plant and Machine Operators and Assemblers'
    }, {
        text: 'financial-information-options.helpers',
        value: 'Cleaners and Helpers'
    }, {
        text: 'financial-information-options.mining',
        value: 'Mining, Construction, Manufacturing and Transport Workers'
    }, {
        text: 'financial-information-options.armed_forces',
        value: 'Armed Forces'
    }, {
        text: 'financial-information-options.government_officers',
        value: 'Government Officers'
    }, {
        text: 'financial-information-options.others',
        value: 'Others'
    }],
    source_of_wealth: [{
        text: 'financial-information-options.accumulation_of_income_savings',
        value: 'Accumulation of Income/Savings'
    }, {
        text: 'financial-information-options.cash_business',
        value: 'Cash Business'
    }, {
        text: 'financial-information-options.company_ownership',
        value: 'Company Ownership'
    }, {
        text: 'financial-information-options.divorce_settlement',
        value: 'Divorce Settlement'
    }, {
        text: 'financial-information-options.inheritance',
        value: 'Inheritance'
    }, {
        text: 'financial-information-options.investment_income',
        value: 'Investment Income'
    }, {
        text: 'financial-information-options.sale_of_property',
        value: 'Sale of Property'
    }, {
        text: 'financial-information-options.other',
        value: 'Other'
    }],
    net_income: [{
        text: 'financial-information-options.net_income_1',
        value: 'Less than $25,000'
    }, {
        text: 'financial-information-options.net_income_2',
        value: '$25,000 - $50,000'
    }, {
        text: 'financial-information-options.net_income_3',
        value: '$50,001 - $100,000'
    }, {
        text: 'financial-information-options.net_income_4',
        value: '$100,001 - $500,000'
    }, {
        text: 'financial-information-options.net_income_5',
        value: 'Over $500,000'
    }],
    estimated_worth: [{
        text: 'financial-information-options.estimated_worth_1',
        value: 'Less than $100,000'
    }, {
        text: 'financial-information-options.estimated_worth_2',
        value: '$100,000 - $250,000'
    }, {
        text: 'financial-information-options.estimated_worth_3',
        value: '$250,001 - $500,000'
    }, {
        text: 'financial-information-options.estimated_worth_4',
        value: '$500,001 - $1,000,000'
    }, {
        text: 'financial-information-options.estimated_worth_5',
        value: 'Over $1,000,000'
    }],
    account_turnover: [{
        text: 'financial-information-options.account_turnover_1',
        value: 'Less than $25,000'
    }, {
        text: 'financial-information-options.account_turnover_2',
        value: '$25,000 - $50,000'
    }, {
        text: 'financial-information-options.account_turnover_3',
        value: '$50,001 - $100,000'
    }, {
        text: 'financial-information-options.account_turnover_4',
        value: '$100,001 - $500,000'
    }, {
        text: 'financial-information-options.account_turnover_5',
        value: 'Over $500,000'
    }]
});
"use strict";

/**
 * @name account categorisation controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 06/17/2018
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.account-categorisation.controllers").controller("AccountCategorisationController", AccountCategorisation);

    AccountCategorisation.$inject = ["$scope", "$state", "$timeout", "$translate", "websocketService", "accountService", "clientService", "alertService"];

    function AccountCategorisation($scope, $state, $timeout, $translate, websocketService, accountService, clientService, alertService) {
        var vm = this;
        var loginid = '';
        var params = {
            request_professional_status: 0,
            tax_identification_number: '',
            tax_residence: ''
        };

        var hasValueIn = function hasValueIn(arr, val) {
            return _.indexOf(arr, val) > -1;
        };
        var isLandingCompanyOf = function isLandingCompanyOf(targetLandingCompany, accountLandingCompany) {
            return clientService.isLandingCompanyOf(targetLandingCompany, accountLandingCompany);
        };

        $scope.$on('set-settings:error', function (e, error) {
            if (error.code === 'InputValidationFailed') {
                $state.go('profile');
            } else {
                alertService.displayError(error.message);
            }
        });

        $scope.$on('set-settings', function (e, message) {
            init();
        });

        $scope.$on('get_settings', function (e, get_settings) {
            _.forEach(params, function (val, k) {
                if (get_settings[k]) params[k] = get_settings[k];
            });
            params.request_professional_status = 1;
            websocketService.sendRequestFor.setAccountSettings(params);
        });

        $scope.$on('authorize', function (e, authorize) {
            if (authorize && authorize.loginid !== loginid) {
                loginid = authorize.loginid;
                var isFinancial = isLandingCompanyOf('maltainvest', authorize.landing_company_name);
                if (!isFinancial) {
                    $state.go('trade');
                } else {
                    init();
                }
            }
        });

        vm.openProfessionalClientInformation = function () {
            alertService.showProfessioanlClientInformation($scope);
        };

        vm.updateClientType = function () {
            websocketService.sendRequestFor.accountSetting();
        };

        vm.showConfirmProfessionalClient = function () {
            if (vm.client_type) {
                alertService.displayProfessionalClientConfirmation($translate.instant('professional-client-confirmation.professional_clients'), 'information-popup', $scope, 'js/share/templates/professional-client/professional-client-confirmation.template.html', [{
                    text: $translate.instant("professional-client-confirmation.decline"),
                    onTap: function onTap() {
                        return vm.client_type = 0;
                    }
                }, {
                    text: $translate.instant("professional-client-confirmation.accept"),
                    type: "button-positive",
                    onTap: function onTap() {
                        return true;
                    }
                }]);
            }
        };

        $scope.$on('get_account_status', function (e, message) {
            vm.isDataLoaded = true;
            var status = message.status;
            if (status) {
                if (hasValueIn(status, 'professional')) {
                    vm.userState = 'professional';
                } else if (hasValueIn(status, 'professional_requested')) {
                    vm.userState = 'processing';
                } else {
                    vm.userState = 'retail';
                }
            } else {
                vm.hasError = true;
            }
            $scope.$apply();
        });

        var init = function init() {
            vm.isDataLoaded = false;
            vm.userState = '';
            var account = accountService.getDefault();
            if (account) {
                loginid = account.id;
                var landingcompany = account.landing_company_name;
                var isFinancial = isLandingCompanyOf('maltainvest', landingcompany);
                if (isFinancial) {
                    websocketService.sendRequestFor.getAccountStatus();
                } else {
                    $state.go('trade');
                }
            } else {
                $timeout(init, 1000);
            }
        };

        init();
    }
})();
"use strict";

/**
 * @name Accounts management controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 10/28/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.accounts-management.controllers").controller("AccountsManagementController", AccountsManagement);

    AccountsManagement.$inject = ["$scope", "$state", "$filter", "$timeout", "$translate", "appStateService", "accountService", "clientService", "websocketService", "alertService"];

    function AccountsManagement($scope, $state, $filter, $timeout, $translate, appStateService, accountService, clientService, websocketService, alertService) {
        var vm = this;
        var hasRealAccount = false;
        var upgradingRealAccountDirectly = false;
        vm.upgradeButtonDisabled = false;
        var activeMarkets = {
            commodities: $translate.instant('accounts-management.commodities'),
            forex: $translate.instant('accounts-management.forex'),
            indices: $translate.instant('accounts-management.indices'),
            stocks: $translate.instant('accounts-management.stocks'),
            volidx: $translate.instant('accounts-management.volidx')
        };

        var requiredDirectUpgradeFields = ['salutation', 'first_name', 'last_name', 'date_of_birth', 'residence', 'place_of_birth', 'address_line_1', 'address_city', 'phone', 'account_opening_reason'];

        var directUpgradeData = {
            salutation: '',
            first_name: '',
            last_name: '',
            date_of_birth: '',
            place_of_birth: '',
            residence: '',
            address_line_1: '',
            address_line_2: '',
            address_city: '',
            address_state: '',
            address_postcode: '',
            phone: '',
            account_opening_reason: ''
        };

        var filterMarkets = function filterMarkets(markets) {
            var availableMarkets = [];
            _.forEach(markets, function (market) {
                if (market in activeMarkets && _.indexOf(availableMarkets, activeMarkets[market]) < 0) {
                    availableMarkets.push(activeMarkets[market]);
                }
            });
            return availableMarkets;
        };

        var isCryptocurrency = function isCryptocurrency(currencyConfig, curr) {
            return (/crypto/i.test(currencyConfig[curr].type)
            );
        };

        var getNextAccountTitle = function getNextAccountTitle(typeOfNextAccount) {
            var nextAccount = void 0;
            if (typeOfNextAccount === 'real') {
                nextAccount = $translate.instant('accounts-management.account_real');
            } else if (typeOfNextAccount === 'financial') {
                nextAccount = $translate.instant('accounts-management.account_financial');
            }
            return nextAccount;
        };

        var getCurrenciesForNewAccount = function getCurrenciesForNewAccount(currencies) {
            var currencyConfig = appStateService.currenciesConfig;
            var currenciesLength = currencies.length;
            var currencyOptions = [];
            for (var i = 0; i < currenciesLength; i++) {
                var currencyObject = {};
                var curr = currencies[i];
                currencyObject.name = curr;
                // adding translate labels to currencies
                currencyObject.currencyGroup = isCryptocurrency(currencyConfig, curr) ? $translate.instant('accounts-management.crypto_currencies') : $translate.instant('accounts-management.fiat_currencies');
                currencyOptions.push(currencyObject);
            }
            return currencyOptions;
        };

        var accountType = function accountType(landingCompany) {
            return clientService.getAccountType(landingCompany);
        };

        var getAvailableMarkets = function getAvailableMarkets(landingCompany) {
            var legalAllowedMarkets = clientService.landingCompanyValue(landingCompany, 'legal_allowed_markets');
            var availableMarkets = [];
            if (Array.isArray(legalAllowedMarkets) && legalAllowedMarkets.length) {
                availableMarkets = _.join(filterMarkets(legalAllowedMarkets), ', ');
            }
            return availableMarkets;
        };

        var getExistingAccounts = function getExistingAccounts() {
            var existingAccounts = [];
            _.forEach(vm.accounts, function (acc) {
                var account = {};
                account.id = acc.id;
                account.isDisabled = acc.is_disabled;
                account.excludedUntil = acc.excluded_until ? $filter('date')(acc.excluded_until * 1000, 'yyyy-MM-dd HH:mm:ss') : false;
                account.availableMarkets = getAvailableMarkets(acc.landing_company_name);
                account.type = accountType(acc.landing_company_name);
                if (vm.currentAccount.id !== account.id) {
                    account.currency = acc.currency || '-';
                } else {
                    account.currency = acc.currency;
                }
                existingAccounts.push(account);
            });
            return existingAccounts;
        };

        var getAvailableAccounts = function getAvailableAccounts() {
            vm.upgrade = appStateService.upgrade;
            if (vm.upgrade.canUpgrade) {
                vm.legalAllowedMarkets = _.join(filterMarkets(vm.upgrade.allowedMarkets), ', ');
                vm.titleOfNextAccount = getNextAccountTitle(vm.upgrade.typeOfNextAccount);
                vm.newAccountCurrencyOptions = getCurrenciesForNewAccount(vm.upgrade.currencyOptions);
                if (vm.newAccountCurrencyOptions.length) {
                    vm.selectedCurrency = vm.newAccountCurrencyOptions[0].name;
                }
            }
        };

        var init = function init() {
            vm.accounts = accountService.getAll();
            vm.currentAccount = accountService.getDefault();
            var landingCompany = vm.currentAccount.landing_company_name;
            vm.isMultiAccount = clientService.isLandingCompanyOf('costarica', landingCompany) || clientService.isLandingCompanyOf('svg', landingCompany);
            vm.selectCurrencyError = false;
            getAvailableAccounts();
            vm.existingAccounts = getExistingAccounts();
            hasRealAccount = !!_.find(vm.existingAccounts, function (acc) {
                return acc.type === 'real';
            });
            vm.showContact = _.some(vm.existingAccounts, function (acc) {
                return acc.isDisabled || acc.excludedUntil;
            });
        };

        vm.redirectToSetCurrency = function () {
            $state.go('set-currency');
        };

        vm.openNewAccount = function () {
            if ((vm.currentAccount.currency && vm.currentAccount.currency !== '' || !vm.upgrade.multi) && !vm.upgradeButtonDisabled) {
                vm.upgradeButtonDisabled = true;
                appStateService.selectedCurrency = vm.selectedCurrency;
                appStateService.redirectedFromAccountsManagemenet = true;
                if (vm.upgrade.typeOfNextAccount === 'real') {
                    if (hasRealAccount) {
                        upgradingRealAccountDirectly = true;
                        websocketService.sendRequestFor.accountSetting();
                    } else {
                        $state.go('real-account-opening');
                    }
                } else if (vm.upgrade.typeOfNextAccount === 'financial') {
                    $state.go('maltainvest-account-opening');
                }
            } else {
                $scope.$applyAsync(function () {
                    vm.upgradeButtonDisabled = false;
                    vm.selectCurrencyError = true;
                });
            }
        };

        $scope.$on("get_settings", function (e, get_settings) {
            if (upgradingRealAccountDirectly && get_settings) {
                _.forEach(directUpgradeData, function (val, k) {
                    if (get_settings[k]) directUpgradeData[k] = get_settings[k];
                });
                directUpgradeData.residence = get_settings.country_code;
                directUpgradeData.date_of_birth = get_settings.date_of_birth ? $filter("date")(get_settings.date_of_birth * 1000, "yyyy-MM-dd") : '';
                directUpgradeData.currency = vm.selectedCurrency;
                // Some users have upgraded their account before the place_of_birth became required for real_account_opening
                // redirect these users to upgrade page to fill the form with place_of_birth included
                if (_.findIndex(requiredDirectUpgradeFields, function (field) {
                    return !directUpgradeData[field];
                }) > -1) {
                    $state.go('profile');
                } else {
                    websocketService.sendRequestFor.createRealAccountSend(directUpgradeData);
                }
            }
        });

        $scope.$on("new_account_real:error", function (e, error) {
            vm.upgradeButtonDisabled = false;
            if (error.hasOwnProperty("details")) {
                alertService.displayError(error.details);
            } else if (error.code) {
                alertService.displayError(error.message);
            }
        });

        $scope.$on("new_account_real", function (e, new_account_real) {
            var selectedAccount = new_account_real.oauth_token;
            websocketService.authenticate(selectedAccount);
            appStateService.newAccountAdded = true;
            accountService.addedAccount = selectedAccount;
            vm.upgradeButtonDisabled = false;
        });

        var reInitAfterChangeAccount = function reInitAfterChangeAccount() {
            if (appStateService.checkingUpgradeDone) {
                init();
            } else {
                $timeout(reInitAfterChangeAccount, 500);
            }
        };

        $scope.$on('authorize', function (e, authorize) {
            if (vm.currentAccount.id !== authorize.loginid) {
                reInitAfterChangeAccount();
            }
        });

        init();
    }
})();
"use strict";

/**
 * @name Asset Index controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 01/26/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.asset-index.controllers").controller("AssetIndexController", AssetIndex);

    AssetIndex.$inject = ["$scope", "$q"];

    function AssetIndex($scope, $q) {
        var vm = this;
        vm.hasError = false;
        vm.assetIndex = JSON.parse(sessionStorage.asset_index || null);
        vm.activeSymbols = JSON.parse(sessionStorage.all_active_symbols);

        vm.getSymbolInfo = function (qSymbol, activeSymbols) {
            return _.filter(activeSymbols, function (sy, id) {
                return sy.symbol === qSymbol;
            });
        };

        vm.getAssetIndexData = function (assetIndex, activeSymbols) {
            if (!assetIndex || !activeSymbols) {
                return false;
            }

            vm.marketColumns = {};

            var idx = {
                symbol: 0,
                displayName: 1,
                cells: 2,
                cellName: 0,
                cellDisplayName: 1,
                cellFrom: 2,
                cellTo: 3,
                symInfo: 3,
                values: 4
            };

            for (var i = 0; i < assetIndex.length; i++) {
                vm.assetItem = assetIndex[i];
                vm.symbolInfo = vm.getSymbolInfo(vm.assetItem[idx.symbol], activeSymbols)[0];
                if (vm.symbolInfo) {
                    var market = vm.symbolInfo.market;

                    vm.assetItem.push(vm.symbolInfo);

                    if (!(market in vm.marketColumns)) {
                        vm.marketColumns[market] = {
                            header: [],
                            columns: [],
                            sub: [],
                            displayName: vm.symbolInfo.market_display_name
                        };
                    }

                    vm.assetCells = vm.assetItem[idx.cells];
                    var values = {};
                    for (var j = 0; j < vm.assetCells.length; j++) {
                        var col = vm.assetCells[j][idx.displayName];
                        values[col] = vm.assetCells[j][idx.cellFrom] + " - " + vm.assetCells[j][idx.cellTo];
                        var marketCols = vm.marketColumns[market];
                        if (marketCols.columns.indexOf(col) < 0) {
                            marketCols.header.push(vm.assetCells[j][idx.cellDisplayName]);
                            marketCols.columns.push(col);
                        }
                    }
                    vm.assetItem.push(values);
                }
            }
            vm.assetIndex = assetIndex;
            return vm.assetIndex;
        };
        vm.getMarketColumns = function () {
            $scope.$applyAsync(function () {
                if (vm.marketColumns) {
                    vm.selectedMarket = Object.getOwnPropertyNames(vm.marketColumns)[0];
                }
            });
            vm.hasError = false;
            return vm.marketColumns;
        };

        vm.getSubmarketTable = function (marketColumns, assetIndex) {
            vm.submarketNames = {};
            if (assetIndex) {
                for (var i = 0; i < assetIndex.length; i++) {
                    var assetItem = assetIndex[i];
                    if (assetItem[3]) {
                        var symInfo = assetItem[3];
                        var marketId = symInfo.market;
                        var subMarketId = symInfo.submarket;
                        var submarketDisplayName = symInfo.submarket_display_name;
                        if (marketColumns[marketId].sub.indexOf(subMarketId) < 0) {
                            marketColumns[marketId].sub.push(subMarketId);
                            vm.submarketNames[subMarketId] = submarketDisplayName;
                        }
                    }
                }
            }
        };
        vm.getAssetIndexData(vm.assetIndex, vm.activeSymbols);
        var promise = $q(function (resolve) {
            if (vm.getMarketColumns()) resolve();
        });
        promise.then(function () {
            vm.getSubmarketTable(vm.marketColumns, vm.assetIndex);
            vm.hasError = false;
        });
    }
})();
"use strict";

/**
 * @name authentication controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 04/27/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.authentication.controllers").controller("AuthenticationController", Authentication);

    Authentication.$inject = [];

    function Authentication() {
        var vm = this;
    }
})();
"use strict";

/**
 * @name Contact controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 04/29/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.contact.controllers").controller("ContactController", Contact);

    Contact.$inject = [];

    function Contact() {
        var vm = this;
        vm.data = {};

        vm.data.selectedCountry = "australia";
        vm.data.countries = {
            australia: {
                phone: {
                    phone_1: {
                        num: "+61 (02) 8294 5448"
                    },
                    phone_2: {
                        num: "1800 093570",
                        toll_free: true
                    }
                }
            },
            canada: {
                phone: {
                    phone_1: {
                        num: "+1 (450) 823 1002"
                    }
                }
            },
            indonesia: {
                phone: {
                    phone_1: {
                        num: "0018030113641",
                        toll_free: true
                    }
                }
            },
            ireland: {
                phone: {
                    phone_1: {
                        num: "+353 (0) 76 888 7500"
                    },
                    phone_2: {
                        num: "1800931084",
                        toll_free: true
                    }
                }
            },
            poland: {
                phone: {
                    phone_1: {
                        num: "+48 58 881 00 02"
                    }
                }
            },
            russia: {
                phone: {
                    phone_1: {
                        num: "8 10 8002 8553011",
                        toll_free: true
                    }
                }
            },
            united_kingdom: {
                phone: {
                    phone_1: {
                        num: "+44 (0) 1666 800042"
                    },
                    phone_2: {
                        num: "0800 011 9847",
                        toll_free: true
                    }
                }
            }
        };
    }
})();
"use strict";

/**
 * @name Change Password controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 01/11/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.change-password.controllers").controller("ChangePasswordController", ChangePassword);

    ChangePassword.$inject = ["$scope", "$timeout", "websocketService", "appStateService", "alertService", "validationService"];

    function ChangePassword($scope, $timeout, websocketService, appStateService, alertService, validationService) {
        var vm = this;
        vm.validation = validationService;
        vm.passwordEqual = false;
        vm.newPasswordHasError = false;
        vm.oldPasswordHasError = false;
        vm.hideInput = false;
        vm.hideChangedPasswordText = true;

        vm.checkPassword = function () {
            $scope.$applyAsync(function () {
                vm.passwordEqual = vm.newPassword === vm.repeatNewPassword;
            });
        };

        vm.changePass = function () {
            websocketService.sendRequestFor.changePassword(vm.currentPassword, vm.newPassword);
            vm.newPasswordHasError = false;
            vm.oldPasswordHasError = false;
            vm.passwordUpdating = true;
        };

        $scope.$on("change_password:success", function (e, change_password) {
            appStateService.passwordChanged = true;
            vm.passwordUpdating = false;
            $scope.$applyAsync(function () {
                vm.hideInput = true;
                vm.hideChangedPasswordText = false;
            });
            $timeout(function () {
                websocketService.logout();
            }, 5000);
        });

        $scope.$on("change_password:error", function (e, error) {
            vm.passwordUpdating = false;
            if (error.hasOwnProperty("details")) {
                if (error.details.hasOwnProperty("new_password")) {
                    $scope.$applyAsync(function () {
                        vm.newPasswordHasError = true;
                        vm.newPasswordError = error.details.new_password;
                    });
                }
                if (error.details.hasOwnProperty("old_password")) {
                    $scope.$applyAsync(function () {
                        vm.oldPasswordHasError = true;
                        vm.oldPasswordError = error.details.old_password;
                    });
                }
            } else {
                alertService.displayError(error.message);
            }
        });
    }
})();
"use strict";

/**
 * @name Financial Assessment controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 01/15/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.financial-assessment.controllers").controller("FinancialAssessmentController", FinancialAssessment);

    FinancialAssessment.$inject = ["$scope", "$translate", "websocketService", "alertService", "clientService", "financialInformationOptions"];

    function FinancialAssessment($scope, $translate, websocketService, alertService, clientService, financialInformationOptions) {
        var vm = this;
        var landingCompany = localStorage.getItem('landingCompany');
        vm.isFinancial = clientService.isAccountOfType('financial', landingCompany);
        vm.errors = {};
        vm.options = financialInformationOptions;
        vm.disableUpdateButton = false;
        vm.notAnyChanges = false;
        vm.isDataLoaded = false;
        vm.data = {
            'education_level': '',
            'employment_industry': '',
            'estimated_worth': '',
            'income_source': '',
            'employment_status': '',
            'net_income': '',
            'occupation': '',
            'source_of_wealth': '',
            'account_turnover': ''
        };
        var financialAssessmentData = {
            'forex_trading_experience': '',
            'forex_trading_frequency': '',
            'other_instruments_trading_experience': '',
            'other_instruments_trading_frequency': '',
            'binary_options_trading_experience': '',
            'binary_options_trading_frequency': '',
            'cfd_trading_experience': '',
            'cfd_trading_frequency': ''
        };

        $scope.$on("get_financial_assessment:success", function (e, financial_assessment) {
            vm.financialAssessment = _.clone(financial_assessment);
            _.forEach(vm.data, function (val, k) {
                return vm.data[k] = financial_assessment[k];
            });
            vm.isDataLoaded = true;
            $scope.$apply();
        });

        vm.submitFinancialAssessment = function () {
            vm.errors = {};
            vm.notAnyChanges = !_.some(vm.data, function (val, key) {
                return vm.financialAssessment[key] !== vm.data[key];
            });
            if (!vm.notAnyChanges) {
                vm.disableUpdateButton = true;
                websocketService.sendRequestFor.setFinancialAssessment(vm.data);
            }
        };

        $scope.$on("set_financial_assessment:success", function (e, set_financial_assessment) {
            if (set_financial_assessment) {
                alertService.displayAlert($translate.instant('financial-assessment.success'), $translate.instant('financial-assessment.success_message'));
            }
            websocketService.sendRequestFor.getFinancialAssessment();
            vm.disableUpdateButton = false;
        });

        $scope.$on("set_financial_assessment:error", function (e, error) {
            vm.disableUpdateButton = false;
            if (error.hasOwnProperty("details")) {
                $scope.$applyAsync(function () {
                    vm.errors = error.details;
                });
            } else if (error.code) {
                alertService.displayError(error.message);
            }
        });

        var init = function init() {
            if (vm.isFinancial) {
                _.assign(vm.data, financialAssessmentData);
            }
            websocketService.sendRequestFor.getFinancialAssessment();
        };

        init();
    }
})();
"use strict";

/**
 * @name HomeController
 * @author Morteza Tavanarad
 * @contributors []
 * @since 8/9/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.home.controllers").controller("HomeController", Home);

    Home.$inject = ["$scope", "$state", "accountService", "analyticsService", "appStateService"];

    function Home($scope, $state, accountService, analyticsService, appStateService) {
        var vm = this;
        /**
        * wait untile authorization and decide
        * to redirect user  to the proper page
        */
        $scope.$on("authorize", function (e, response) {
            if (response) {
                setTimeout(function () {
                    $state.go("trade");
                }, 1000);
            } else {
                $state.go("signin");
            }
        });

        var init = function init() {
            // send track view to Google Analytics
            analyticsService.google.trackView("Home");

            // Check that is saved any default account or not
            if (accountService.hasDefault()) {
                // Login to the server if there is any default account
                if (!appStateService.isLoggedin) {
                    accountService.validate();
                } else {
                    $state.go("trade");
                }
            } else {
                accountService.removeAll();
                $state.go("signin");
            }
        };

        init();
    }
})();
"use strict";

/**
 * @name Limits controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 01/18/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.limits.controllers").controller("LimitsController", Limits);

    Limits.$inject = ["$scope", "$state", "websocketService", "accountService", "appStateService", "clientService"];

    function Limits($scope, $state, websocketService, accountService, appStateService, clientService) {
        var vm = this;
        vm.limits = {};
        vm.isDataLoaded = false;
        var account = accountService.getDefault();
        vm.loginid = account.id;
        var landingCompany = account.landing_company_name;
        vm.currency = account.currency && account.currency.length ? account.currency : clientService.landingCompanyValue(landingCompany, 'legal_default_currency');

        var isLandingCompanyOf = function isLandingCompanyOf(targetLandingCompany, accountLandingCompany) {
            return clientService.isLandingCompanyOf(targetLandingCompany, accountLandingCompany);
        };

        websocketService.sendRequestFor.accountLimits();
        $scope.$on("get_limits", function (e, get_limits) {
            $scope.$applyAsync(function () {
                vm.limits = get_limits;
                if (vm.limits.lifetime_limit === 99999999 && vm.limits.num_of_days_limit === 99999999) {
                    // fully aithenticated
                    vm.fullyAuthenticated = true;
                    vm.mxAccount = false;
                    vm.crAccount = false;
                    vm.otherAccount = false;
                } else if (isLandingCompanyOf('iom', landingCompany)) {
                    // MX accounts
                    vm.mxAccount = true;
                    vm.fullyAuthenticated = false;
                    vm.crAccount = false;
                    vm.otherAccount = false;
                } else if (isLandingCompanyOf('costarica', landingCompany) || isLandingCompanyOf('svg', landingCompany)) {
                    // CR accounts
                    vm.crAccount = true;
                    vm.fullyAuthenticated = false;
                    vm.mxAccount = false;
                    vm.otherAccount = false;
                } else {
                    vm.otherAccount = true;
                    vm.fullyAuthenticated = false;
                    vm.mxAccount = false;
                    vm.crAccount = false;
                }
            });
            vm.isDataLoaded = true;
        });

        $scope.$on("authorize", function () {
            if (appStateService.limitsChange) {
                if (appStateService.virtuality) {
                    $state.go("trade");
                } else {
                    $state.reload();
                }
                appStateService.limitsChange = false;
            }
        });

        vm.getLanguageId = function (title) {
            return "limits." + title.replace(/[\s]/g, '_').toLowerCase();
        };
    }
})();
"use strict";

/**
 * @name maltainvest-account-opening controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.maltainvest-account-opening").controller("MaltainvestAccountOpeningController", MaltainvestAccountOpening);

    MaltainvestAccountOpening.$inject = ["$scope", "$state", "$filter", "$translate", "$ionicModal", "$ionicScrollDelegate", "websocketService", "appStateService", "accountService", "alertService", "clientService", "validationService", "accountOptions", "financialInformationOptions"];

    function MaltainvestAccountOpening($scope, $state, $filter, $translate, $ionicModal, $ionicScrollDelegate, websocketService, appStateService, accountService, alertService, clientService, validationService, accountOptions, financialInformationOptions) {
        var vm = this;
        vm.errors = {};
        vm.settingTaxResidence = [];
        vm.disableUpdatebutton = false;
        vm.touchedTaxResidence = false;
        vm.hasResidence = false;
        vm.hasPOB = false;
        vm.hasCitizen = false;
        var modalIsSubmitted = false;
        vm.showRiskDisclaimer = false;
        vm.tncAccepted = false;
        var acceptRisk = 0;
        var landingCompany = accountService.getDefault().landing_company_name;
        var isVirtual = clientService.isLandingCompanyOf('virtual', landingCompany);
        var accounts = accountService.getAll();
        var upgradableLandingCompanies = appStateService.upgradeableLandingCompanies;
        vm.hasIOM = _.indexOf(upgradableLandingCompanies, 'iom') > -1 || clientService.hasAccountOfLandingCompany(accounts, 'iom');
        vm.receivedSettings = false;
        vm.options = _.merge(financialInformationOptions, accountOptions);
        vm.validation = validationService;
        var linkToTermAndConditions = "https://www.binary.com/" + (localStorage.getItem("language") || "en") + "/terms-and-conditions.html";
        var linkToTINSite = 'https://ec.europa.eu/taxation_customs/tin/tinByCountry.html';
        vm.data = {
            salutation: '',
            first_name: '',
            last_name: '',
            date_of_birth: '',
            residence: '',
            place_of_birth: '',
            citizen: '',
            address_line_1: '',
            address_line_2: '',
            address_city: '',
            address_state: '',
            address_postcode: '',
            phone: '',
            forex_trading_experience: '',
            forex_trading_frequency: '',
            binary_options_trading_experience: '',
            binary_options_trading_frequency: '',
            cfd_trading_experience: '',
            cfd_trading_frequency: '',
            other_instruments_trading_experience: '',
            other_instruments_trading_frequency: '',
            employment_industry: '',
            occupation: '',
            education_level: '',
            income_source: '',
            net_income: '',
            estimated_worth: '',
            tax_residence: '',
            tax_identification_number: '',
            account_turnover: '',
            account_opening_reason: '',
            source_of_wealth: '',
            employment_status: '',
            client_type: ''
        };

        if (isVirtual) {
            vm.data.secret_question = '';
            vm.data.secret_answer = '';
        };

        var getPhoneCode = function getPhoneCode(countryCode) {
            return _.find(vm.residenceList, function (country) {
                return country.value === countryCode;
            }).phone_idd;
        };

        $ionicModal.fromTemplateUrl("js/pages/maltainvest-account-opening/tax-residence.modal.html", {
            scope: $scope
        }).then(function (modal) {
            vm.modalCtrl = modal;
        });

        vm.closeModal = function () {
            if (vm.modalCtrl) {
                vm.modalCtrl.hide();
            }
        };

        $scope.$on('modal.hidden', function () {
            // check in modal close action to see if it's closed by submitting changes or not
            // if it's not saved, changes to popup state should not be saved too
            // not saving applies when user clicks outside popup to close popup either
            if (!modalIsSubmitted) {
                var taxResidence = _.split(vm.data.tax_residence, ',');
                _.filter(vm.residenceList, function (residence, idx) {
                    if (_.indexOf(taxResidence, residence.value) > -1) {
                        vm.residenceList[idx].checked = true;
                    } else {
                        vm.residenceList[idx].checked = false;
                    }
                });
            }
            modalIsSubmitted = false;
        });

        vm.showTaxResidenceItems = function () {
            return vm.modalCtrl.show();
        };

        $scope.$on("residence_list", function (e, residence_list) {
            vm.residenceList = residence_list;
            websocketService.sendRequestFor.accountSetting();
        });

        $scope.$on("states_list", function (e, states_list) {
            $scope.$applyAsync(function () {
                vm.statesList = states_list;
            });
        });

        // get some values which are set by user before
        $scope.$on("get_settings", function (e, get_settings) {
            $scope.$applyAsync(function () {
                vm.receivedSettings = true;
                _.forEach(vm.data, function (val, k) {
                    if (get_settings[k]) vm.data[k] = get_settings[k];
                });
                if (get_settings.date_of_birth) {
                    vm.data.date_of_birth = new Date(get_settings.date_of_birth * 1000);
                }
                if (get_settings.place_of_birth) {
                    vm.hasPOB = true;
                }
                if (get_settings.citizen) {
                    vm.hasCitizen = true;
                }
                if (get_settings.country_code) {
                    var countryCode = get_settings.country_code;
                    vm.hasResidence = true;
                    vm.data.residence = countryCode;
                    websocketService.sendRequestFor.statesListSend(countryCode);
                    if (!get_settings.phone) {
                        var phoneCode = getPhoneCode(countryCode);
                        vm.data.phone = phoneCode ? "+" + phoneCode : '';
                    }
                }
                if (vm.data.tax_residence) {
                    vm.settingTaxResidence = _.words(vm.data.tax_residence);
                    vm.residenceList = _.map(vm.residenceList, function (res) {
                        if (vm.settingTaxResidence.indexOf(res.value) > -1) {
                            res.checked = true;
                        }
                        return res;
                    });
                    var checkedValues = _.filter(vm.residenceList, function (res) {
                        return res.checked;
                    });
                    vm.selectedTaxResidencesName = _.map(checkedValues, function (value) {
                        return value.text;
                    }).join(', ');
                }
            });
        });

        vm.setTaxResidence = function () {
            vm.touchedTaxResidence = true;
            var checkedValues = _.filter(vm.residenceList, function (res) {
                return res.checked;
            });
            vm.selectedTaxResidencesName = _.map(checkedValues, function (value) {
                return value.text;
            }).join(', ');
            vm.data.tax_residence = _.map(checkedValues, function (value) {
                return value.value;
            }).join(',');
            vm.closeModal();
        };

        vm.submitAccountOpening = function () {
            vm.disableUpdatebutton = true;
            vm.error = {};
            var params = _.clone(vm.data);
            params.client_type = vm.client_type ? 'professional' : 'retail';
            params.accept_risk = acceptRisk;
            params.date_of_birth = vm.data.date_of_birth ? $filter("date")(vm.data.date_of_birth, "yyyy-MM-dd") : '';
            params = _.forEach(params, function (val, k) {
                params[k] = _.trim(val);
                return params[k];
            });
            websocketService.sendRequestFor.createMaltainvestAccountSend(params);
        };

        vm.acceptRisk = function () {
            acceptRisk = 1;
            vm.submitAccountOpening();
        };

        vm.declineRisk = function () {
            acceptRisk = 0;
            $state.go('trade');
        };

        $scope.$on("new_account_maltainvest:error", function (e, error) {
            vm.disableUpdatebutton = false;
            if (error.hasOwnProperty("details")) {
                $scope.$apply(function () {
                    vm.errors = error.details;
                });
            } else if (error.code && error.code === 'show risk disclaimer') {
                $scope.$applyAsync(function () {
                    vm.showRiskDisclaimer = true;
                    $ionicScrollDelegate.scrollTop(true);
                });
            } else if (error.code) {
                alertService.displayError(error.message);
            }
        });

        $scope.$on("new_account_maltainvest", function (e, new_account_maltainvest) {
            vm.disableUpdatebutton = false;
            var selectedAccount = new_account_maltainvest.oauth_token;
            appStateService.loginFinished = false;
            websocketService.authenticate(selectedAccount);
            appStateService.newAccountAdded = true;
            accountService.addedAccount = selectedAccount;
        });

        vm.openTermsAndConditions = function () {
            window.open(linkToTermAndConditions, "_system");
        };

        vm.openProfessionalClientInformation = function () {
            alertService.showProfessioanlClientInformation($scope);
        };

        vm.openPEPInformation = function () {
            alertService.showPEPInformation($scope);
        };

        vm.openTaxInformation = function () {
            alertService.showTaxInformation($scope);
        };

        vm.goToTINSite = function () {
            window.open(linkToTINSite, "_blank");
        };

        vm.showConfirmProfessionalClient = function () {
            if (vm.client_type) {
                alertService.displayProfessionalClientConfirmation($translate.instant('professional-client-confirmation.professional_clients'), 'information-popup', $scope, 'js/share/templates/professional-client/professional-client-confirmation.template.html', [{
                    text: $translate.instant("professional-client-confirmation.decline"),
                    onTap: function onTap() {
                        return vm.client_type = 0;
                    }
                }, {
                    text: $translate.instant("professional-client-confirmation.accept"),
                    type: "button-positive",
                    onTap: function onTap() {
                        return true;
                    }
                }]);
            }
        };

        var init = function init() {
            vm.error = {};
            websocketService.sendRequestFor.residenceListSend();
            vm.readOnly = !isVirtual;
        };

        init();
    }
})();
"use strict";

/**
 * @name MetaTrader Controller
 * @author Morteza Tavanarad
 * @contributors []
 * @since 04/15/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.meta-trader.controllers").controller("MetaTraderController", MetaTrader);

    MetaTrader.$inject = ["$scope", "$translate", "$state", "accountService", "websocketService", "clientService", "appStateService"];

    function MetaTrader($scope, $translate, $state, accountService, websocketService, clientService, appStateService) {
        var vm = this;
        vm.isLoaded = false;
        vm.hasAccount = false;
        vm.accountsList = {};
        vm.hasMTAccess = false;
        vm.canUpgrade = false;
        vm.showUpgradeToRealButton = false;
        var accounts = {};
        var accountsInfo = {};
        var mtCompany = {};
        var landingCompanyObject = JSON.parse(localStorage.getItem('landingCompanyObject'));

        var mtCompanies = {
            financial: {
                standard: { mt5_account_type: 'standard', max_leverage: 1000, title: $translate.instant('mt.standard') },
                advanced: { mt5_account_type: 'advanced', max_leverage: 300, title: $translate.instant('mt.advanced') },
                mamm: { mt5_account_type: 'mamm_advanced', max_leverage: 300, title: $translate.instant('mt.mam_advanced'), is_real_only: 1 }
            },
            gaming: {
                volatility: { mt5_account_type: '', max_leverage: 500, title: $translate.instant('mt.volatility_indices') },
                mamm: { mt5_account_type: 'mamm', max_leverage: 500, title: $translate.instant('mt.mam_volatility_indices'), is_real_only: 1 }
            }
        };

        var addAccount = function addAccount(company) {
            _.forEach(['demo', 'real'], function (type) {
                _.forEach(_.keys(mtCompanies[company]), function (accType) {
                    var companyInfo = mtCompanies[company][accType];
                    var mt5AccountType = companyInfo.mt5_account_type;
                    // add translate to this later
                    var title = companyInfo.title;
                    var isDemo = type === 'demo';

                    if (!(isDemo && companyInfo.is_real_only)) {
                        accountsInfo[type + "_" + mtCompany[company] + (mt5AccountType ? "_" + mt5AccountType : '')] = {
                            title: title,
                            isDemo: isDemo,
                            mt5AccountType: mt5AccountType,
                            accountType: isDemo ? 'demo' : company,
                            maxLeverage: companyInfo.max_leverage,
                            shortTitle: companyInfo.title
                        };
                    }
                });
            });
        };

        var getMT5AccountType = function getMT5AccountType(group) {
            return group ? group.replace('\\', '_').replace(/_(\d+|master)/, '') : '';
        }; // remove manager id or master distinction from group

        var getMT5LoginList = function getMT5LoginList() {
            return websocketService.sendRequestFor.mt5LoginList();
        };

        var getAllAccountsInfo = function getAllAccountsInfo(list) {
            // Ignore old accounts which are not linked to any group or has deprecated group
            var mt5LoginList = _.filter(list, function (obj) {
                return obj.group && getMT5AccountType(obj.group) in accountsInfo;
            });

            _.forEach(mt5LoginList, function (obj) {
                if (obj) {
                    var accountType = getMT5AccountType(obj.group);
                    accountsInfo[accountType].info = obj;
                    var account = obj;
                    account.isDemo = accountsInfo[accountType].isDemo;
                    account.shortTitle = accountsInfo[accountType].shortTitle;
                    accounts[account.login] = account;
                }
            });

            $scope.$applyAsync(function () {
                vm.canUpgrade = !!_.find(accountsInfo, function (acc) {
                    return !acc.hasOwnProperty('info');
                });
                vm.accountsList = clientService.groupMT5Accounts(accounts);
                vm.isLoaded = true;
                vm.hasAccount = !_.isEmpty(vm.accountsList);
            });
        };

        var isEligible = function isEligible() {
            var hasMTCompany = false;
            _.forEach(_.keys(mtCompanies), function (company) {
                var landingCompany = "mt_" + company + "_company";
                if (landingCompanyObject.hasOwnProperty(landingCompany)) {
                    mtCompany[company] = landingCompanyObject[landingCompany].shortcode;
                    if (mtCompany[company]) {
                        hasMTCompany = true;
                        addAccount(company);
                    }
                }
            });
            return hasMTCompany;
        };

        $scope.$on('mt5_login_list:success', function (e, list) {
            getAllAccountsInfo(list);
        });

        vm.createMTAccount = function () {
            window.open("https://www.binary.com/en/user/metatrader.html", "_system");
        };

        vm.openMT5 = function (type) {
            type = type || "_blank";
            if (["android", "ios"].indexOf(ionic.Platform.platform()) > -1) {
                $state.go("mt5-web");
                return;
            }

            var url = "https://trade.mql5.com/trade?servers=Binary.com-Server&trade_server=Binary.com-Server";
            window.open(url, type);
        };

        vm.redirectToUpgrade = function () {
            var linkToUpgrade = appStateService.upgrade.upgradeLink;
            $state.go(linkToUpgrade);
        };

        var init = function init() {
            if (isEligible()) {
                var _accounts = accountService.getAll();
                vm.hasRealAccount = !!_.find(_accounts, function (obj) {
                    return _.indexOf(['malta', 'costarica', 'svg', 'iom', 'maltainvest'], obj.landing_company_name) > -1;
                });
                if (!vm.hasRealAccount && appStateService.upgrade && appStateService.upgrade.upgradeLink) {
                    vm.showUpgradeToRealButton = true;
                }
                $scope.$applyAsync(function () {
                    vm.hasMTAccess = true;
                });
                getMT5LoginList();
            } else {
                $scope.$applyAsync(function () {
                    vm.hasMTAccess = false;
                    vm.isLoaded = true;
                });
                //  show feature not available error
            }
        };

        init();
    }
})();
"use strict";

/**
 * @name MT5 Web Controller
 * @author Morteza Tavanarad
 * @contributors []
 * @since 04/15/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.meta-trader.controllers").controller("MT5WebController", MTWeb);

    MTWeb.$inject = ["$sce", "$stateParams"];

    function MTWeb($sce, $stateParams) {
        var vm = this;
        vm.url = "https://trade.mql5.com/trade?servers=Binary.com-Server&trade_server=Binary.com-Server&login=";

        vm.url += $stateParams.id;

        vm.url = $sce.trustAsResourceUrl(vm.url);
    }
})();
"use strict";

/**
 * @name Notifications controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 05/02/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.notifications.controllers").controller("NotificationsController", Notifications);

    Notifications.$inject = ["$scope", "notificationService"];

    function Notifications($scope, notificationService) {
        var vm = this;
        $scope.$watch(function () {
            return notificationService.notices;
        }, function () {
            vm.notices = notificationService.notices;
        });
    }
})();
"use strict";

/**
 * @name Profile Module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 11/21/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.profile.controllers").controller("ProfileController", Profile);

    Profile.$inject = ["$scope", "$state", "$translate", "$ionicModal", "alertService", "appStateService", "websocketService", "accountService", "validationService", "clientService", "accountOptions"];

    function Profile($scope, $state, $translate, $ionicModal, alertService, appStateService, websocketService, accountService, validationService, clientService, accountOptions) {
        var vm = this;
        vm.profile = {};
        vm.errors = {};
        vm.taxInfoIsOptional = false;
        vm.validation = validationService;
        vm.isDataLoaded = false;
        vm.notAnyChanges = false;
        vm.disableUpdateButton = false;
        vm.hasResidence = false;
        vm.hasPOB = false;
        vm.hasCitizen = false;
        vm.hasAccountOpeningReason = false;
        vm.touchedTaxResidence = false;
        vm.settingTaxResidence = [];
        vm.options = accountOptions;
        var modalIsSubmitted = false;
        var account = accountService.getDefault();
        var landingCompany = account.landing_company_name;
        var accounts = accountService.getAll();
        var profileFields = {
            address_line_1: '',
            address_line_2: '',
            address_city: '',
            address_state: '',
            address_postcode: '',
            phone: '',
            tax_identification_number: '',
            tax_residence: '',
            place_of_birth: '',
            citizen: '',
            account_opening_reason: '',
            email_consent: ''
        };

        $ionicModal.fromTemplateUrl("js/pages/profile/tax-residence.modal.html", {
            scope: $scope
        }).then(function (modal) {
            vm.modalCtrl = modal;
        });

        var isLandingCompanyOf = function isLandingCompanyOf(targetLandingCompany, accountLandingCompany) {
            return clientService.isLandingCompanyOf(targetLandingCompany, accountLandingCompany);
        };
        var hasAccountOfLandingCompany = function hasAccountOfLandingCompany(accounts, landingCompany) {
            return clientService.hasAccountOfLandingCompany(accounts, landingCompany);
        };
        var getResidenceList = function getResidenceList() {
            return websocketService.sendRequestFor.residenceListSend();
        };
        var getProfile = function getProfile() {
            return websocketService.sendRequestFor.accountSetting();
        };
        var getPhoneCode = function getPhoneCode(countryCode) {
            return _.find(vm.residenceList, function (country) {
                return country.value === countryCode;
            }).phone_idd;
        };

        vm.init = function () {
            vm.isVirtualAccount = isLandingCompanyOf('virtual', landingCompany);
            vm.hasIOM = hasAccountOfLandingCompany(accounts, 'iom');
            var hasMaltainvestAccount = hasAccountOfLandingCompany(accounts, 'maltainvest');
            vm.requireCitizen = isLandingCompanyOf('malta', landingCompany) || isLandingCompanyOf('maltainvest', landingCompany) || isLandingCompanyOf('iom', landingCompany);
            vm.taxInfoIsOptional = !isLandingCompanyOf('maltainvest', landingCompany) && !hasMaltainvestAccount;
            getResidenceList();
        };

        $scope.$on("residence_list", function (e, response) {
            $scope.$applyAsync(function () {
                vm.residenceList = response;
                getProfile();
            });
        });

        var setProfile = function setProfile(get_settings) {
            $scope.$applyAsync(function () {
                vm.isDataLoaded = true;
            });
            if (vm.isVirtualAccount) {
                vm.profile = get_settings;
                if (get_settings.country_code) {
                    var countryCode = get_settings.country_code;
                    vm.hasResidence = true;
                    vm.profile.residence = countryCode;
                    if (countryCode !== account.country) {
                        websocketService.authenticate(account.token);
                    }
                }
                vm.profile.email_consent = get_settings.email_consent === 1;
            } else {
                vm.profile = get_settings;
                if (get_settings.date_of_birth) {
                    vm.profile.date_of_birth = new Date(get_settings.date_of_birth * 1000);
                }
                if (get_settings.place_of_birth) {
                    vm.hasPOB = true;
                }
                if (get_settings.citizen) {
                    vm.hasCitizen = true;
                }
                if (get_settings.country_code) {
                    var _countryCode = get_settings.country_code;
                    vm.hasResidence = true;
                    vm.profile.residence = _countryCode;
                    websocketService.sendRequestFor.statesListSend(_countryCode);
                    if (!get_settings.phone) {
                        var phoneCode = getPhoneCode(_countryCode);
                        vm.profile.phone = phoneCode ? "+" + phoneCode : '';
                    }
                }
                if (vm.profile.tax_residence) {
                    vm.settingTaxResidence = _.words(vm.profile.tax_residence);
                    vm.residenceList = _.map(vm.residenceList, function (res) {
                        if (vm.settingTaxResidence.indexOf(res.value) > -1) {
                            res.checked = true;
                        }
                        return res;
                    });
                    var checkedValues = _.filter(vm.residenceList, function (res) {
                        return res.checked;
                    });
                    vm.selectedTaxResidencesName = _.map(checkedValues, function (value) {
                        return value.text;
                    }).join(', ');
                }
                vm.profile.email_consent = get_settings.email_consent === 1;
                if (vm.profile.account_opening_reason) {
                    vm.hasAccountOpeningReason = true;
                }
            };
        };

        $scope.$on("get_settings", function (e, get_settings) {
            vm.getSettings = _.clone(get_settings);
            setProfile(get_settings);
        });

        $scope.$on("states_list", function (e, states_list) {
            $scope.$applyAsync(function () {
                vm.states = states_list;
            });
        });

        $scope.$on("set-settings", function (e, response) {
            vm.disableUpdateButton = false;
            vm.notAnyChanges = false;
            if (response) {
                $translate(["profile.success", "profile.success_message"]).then(function (translation) {
                    alertService.displayAlert(translation["profile.success"], translation["profile.success_message"]);
                });
                getProfile();
            }
        });

        $scope.$on("set-settings:error", function (e, error) {
            vm.disableUpdatebutton = false;
            if (!vm.isVirtualAccount && error.hasOwnProperty("details")) {
                $scope.$apply(function () {
                    vm.errors = error.details;
                });
            } else if (error.code) {
                alertService.displayError(error.message);
            }
        });

        vm.closeModal = function () {
            if (vm.modalCtrl) {
                vm.modalCtrl.hide();
                appStateService.modalIsOpen = false;
            }
        };

        $scope.$on('modal.hidden', function () {
            // check in modal close action to see if it's closed by submitting changes or not
            // if it's not saved, changes to popup state should not be saved too
            // not saving applies when user clicks outside popup to close popup either
            if (!modalIsSubmitted) {
                var taxResidence = _.split(vm.profile.tax_residence, ',');
                _.filter(vm.residenceList, function (residence, idx) {
                    if (_.indexOf(taxResidence, residence.value) > -1) {
                        vm.residenceList[idx].checked = true;
                    } else {
                        vm.residenceList[idx].checked = false;
                    }
                });
            }
            modalIsSubmitted = false;
        });

        vm.showTaxResidenceItems = function () {
            return vm.modalCtrl.show();
        };

        vm.setTaxResidence = function () {
            vm.touchedTaxResidence = true;
            var checkedValues = _.filter(vm.residenceList, function (res) {
                return res.checked;
            });
            vm.selectedTaxResidencesName = _.map(checkedValues, function (value) {
                return value.text;
            }).join(', ');
            vm.profile.tax_residence = _.map(checkedValues, function (value) {
                return value.value;
            }).join(',');
            modalIsSubmitted = true;
            vm.closeModal();
        };

        vm.updateProfile = function () {
            vm.disableUpdatebutton = true;
            vm.notAnyChanges = true;
            vm.error = {};
            var params = {};
            if (!vm.isVirtualAccount) {
                _.forEach(profileFields, function (val, k) {
                    if (vm.profile[k] && k !== 'email_consent') params[k] = vm.profile[k];
                    if (k === 'email_consent') {
                        params[k] = vm.profile[k] ? 1 : 0;
                    }
                });
                _.forEach(params, function (val, k) {
                    if (_.isString(params[k])) {
                        params[k] = _.trim(val);
                    }
                    if (params[k] !== vm.getSettings[k]) {
                        vm.notAnyChanges = false;
                    }
                    return params[k];
                });
                if (!vm.notAnyChanges) {
                    vm.disableUpdateButton = true;
                    websocketService.sendRequestFor.setAccountSettings(params);
                }
            } else {
                params = {
                    residence: vm.hasResidence ? vm.getSettings.country_code : vm.profile.country,
                    email_consent: vm.profile.email_consent ? 1 : 0
                };
                if (params.residence !== vm.getSettings.country_code || params.email_consent !== vm.getSettings.email_consent) {
                    vm.notAnyChanges = false;
                }
                if (!vm.notAnyChanges) {
                    vm.disableUpdateButton = true;
                    websocketService.sendRequestFor.setAccountSettings(params);
                }
            }
        };

        vm.goToContact = function () {
            $state.go('contact');
        };

        vm.init();
    }
})();
"use strict";

/**
 * @name profit-table controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.profit-table.controllers").controller("ProfitTableController", ProfitTable);

    ProfitTable.$inject = ["$scope", "$filter", "$timeout", "$state", "$templateCache", "$ionicScrollDelegate", "config", "tableStateService", "websocketService", "appStateService"];

    function ProfitTable($scope, $filter, $timeout, $state, $templateCache, $ionicScrollDelegate, config, tableStateService, websocketService, appStateService) {
        var vm = this;
        vm.data = {};
        vm.noTransaction = false;
        vm.noMore = false;
        vm.ios = ionic.Platform.isIOS();
        vm.android = ionic.Platform.isAndroid();
        vm.goToTopButton = false;
        vm.firstCompleted = false;
        vm.jumpToDateInputShow = false;
        vm.hasError = false;
        vm.dateChanged = false;
        vm.isItemShown = false;
        var appIdAllowed = config.app_id;
        var enteredNow = false;
        var backFromMainPages = false;
        var noMoreRequest = false;
        vm.fractionalDigits = 2;

        var notAuthorizeYet = function notAuthorizeYet() {
            // check if app is authorized already or has to wait for it to be authorized
            if (appStateService.isLoggedin) {
                vm.currency = sessionStorage.getItem('currency') || 'USD';
                var currencyConfig = appStateService.currenciesConfig || {};
                vm.fractionalDigits = !_.isEmpty(currencyConfig) && currencyConfig[vm.currency] ? currencyConfig[vm.currency].fractional_digits : 2;
                if (appStateService.profitTableRefresh || backFromMainPages) {
                    $templateCache.remove();
                    resetParams();
                    vm.jumpToDateInputShow = false;
                    vm.firstCompleted = false;
                    noMoreRequest = false;
                    vm.hasError = false;
                    vm.filteredTransactions = [];
                    vm.noTransaction = false;
                    backFromMainPages = false;
                    tableStateService.completedGroup = true;
                    appStateService.profitTableRefresh = false;
                    appStateService.isProfitTableSet = false;
                    loadMore();
                }
            }
            // else{
            //    wait for authorize
            // }
        };

        $scope.$on("$stateChangeSuccess", function (ev, to, toParams, from, fromParams) {
            vm.lastPage = from.name;
            enteredNow = true;
            vm.thisPage = to.name;
            // check if state is changed from any state other than transaction-detail
            // we do not refresh the state if it comes back from transaction-detail
            if (vm.lastPage !== "transaction-detail" && vm.thisPage === "profit-table") {
                resetParams();
                vm.firstCompleted = false;
                backFromMainPages = true;
                vm.jumpToDateInputShow = false;
                notAuthorizeYet();
            }
        });

        $scope.$on("authorize", function (e, response) {
            if (appStateService.profitTableRefresh) {
                notAuthorizeYet();
            }
        });

        vm.delayedLoad = function () {
            $timeout(loadMore, 50);
        };

        var loadMore = function loadMore() {
            if (!tableStateService.completedGroup) {
                // here can load some amount of transactions already recieved
                setBatch();
            } else if (tableStateService.completedGroup) {
                tableStateService.currentPage += 1;
                pageState();
            }
        };

        var pageState = function pageState() {
            if (!appStateService.isProfitTableSet) {
                appStateService.isProfitTableSet = true;
                tableStateService.dateType = "allTime";
                vm.jumpToDateInputShow = false;
                resetParams();
                setParams();
                tableStateService.completedGroup = false;
                vm.goTop();
            } else if (appStateService.isProfitTableSet && enteredNow && vm.lastPage === "transaction-detail") {
                enteredNow = false;
                vm.lastPage = "";
                setParams();
            } else if (appStateService.isProfitTableSet && vm.dateChanged && tableStateService.completedGroup) {
                vm.transactions = [];
                vm.batchedTransaction = [];
                vm.filteredTransactions = [];
                vm.dateChanged = false;
                tableStateService.currentPage = 0;
                tableStateService.batchNum = 0;
                tableStateService.batchLimit = 0;
                tableStateService.completedGroup = false;
                setParams();
                vm.goTop();
            } else if (appStateService.isProfitTableSet && !vm.dateChanged && tableStateService.completedGroup) {
                vm.transactions = [];
                tableStateService.completedGroup = false;
                setParams();
            } else if (!vm.dateChanged) {
                setParams();
                $scope.$applyAsync(function () {
                    vm.noMore = false;
                });
            }
            sendRequest();
        };

        var setParams = function setParams() {
            vm.data.appID = tableStateService.appID;
            vm.data.dateType = tableStateService.dateType;
            vm.data.dateFrom = tableStateService.dateFrom;
            vm.data.dateTo = tableStateService.dateTo;
            vm.data.currentPage = tableStateService.currentPage;
            vm.itemsPerPage = 300;
            vm.limit = vm.itemsPerPage + 1;
        };

        var resetParams = function resetParams() {
            tableStateService.appID = "allApps";
            tableStateService.dateFrom = "";
            tableStateService.dateTo = "";
            tableStateService.currentPage = 0;
            vm.transactions = [];
            vm.batchedTransaction = [];
            tableStateService.completedGroup = true;
            tableStateService.batchNum = 0;
            tableStateService.batchLimit = 0;
        };

        var sendRequest = function sendRequest() {
            var params = {
                description: 1,
                limit: vm.limit,
                offset: vm.itemsPerPage * vm.data.currentPage
            };
            if (vm.data.hasOwnProperty("dateFrom") && vm.data.dateFrom !== "") {
                params.date_from = vm.data.dateFrom;
            }
            if (vm.data.hasOwnProperty("dateTo") && vm.data.dateTo !== "") {
                params.date_to = vm.data.dateTo + 8.64e4;
            }
            params.req_id = vm.data.dateTo || Math.round(new Date().getTime() / 1000);
            vm.reqId = params.req_id;
            websocketService.sendRequestFor.profitTable(params);
        };

        $scope.$on("profit_table:update", function (e, _profitTable, _req_id) {
            vm.firstCompleted = true;
            vm.profitTable = _profitTable;
            var count = vm.profitTable.count;
            vm.hasError = false;
            if (vm.reqId === _req_id) {
                if (count === 0) {
                    vm.noTransaction = true;
                    $scope.$applyAsync(function () {
                        vm.noMore = true;
                    });
                    setBatch();
                } else if (count > 0) {
                    if (count < vm.limit) {
                        // has no more to load on next call
                        vm.noTransaction = false;
                        // $scope.$applyAsync(() => {
                        noMoreRequest = true;
                        // });
                        vm.profitTable.transactions.forEach(function (el, i) {
                            vm.transactions.push(vm.profitTable.transactions[i]);
                        });
                        setBatch();
                    } else if (count === vm.limit) {
                        // has at least one transaction on next call to show to user
                        vm.noTransaction = false;
                        $scope.$applyAsync(function () {
                            vm.noMore = false;
                        });
                        vm.profitTable.transactions.forEach(function (el, i) {
                            if (i < count - 1) {
                                vm.transactions.push(vm.profitTable.transactions[i]);
                            }
                        });
                        setBatch();
                    }
                }
            }
        });

        $scope.$on("profit_table:error", function (e, message) {
            $scope.$applyAsync(function () {
                vm.hasError = true;
                vm.errorMessage = message;
            });
        });

        var setBatch = function setBatch() {
            tableStateService.batchLimit = Math.ceil(vm.transactions.length / tableStateService.batchSize);
            var sliced = [];
            sliced = vm.transactions.slice(tableStateService.batchNum * tableStateService.batchSize, (tableStateService.batchNum + 1) * tableStateService.batchSize);
            sliced.forEach(function (el, i) {
                vm.batchedTransaction.push(sliced[i]);
            });
            tableStateService.batchNum += 1;
            if (tableStateService.batchNum === tableStateService.batchLimit) {
                tableStateService.batchLimit = 0;
                tableStateService.batchNum = 0;
                tableStateService.completedGroup = true;
                if (noMoreRequest) {
                    $scope.$applyAsync(function () {
                        vm.noMore = true;
                    });
                }
            }

            vm.setFiltered();
        };

        vm.setFiltered = function () {
            $scope.$applyAsync(function () {
                tableStateService.appID = vm.data.appID;
                vm.filteredTransactions = $filter("DataFilter")(vm.batchedTransaction, tableStateService.appID, appIdAllowed);
                if (vm.filteredTransactions.length === 0) {
                    vm.noTransaction = true;
                } else {
                    vm.noTransaction = false;
                }
                $scope.$broadcast("scroll.infiniteScrollComplete");
            });
        };

        vm.dateFilter = function () {
            tableStateService.dateType = vm.data.dateType;
            vm.dateChanged = true;
            vm.noTransaction = false;
            if (tableStateService.dateType === "allTime") {
                $scope.$applyAsync(function () {
                    vm.jumpToDateInputShow = false;
                });
                tableStateService.completedGroup = true;
                vm.firstCompleted = false;
                vm.data.dateTo = "";
                tableStateService.dateFrom = "";
                tableStateService.dateTo = "";
                loadMore();
            } else if (tableStateService.dateType === "jumpToDate") {
                $scope.$applyAsync(function () {
                    vm.jumpToDateInputShow = true;
                });
                tableStateService.completedGroup = true;
                vm.firstCompleted = false;
                vm.nowDateInputLimit = $filter("date")(new Date(), "yyyy-MM-dd");
                document.getElementById("dateTo").setAttribute("max", vm.nowDateInputLimit);
                document.getElementById("dateTo").value = vm.nowDateInputLimit;
                vm.jumpToDateFilter();
            }
        };

        vm.jumpToDateFilter = function () {
            if (tableStateService.dateType === "jumpToDate") {
                tableStateService.completedGroup = true;
                vm.dateChanged = true;
                vm.noTransaction = false;
                vm.firstCompleted = false;
                tableStateService.currentPage = 0;
                vm.data.dateTo = new Date(vm.data.end).getTime() / 1000 || "";
                tableStateService.dateTo = vm.data.dateTo;
                loadMore();
            }
        };

        vm.toggleItem = function () {
            vm.isItemShown = !vm.isItemShown;
            var content = document.getElementsByClassName("profit-table-expandable")[0];
            content.id = content.id === "profit-table-filter-active" ? "" : "profit-table-filter-active";
        };

        vm.goTop = function () {
            $ionicScrollDelegate.scrollTop(true);
        };

        vm.goToTopButtonCondition = function () {
            $timeout(function () {
                var position = $ionicScrollDelegate.$getByHandle("handler").getScrollPosition();
                vm.goToTopButton = position ? position.top >= 30 : false;
            }, 500);
        };

        // details functions
        vm.sendContractDetailRequest = function (id) {
            if (id) {
                sessionStorage.setItem("id", id);
                $state.go("transaction-detail");
            }
        };
    }
})();
"use strict";

/**
 * @name profit-table filter
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.profit-table.filters").filter("DataFilter", DataFilter);

    DataFilter.$inject = ["$filter"];

    function DataFilter(transactions, appID, appIdAllowed) {
        function DataChange(transactions, appID, appIdAllowed) {
            var filtered = [];

            transactions.forEach(function (value, i) {
                var item = transactions[i];
                var itemId = item.app_id;
                if (appID === "allApps" || appID === "tickTradeApp" && itemId === appIdAllowed.toString()) {
                    filtered.push(item);
                }
            });
            return filtered;
        }
        return DataChange;
    }
})();
"use strict";

/**
 * @name new-account-real controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.real-account-opening").controller("RealAccountOpeningController", RealAccountOpening);

    RealAccountOpening.$inject = ["$scope", "$filter", "websocketService", "appStateService", "accountService", "alertService", "clientService", "validationService", "accountOptions"];

    function RealAccountOpening($scope, $filter, websocketService, appStateService, accountService, alertService, clientService, validationService, accountOptions) {
        var vm = this;
        vm.data = {};
        vm.errors = {};
        var landingCompany = accountService.getDefault().landing_company_name;
        var isVirtual = clientService.isLandingCompanyOf('virtual', landingCompany);
        var accounts = accountService.getAll();
        var upgradableLandingCompanies = appStateService.upgradeableLandingCompanies;
        vm.hasIOM = _.indexOf(upgradableLandingCompanies, 'iom') > -1 || clientService.hasAccountOfLandingCompany(accounts, 'iom');
        vm.requireCitizen = _.indexOf(upgradableLandingCompanies, 'malta') > -1 || _.indexOf(upgradableLandingCompanies, 'iom') > -1;
        vm.validation = validationService;
        vm.options = accountOptions;
        vm.receivedSettings = false;
        vm.hasResidence = false;
        vm.hasPOB = false;
        vm.hasCitizen = false;
        vm.disableUpdatebutton = false;
        vm.linkToTermAndConditions = "https://www.binary.com/" + (localStorage.getItem("language") || "en") + "/terms-and-conditions.html";
        vm.data = {
            salutation: '',
            first_name: '',
            last_name: '',
            date_of_birth: '',
            citizen: '',
            place_of_birth: '',
            residence: '',
            address_line_1: '',
            address_line_2: '',
            address_city: '',
            address_state: '',
            address_postcode: '',
            phone: '',
            account_opening_reason: ''
        };

        if (isVirtual) {
            vm.data.secret_question = '';
            vm.data.secret_answer = '';
        };

        var getPhoneCode = function getPhoneCode(countryCode) {
            return _.find(vm.residenceList, function (country) {
                return country.value === countryCode;
            }).phone_idd;
        };

        $scope.$on("residence_list", function (e, residence_list) {
            vm.residenceList = residence_list;
            websocketService.sendRequestFor.accountSetting();
        });

        // get some values which are set by user before
        $scope.$on("get_settings", function (e, get_settings) {
            $scope.$applyAsync(function () {
                vm.receivedSettings = true;
                _.forEach(vm.data, function (val, k) {
                    if (get_settings[k]) vm.data[k] = get_settings[k];
                });
                if (get_settings.date_of_birth) {
                    vm.data.date_of_birth = new Date(get_settings.date_of_birth * 1000);
                }
                if (get_settings.place_of_birth) {
                    vm.hasPOB = true;
                }
                if (get_settings.citizen) {
                    vm.hasCitizen = true;
                }
                if (get_settings.country_code) {
                    var countryCode = get_settings.country_code;
                    vm.hasResidence = true;
                    vm.data.residence = countryCode;
                    websocketService.sendRequestFor.statesListSend(countryCode);
                    if (!get_settings.phone) {
                        var phoneCode = getPhoneCode(countryCode);
                        vm.data.phone = phoneCode ? "+" + phoneCode : '';
                    }
                }
            });
        });

        $scope.$on("states_list", function (e, states_list) {
            $scope.$applyAsync(function () {
                vm.statesList = states_list;
            });
        });

        vm.submitAccountOpening = function () {
            vm.disableUpdatebutton = true;
            vm.error = {};
            var params = _.clone(vm.data);
            var currency = appStateService.selectedCurrency || '';
            if (currency) {
                params.currency = currency;
            }
            params.date_of_birth = vm.data.date_of_birth ? $filter("date")(vm.data.date_of_birth, "yyyy-MM-dd") : '';
            params = _.forEach(params, function (val, k) {
                params[k] = _.trim(val);
                return params[k];
            });
            websocketService.sendRequestFor.createRealAccountSend(params);
        };

        // error handling by backend errors under each input
        $scope.$on("new_account_real:error", function (e, error) {
            vm.disableUpdatebutton = false;
            if (error.hasOwnProperty("details")) {
                $scope.$apply(function () {
                    vm.errors = error.details;
                });
            } else if (error.code) {
                alertService.displayError(error.message);
            }
        });

        $scope.$on("new_account_real", function (e, new_account_real) {
            vm.disableUpdatebutton = false;
            var selectedAccount = new_account_real.oauth_token;
            appStateService.loginFinished = false;
            websocketService.authenticate(selectedAccount);
            appStateService.newAccountAdded = true;
            accountService.addedAccount = selectedAccount;
        });

        vm.openTermsAndConditions = function () {
            window.open(vm.linkToTermAndConditions, "_blank");
        };

        vm.openPEPInformation = function () {
            alertService.showPEPInformation($scope);
        };

        vm.init = function () {
            vm.errors = {};
            websocketService.sendRequestFor.residenceListSend();
            vm.readOnly = !isVirtual;
        };

        vm.init();
    }
})();
'use strict';

/**
 * @name Redirect Controller
 * @author Morteza Tavanarad
 * @contributors []
 * @since 03/03/2018
 * @copyright Binary Ltd
 */

(function () {
    angular.module('binary.pages.redirect.controllers').controller("RedirectController", Redirect);

    Redirect.$inject = ['$state'];

    function Redirect($state) {
        var vm = this;

        vm.init = function () {
            var url = window.location.href;
            var result = /^.*\?(.*)$/g.exec(url);

            if (result) {
                $state.go('signin', { accountTokens: url });
            } else {
                $state.go('home');
            }
        };

        vm.init();
    }
})();
"use strict";

/**
 * @name resources controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 01/24/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.resources.controllers").controller("ResourcesController", Resources);

    Resources.$inject = [];

    function Resources() {
        var vm = this;
        vm.ios = ionic.Platform.isIOS();
        vm.android = ionic.Platform.isAndroid();

        vm.resources = [{
            name: "resources.trading_times",
            url: "trading-times"
        }, {
            name: "resources.asset_index",
            url: "asset-index"
        }];
    }
})();
"use strict";

/**
 * @name self-exclusion module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 11/12/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.self-exclusion.controllers").controller("SelfExclusionController", SelfExclusion);

    SelfExclusion.$inject = ["$scope", "$state", "$translate", "$ionicScrollDelegate", "alertService", "websocketService", "accountService", "validationService"];

    function SelfExclusion($scope, $state, $translate, $ionicScrollDelegate, alertService, websocketService, accountService, validationService) {
        var vm = this;
        vm.hasError = false;
        vm.validation = validationService;
        vm.fractionalDigits = vm.validation.fractionalDigits;
        var today = new Date();
        vm.minDate = today.toISOString().slice(0, 10);
        vm.minDateTime = today.toISOString();
        vm.nextSixWeeks = new Date(today.getTime() + 7 * 6 * 24 * 60 * 60 * 1000).toISOString().slice(0, 10);
        vm.nextSixMonths = new Date(today.getTime() + 30 * 6 * 24 * 60 * 60 * 1000).toISOString().slice(0, 10);
        vm.disableUpdateButton = true;
        vm.isDataLoaded = false;
        vm.disableForZeroValues = false;
        var isUpdated = false;
        vm.data = {};
        var account = accountService.getDefault();
        vm.country = account.country;
        var noZeroValues = ['max_balance', 'max_turnover', 'max_losses', 'max_7day_turnover', 'max_7day_losses', 'max_30day_turnover', 'max_30day_losses', 'max_open_bets'];

        $scope.$on("get-self-exclusion", function (e, response) {
            $scope.$applyAsync(function () {
                vm.data = _.clone(response);
                if (vm.data.exclude_until) {
                    vm.data.exclude_until = new Date(vm.data.exclude_until);
                }
                vm.limits = _.clone(response);
                vm.disableUpdateButton = false;
                vm.isDataLoaded = true;
            });
        });

        $scope.$on("get-self-exclusion:error", function (e, error) {
            alertService.displayError(error);
            vm.disableUpdateButton = false;
        });

        $scope.$on("set-self-exclusion", function (e, response) {
            $translate(["self-exclusion.success", "self-exclusion.save_prompt"]).then(function (translation) {
                alertService.displayAlert(translation["self-exclusion.success"], translation["self-exclusion.save_prompt"]);
            });
            vm.limits = _.clone(vm.data);
            vm.disableUpdateButton = false;
            if (isUpdated) {
                isUpdated = false;
                if (vm.country === 'gb') {
                    $ionicScrollDelegate.scrollBottom();
                }
            }
        });

        $scope.$on("set-self-exclusion:error", function (e, error) {
            alertService.displayError(error);
            vm.disableUpdateButton = false;
        });

        vm.checkZeroValues = function () {
            var hasZeroValue = [];
            _.forEach(noZeroValues, function (field) {
                if (parseInt(vm.data[field]) === 0) {
                    hasZeroValue.push(field);
                }
            });
            $scope.$applyAsync(function () {
                vm.disableForZeroValues = !!hasZeroValue.length;
            });
        };

        vm.submit = function () {
            vm.disableUpdateButton = true;
            setSelfExclusion();
        };

        var getSelfExclusion = function getSelfExclusion() {
            return websocketService.sendRequestFor.getSelfExclusion();
        };
        var getLimits = function getLimits() {
            return websocketService.sendRequestFor.accountLimits();
        };

        var setSelfExclusion = function setSelfExclusion() {
            var data = _.clone(vm.data);

            if (data.timeout_until) {
                data.timeout_until = new Date(data.timeout_until).getTime() / 1000;
            }

            if (data.exclude_until) {
                data.exclude_until = data.exclude_until.toISOString().slice(0, 10);
            }

            // Convert all numbers to string for supporting number with more than 15 digits
            var stringify = JSON.stringify(data);
            stringify = stringify.replace(/:(\d+)([,}])/g, ':"$1"$2');
            websocketService.sendRequestFor.setSelfExclusion(JSON.parse(stringify));
            isUpdated = true;
        };

        $scope.$on('get_limits', function (e, limits) {
            vm.hasError = false;
            vm.accountLimits = limits;
            getSelfExclusion();
        });

        $scope.$on('get_limits:error', function () {
            vm.hasError = true;
        });

        vm.goToContact = function () {
            $state.go('contact');
        };

        var init = function init() {
            return getLimits();
        };

        init();
    }
})();
"use strict";

/**
 * @name session-timout controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 02/04/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.self-exclusion.controllers").controller("SessionTimeoutController", SessionTimeout);

    SessionTimeout.$inject = ["$scope", "$translate", "alertService", "websocketService"];

    function SessionTimeout($scope, $translate, alertService, websocketService) {
        var vm = this;
        var timeoutHasSet = false;
        var loginTime = 0;
        var sessionLimit = null;

        $scope.$on("authorize", function (e, response) {
            loginTime = new Date().getTime();
            websocketService.sendRequestFor.getSelfExclusion();
            timeoutHasSet = false;
        });

        $scope.$on("get-self-exclusion", function (e, response) {
            if (response.session_duration_limit && !timeoutHasSet) {
                timeoutHasSet = true;
                sessionLimit = response.session_duration_limit * 60 * 1000;
                checkSessionDuration();
            }
        });

        function checkSessionDuration() {
            var now = new Date().getTime();
            var remained = loginTime + sessionLimit - now;
            var maxLimit = Math.pow(2, 31) - 1;
            var warning = 10 * 1000;

            if (remained < 0) {
                remained = warning;
            }

            var logout = function logout() {
                $translate(["self-exclusion.warning", "self-exclusion.session_timeout_warning"]).then(function (translation) {
                    alertService.displayAlert(translation["self-exclusion.warning"], translation["self-exclusion.session_timeout_warning"]);
                });
                setTimeout(function () {
                    websocketService.logout();
                }, warning);
            };

            if (remained > maxLimit) {
                remained %= maxLimit;
                setTimeout(checkSessionDuration, remained);
            } else {
                setTimeout(logout, remained - warning);
            }
        }
    }
})();
"use strict";

/**
 * @name session-timout directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 02/04/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.self-exclusion.directives").directive("bgSessionTimeout", SessionTimeout);

    function SessionTimeout() {
        var directive = {
            restrict: "E",
            scope: {},
            controller: "SessionTimeoutController",
            controllerAs: "vm"
        };

        return directive;
    }
})();
"use strict";

/**
 * @name set-currency controller
 * @author Nazanin Reihani haghighi
 * @contributors []
 * @since 10/18/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.set-currency.controllers").controller("SetCurrencyController", SetCurrency);

    SetCurrency.$inject = ['$scope', '$rootScope', '$state', 'config', 'appStateService', 'websocketService', 'accountService', 'clientService', 'alertService'];

    function SetCurrency($scope, $rootScope, $state, config, appStateService, websocketService, accountService, clientService, alertService) {
        var vm = this;
        var cryptoConfig = config.cryptoConfig;
        var currencyConfig = appStateService.currenciesConfig;
        var accounts = accountService.getAll();
        var currentAccount = accountService.getDefault();
        var landingCompany = currentAccount.landing_company_name;
        vm.isCRAccount = clientService.isLandingCompanyOf('costarica', landingCompany) || clientService.isLandingCompanyOf('svg', landingCompany);
        vm.currenciesOptions = [];

        vm.getCurrenciesOptions = function () {
            var legalAllowedCurrencies = clientService.landingCompanyValue(landingCompany, 'legal_allowed_currencies');
            if (vm.isCRAccount) {
                var existingCurrencies = clientService.getExistingCurrencies(accounts);
                if (existingCurrencies.length) {
                    var dividedExistingCurrencies = clientService.dividedCurrencies(existingCurrencies);
                    var hasFiat = dividedExistingCurrencies.fiatCurrencies.length > 0;
                    if (hasFiat) {
                        var legalAllowedCryptoCurrencies = clientService.dividedCurrencies(legalAllowedCurrencies).cryptoCurrencies;
                        var existingCryptoCurrencies = dividedExistingCurrencies.cryptoCurrencies;
                        return _.difference(legalAllowedCryptoCurrencies, existingCryptoCurrencies);
                    }
                    return _.difference(legalAllowedCurrencies, existingCurrencies);
                }
                return legalAllowedCurrencies;
            }
            // for all accounts except CR accounts
            return legalAllowedCurrencies;
        };

        var populateOptions = function populateOptions(options) {
            options.forEach(function (curr) {
                var currency = currencyConfig[curr];
                var isCryptoCurrency = /crypto/i.test(currencyConfig[curr].type);
                if (isCryptoCurrency && !cryptoConfig[curr]) return;
                currency.symb = curr;
                currency.isCryptoCurrency = isCryptoCurrency;
                currency.img = "img/currency/" + curr.toLowerCase() + ".svg";
                if (isCryptoCurrency) {
                    currency.name = cryptoConfig[curr].name;
                }
                vm.currenciesOptions.push(currencyConfig[curr]);
            });
        };

        var hasCurrency = function hasCurrency() {
            $scope.$applyAsync(function () {
                vm.hasCryptoOption = _.findIndex(vm.currenciesOptions, 'isCryptoCurrency') > -1;
                vm.hasFiatOption = _.findIndex(vm.currenciesOptions, ['isCryptoCurrency', false]) > -1;
            });
        };

        vm.setCurrencyOfAccount = function (selectedCurrency) {
            websocketService.sendRequestFor.setAccountCurrency(selectedCurrency);
        };

        $scope.$on('set_account_currency:success', function (e, currency) {
            var accounts = JSON.parse(localStorage.accounts);
            for (var i = 0; i < accounts.length; i++) {
                if (accounts[i].is_default === true) {
                    accounts[i].currency = currency;
                    break;
                }
            }
            localStorage.setItem("accounts", JSON.stringify(accounts));
            sessionStorage.setItem("currency", currency);
            appStateService.accountCurrencyChanged = true;
            $rootScope.$broadcast("currency:changed", currency);
            // if user is redirected here from accounts-management page redirect him/her to account-management page
            if (vm.from === 'accounts-management') {
                $state.go("accounts-management");
            } else {
                $state.go("trade");
            }
        });

        $scope.$on('set_account_currency:error', function (e, error) {
            alertService.displayError(error.message);
        });

        $scope.$on('$stateChangeSuccess', function (ev, to, toParams, from, fromParams) {
            vm.from = from.name;
        });

        var init = function init() {
            var options = vm.getCurrenciesOptions();
            populateOptions(options);
            hasCurrency();
        };

        init();
    }
})();
"use strict";

/**
 * @name settings controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 11/11/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.settings.controllers").controller("SettingsController", Settings);

    Settings.$inject = ["appStateService", "accountService", "clientService"];

    function Settings(appStateService, accountService, clientService) {
        var vm = this;
        vm.ios = ionic.Platform.isIOS();
        vm.android = ionic.Platform.isAndroid();

        var isLandingCompanyOf = function isLandingCompanyOf(targetLandingCompany, accountLandingCompany) {
            return clientService.isLandingCompanyOf(targetLandingCompany, accountLandingCompany);
        };

        vm.settings = [{
            name: "profile.personal_details",
            url: "profile",
            scope: "read",
            forRealAccount: false,
            forFinancialAccount: false
        }, {
            name: "settings.account_categorisation",
            url: "account-categorisation",
            scope: "read",
            forRealAccount: false,
            forFinancialAccount: true
        }, {
            name: "settings.self_exclusion",
            url: "self-exclusion",
            scope: "admin",
            forRealAccount: true,
            forFinancialAccount: false
        }, {
            name: "menu.language",
            url: "language",
            scope: "read",
            forRealAccount: false,
            forFinancialAccount: false
        }, {
            name: "settings.change_password",
            url: "change-password",
            scope: "admin",
            forRealAccount: false,
            forFinancialAccount: false
        }, {
            name: "settings.financial_assessment",
            url: "financial-assessment",
            scope: "admin",
            forRealAccount: true,
            forFinancialAccount: false
        }, {
            name: "settings.limits",
            url: "limits",
            scope: "admin",
            forRealAccount: true,
            forFinancialAccount: false
        }];

        vm.checkAccount = function (forRealAccount) {
            return forRealAccount ? !appStateService.virtuality : true;
        };

        vm.checkFinancialAccount = function (forFinancialAccount) {
            var currentAccount = accountService.getDefault();
            var landingCompany = currentAccount ? currentAccount.landing_company_name : '';
            return forFinancialAccount ? isLandingCompanyOf('maltainvest', landingCompany) : true;
        };
    }
})();
"use strict";

/**
 * @name Singin Controller
 * @author Morteza Tavanarad
 * @contributors []
 * @since 8/10/2016
 * @copyright Binary Ltd
 */

(function () {
    Signin.$inject = ["$scope", "$state", "$stateParams", "$ionicLoading", "accountService", "languageService", "websocketService", "alertService", "appStateService", "validationService"];
    angular.module("binary.pages.signin.controllers").controller("SigninController", Signin);

    Signin.$inejct = ["$scope", "$state", "$stateParams", "$ionicLoading", "accountService", "languageService", "websocketService", "alertService", "appStateService", "validationService"];

    function Signin($scope, $state, $stateParams, $ionicLoading, accountService, languageService, websocketService, alertService, appStateService, validationService) {
        var vm = this;
        vm.validation = validationService;
        vm.showTokenForm = false;
        vm.showSignin = false;
        vm.showSignup = false;
        vm.showvirtualws = false;
        vm.data = {};
        vm.tokenError = false;
        vm.passwordError = false;
        vm.ios = ionic.Platform.isIOS();
        vm.android = ionic.Platform.isAndroid();
        vm.disableNextbutton = false;
        vm.clientCountryIsUK = false;
        vm.linkToRegulatory = "https://www.binary.com/" + (localStorage.getItem("language") || "en") + "/regulation.html";
        vm.gamStopLink = "https://www.gamstop.co.uk/";

        /**
         * On load:
         * Open the websocket
         * If default account is set, send it for validation
         */
        var init = function init() {
            vm.language = languageService.read();

            // Checking url params to get accoutn tokens from /redirect.
            if (!_.isEmpty($stateParams.accountTokens)) {
                vm.showSignin = true;
                vm.data.accountTokens = $stateParams.accountTokens;
            }

            // Checking the url param to get verficatoin code.
            if (!_.isEmpty($stateParams.verificationCode)) {
                vm.showvirtualws = true;
                vm.data.verificationCode = $stateParams.verificationCode;
                websocketService.sendRequestFor.residenceListSend();
            }
        };

        init();

        $scope.$on("authorize", function (e, response, message) {
            $ionicLoading.hide();
            if (response) {
                if (accountService.isUnique(response.loginid)) {
                    var account = {};
                    var accountList = response.account_list;
                    if (accountList) {
                        var acc = _.find(accountList, function (a) {
                            return a.loginid === response.loginid;
                        });
                        account = _.assign(response, acc);
                    }
                    accountService.add(account);
                    accountService.setDefault(response.token);
                    appStateService.virtuality = response.is_virtual;
                }
                vm.token = "";
                $state.go("trade");
            } else {
                alertService.accountError.tokenNotAuthenticated(message);
            }
        });

        /**
         * SignIn button: event handler
         * @param  {String} _token 15char token
         */
        vm.signIn = function () {
            var _token = vm.token;
            // Validate the token
            if (_token && _token.length === 15) {
                $ionicLoading.show();
                websocketService.authenticate(_token);
            } else {
                alertService.accountError.tokenNotValid();
            }
        };

        // sign up email verify
        vm.verifyUserMail = function () {
            vm.emailError = false;
            var mail = vm.data.mail ? vm.data.mail : "";
            websocketService.sendRequestFor.accountOpening(_.trim(vm.data.mail));
            vm.isVerifyingEmail = true;
        };

        $scope.$on("verify_email", function (e, verify_email) {
            if (verify_email === 1) {
                $scope.$applyAsync(function () {
                    vm.emailError = false;
                    vm.showvirtualws = true;
                    vm.showSignup = false;
                    vm.isVerifyingEmail = false;
                });
            }
        });

        $scope.$on("verify_email:error", function (e, details) {
            $scope.$applyAsync(function () {
                vm.emailError = true;
                vm.emailErrorMessage = details.verify_email;
                vm.isVerifyingEmail = false;
            });
        });

        // virtual ws opening
        $scope.$watch("vm.showSignup", function () {
            if (vm.showSignup) {
                websocketService.sendRequestFor.residenceListSend();
            }
        });

        $scope.$on("residence_list", function (e, residence_list) {
            vm.data.residenceList = residence_list;
        });

        // Hide & show password function
        vm.data.inputType = "password";
        vm.hideShowPassword = function () {
            if (vm.data.inputType === "password") vm.data.inputType = "text";else vm.data.inputType = "password";
        };

        vm.createVirtualAccount = function () {
            vm.tokenError = false;
            vm.passwordError = false;
            var verificationCode = _.trim(vm.data.signupToken);
            var clientPassword = vm.data.clientPassword;
            var residence = vm.data.residence;
            websocketService.sendRequestFor.newAccountVirtual(verificationCode, clientPassword, residence);
        };

        $scope.$on("new_account_virtual", function (e, new_account_virtual) {
            if (!appStateService.isLoggedin) {
                var _token = new_account_virtual.oauth_token;
                websocketService.authenticate(_token);
                vm.showTokenForm = false;
                vm.showSignin = false;
                vm.showSignup = false;
                vm.showvirtualws = false;
            }
        });

        $scope.$on("new_account_virtual:error", function (e, error) {
            $scope.$applyAsync(function () {
                if (error) {
                    if (error.hasOwnProperty("details") && error.details.hasOwnProperty("verification_code")) {
                        vm.tokenError = true;
                        vm.tokenErrorMessage = error.details.verification_code || error.code;
                    }
                    if (error.hasOwnProperty("code") && error.code === "InvalidToken") {
                        vm.tokenError = true;
                        vm.tokenErrorMessage = error.message;
                    }
                    if (error.hasOwnProperty("details") && error.details.hasOwnProperty("client_password")) {
                        vm.passwordError = true;
                        vm.passwordErrorMessage = error.details.client_password || error.code;
                    }
                    if (error.hasOwnProperty("code") && error.code === "PasswordError") {
                        vm.passwordError = true;
                        vm.passwordErrorMessage = error.message;
                    }
                }
            });
        });

        $scope.$on("website_status", function (e, website_status) {
            $scope.$applyAsync(function () {
                if (/gb/.test(website_status.clients_country)) {
                    vm.clientCountryIsUK = true;
                }
            });
        });

        // change different type of singing methods
        vm.changeSigninView = function (_isBack) {
            _isBack = _isBack || false;

            $scope.$applyAsync(function () {
                if (!vm.showSignin && !vm.showSignup && !vm.showvirtualws && vm.showTokenForm) {
                    vm.showTokenForm = false;
                    vm.showSignin = true;
                } else if (!vm.showSignin && vm.showSignup && !vm.showTokenForm && !vm.showvirtualws) {
                    vm.showSignup = false;
                    vm.showSignin = true;
                } else if (!vm.showSignin && !vm.showSignup && !vm.showTokenForm && vm.showvirtualws) {
                    vm.showvirtualws = false;
                    vm.showSignup = false;
                    vm.showSignin = true;
                } else if (!vm.showSignin && vm.showSignup && !vm.showTokenForm && !vm.showvirtualws) {
                    vm.showvirtualws = false;
                    vm.showSignup = false;
                    vm.showSignin = true;
                } else if (vm.showSignin && !vm.showSignup && !vm.showTokenForm && !vm.showvirtualws && _isBack) {
                    vm.showSignin = false;
                }
            });
        };

        vm.changeSigninViewtoSignup = function () {
            if (vm.showSignin && !vm.showSignup) {
                vm.showSignup = true;
                vm.showSignin = false;
            }
        };

        vm.showSigninView = function () {
            $scope.$applyAsync(function () {
                vm.showSignin = true;
            });
        };

        $scope.$watch(function () {
            return appStateService.isLanguageReady;
        }, function (newValue, oldValue) {
            vm.disableNextbutton = !newValue;
        });

        vm.goToRegulatory = function () {
            window.open(vm.linkToRegulatory, "_blank");
        };

        vm.goToGamStop = function () {
            window.open(vm.gamStopLink, "_blank");
        };
    }
})();
"use strict";

/**
 * @name statement controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.statement.controllers").controller("StatementController", Statement);

    Statement.$inject = ["$scope", "$filter", "$timeout", "$state", "$templateCache", "$ionicScrollDelegate", "config", "tableStateService", "websocketService", "appStateService"];

    function Statement($scope, $filter, $timeout, $state, $templateCache, $ionicScrollDelegate, config, tableStateService, websocketService, appStateService) {
        var vm = this;
        vm.data = {};
        vm.noTransaction = false;
        vm.noMore = false;
        vm.ios = ionic.Platform.isIOS();
        vm.android = ionic.Platform.isAndroid();
        vm.goToTopButton = false;
        vm.firstCompleted = false;
        vm.jumpToDateInputShow = false;
        vm.hasError = false;
        vm.dateChanged = false;
        vm.isItemShown = false;
        var appIdAllowed = config.app_id;
        var enteredNow = false;
        var backFromMainPages = false;
        var noMoreRequest = false;
        vm.fractionalDigits = 2;

        var notAuthorizeYet = function notAuthorizeYet() {
            // check if app is authorized already or has to wait for it to be authorized
            if (appStateService.isLoggedin) {
                vm.currency = sessionStorage.getItem('currency') || 'USD';
                var currencyConfig = appStateService.currenciesConfig || {};
                vm.fractionalDigits = !_.isEmpty(currencyConfig) && currencyConfig[vm.currency] ? currencyConfig[vm.currency].fractional_digits : 2;
                if (appStateService.statementRefresh || backFromMainPages) {
                    $templateCache.remove();
                    resetParams();
                    vm.jumpToDateInputShow = false;
                    vm.firstCompleted = false;
                    noMoreRequest = false;
                    vm.hasError = false;
                    vm.filteredTransactions = [];
                    vm.noTransaction = false;
                    backFromMainPages = false;
                    tableStateService.statementCompletedGroup = true;
                    appStateService.statementRefresh = false;
                    appStateService.isStatementSet = false;
                    loadMore();
                }
            }
            // else{
            //    wait for authorize
            // }
        };

        $scope.$on("$stateChangeSuccess", function (ev, to, toParams, from, fromParams) {
            vm.lastPage = from.name;
            enteredNow = true;
            vm.thisPage = to.name;
            // check if state is changed from any state other than transaction-detail
            // we do not refresh the state if it comes back from transaction-detail
            if (vm.lastPage !== "transaction-detail" && vm.thisPage === "statement") {
                resetParams();
                vm.firstCompleted = false;
                backFromMainPages = true;
                vm.jumpToDateInputShow = false;
                notAuthorizeYet();
            }
        });

        $scope.$on("authorize", function (e, response) {
            if (appStateService.statementRefresh) {
                notAuthorizeYet();
            }
        });

        vm.delayedLoad = function () {
            $timeout(loadMore, 50);
        };

        var loadMore = function loadMore() {
            if (!tableStateService.statementCompletedGroup) {
                // here can load some amount of transactions already recieved
                setBatch();
            } else if (tableStateService.statementCompletedGroup) {
                tableStateService.statementCurrentPage += 1;
                pageState();
            }
        };

        var pageState = function pageState() {
            if (!appStateService.isStatementSet) {
                appStateService.isStatementSet = true;
                tableStateService.statementDateType = "allTime";
                vm.jumpToDateInputShow = false;
                resetParams();
                setParams();
                tableStateService.statementCompletedGroup = false;
                vm.goTop();
            } else if (!appStateService.isStatementSet && enteredNow && vm.lastPage === "transaction-detail") {
                enteredNow = false;
                vm.lastPage = "";
                setParams();
            } else if (appStateService.isStatementSet && vm.dateChanged && tableStateService.statementCompletedGroup) {
                vm.transactions = [];
                vm.batchedTransaction = [];
                vm.filteredTransactions = [];
                vm.dateChanged = false;
                tableStateService.statementCurrentPage = 0;
                tableStateService.statementBatchNum = 0;
                tableStateService.statementBatchLimit = 0;
                tableStateService.statementCompletedGroup = false;
                setParams();
                vm.goTop();
            } else if (appStateService.isStatementSet && !vm.dateChanged && tableStateService.statementCompletedGroup) {
                vm.transactions = [];
                tableStateService.statementCompletedGroup = false;
                setParams();
            } else if (!vm.dateChanged) {
                setParams();
                $scope.$applyAsync(function () {
                    vm.noMore = false;
                });
            }
            sendRequest();
        };

        var setParams = function setParams() {
            vm.data.appID = tableStateService.statementAppID;
            vm.data.dateType = tableStateService.statementDateType;
            vm.data.dateFrom = tableStateService.statementDateFrom;
            vm.data.dateTo = tableStateService.statementDateTo;
            vm.data.statementCurrentPage = tableStateService.statementCurrentPage;
            vm.itemsPerPage = 300;
            vm.limit = vm.itemsPerPage + 1;
        };

        var resetParams = function resetParams() {
            tableStateService.statementAppID = "allApps";
            tableStateService.statementDateFrom = "";
            tableStateService.statementDateTo = "";
            tableStateService.statementCurrentPage = 0;
            vm.transactions = [];
            vm.batchedTransaction = [];
            tableStateService.statementCompletedGroup = true;
            tableStateService.statementBatchNum = 0;
            tableStateService.statementBatchLimit = 0;
        };

        var sendRequest = function sendRequest() {
            var params = {
                description: 1,
                limit: vm.limit,
                offset: vm.itemsPerPage * vm.data.statementCurrentPage
            };
            if (vm.data.hasOwnProperty("dateFrom") && vm.data.dateFrom !== "") {
                params.date_from = vm.data.dateFrom;
            }
            if (vm.data.hasOwnProperty("dateTo") && vm.data.dateTo !== "") {
                params.date_to = vm.data.dateTo + 8.64e4;
            }
            params.req_id = vm.data.dateTo || Math.round(new Date().getTime() / 1000);
            vm.reqId = params.req_id;
            websocketService.sendRequestFor.statement(params);
        };

        $scope.$on("statement:update", function (e, _statement, _req_id) {
            vm.firstCompleted = true;
            vm.statement = _statement;
            var count = vm.statement.count;
            vm.hasError = false;
            if (vm.reqId === _req_id) {
                if (count === 0) {
                    vm.noTransaction = true;
                    $scope.$applyAsync(function () {
                        vm.noMore = true;
                    });
                    setBatch();
                } else if (count > 0) {
                    if (count < vm.limit) {
                        // has no more to load on next call
                        vm.noTransaction = false;
                        // $scope.$applyAsync(() => {
                        noMoreRequest = true;
                        // });
                        vm.statement.transactions.forEach(function (el, i) {
                            vm.transactions.push(vm.statement.transactions[i]);
                        });
                        setBatch();
                    } else if (count === vm.limit) {
                        // has at least one transaction on next call to show to user
                        vm.noTransaction = false;
                        $scope.$applyAsync(function () {
                            vm.noMore = false;
                        });
                        vm.statement.transactions.forEach(function (el, i) {
                            if (i < count - 1) {
                                vm.transactions.push(vm.statement.transactions[i]);
                            }
                        });
                        setBatch();
                    }
                }
            }
        });

        $scope.$on("statement:error", function (e, message) {
            $scope.$applyAsync(function () {
                vm.hasError = true;
                vm.errorMessage = message;
            });
        });

        var setBatch = function setBatch() {
            tableStateService.statementBatchLimit = Math.ceil(vm.transactions.length / tableStateService.statementBatchSize);
            var sliced = [];
            sliced = vm.transactions.slice(tableStateService.statementBatchNum * tableStateService.statementBatchSize, (tableStateService.statementBatchNum + 1) * tableStateService.statementBatchSize);
            sliced.forEach(function (el, i) {
                vm.batchedTransaction.push(sliced[i]);
            });
            tableStateService.statementBatchNum += 1;
            if (tableStateService.statementBatchNum === tableStateService.statementBatchLimit) {
                tableStateService.statementBatchLimit = 0;
                tableStateService.statementBatchNum = 0;
                tableStateService.statementCompletedGroup = true;
                if (noMoreRequest) {
                    $scope.$applyAsync(function () {
                        vm.noMore = true;
                    });
                }
            }

            vm.setFiltered();
        };

        vm.setFiltered = function () {
            $scope.$applyAsync(function () {
                tableStateService.statementAppID = vm.data.appID;
                vm.filteredTransactions = $filter("StatementDataFilter")(vm.batchedTransaction, tableStateService.statementAppID, appIdAllowed);
                if (vm.filteredTransactions.length === 0) {
                    vm.noTransaction = true;
                } else {
                    vm.noTransaction = false;
                }
                $scope.$broadcast("scroll.infiniteScrollComplete");
            });
        };

        vm.dateFilter = function () {
            tableStateService.statementDateType = vm.data.dateType;
            vm.dateChanged = true;
            vm.noTransaction = false;
            if (vm.data.dateType === "allTime") {
                $scope.$applyAsync(function () {
                    vm.jumpToDateInputShow = false;
                });
                tableStateService.statementCompletedGroup = true;
                vm.firstCompleted = false;
                vm.data.dateTo = "";
                tableStateService.statementDateFrom = "";
                tableStateService.statementDateTo = "";
                loadMore();
            }
            if (vm.data.dateType === "jumpToDate") {
                $scope.$applyAsync(function () {
                    vm.jumpToDateInputShow = true;
                });
                tableStateService.statementCompletedGroup = true;
                vm.firstCompleted = false;
                vm.nowDateInputLimit = $filter("date")(new Date(), "yyyy-MM-dd");
                document.getElementById("statement-dateTo").setAttribute("max", vm.nowDateInputLimit);
                document.getElementById("statement-dateTo").value = vm.nowDateInputLimit;
                vm.jumpToDateFilter();
            }
        };

        vm.jumpToDateFilter = function () {
            if (tableStateService.statementDateType === "jumpToDate") {
                tableStateService.statementCompletedGroup = true;
                vm.dateChanged = true;
                vm.noTransaction = false;
                vm.firstCompleted = false;
                tableStateService.statementCurrentPage = 0;
                vm.data.dateTo = new Date(vm.data.end).getTime() / 1000 || "";
                tableStateService.statementDateTo = vm.data.dateTo;
                loadMore();
            }
        };

        vm.toggleItem = function () {
            vm.isItemShown = !vm.isItemShown;
            var content = document.getElementsByClassName("statement-content-expandable")[0];
            content.id = content.id === "statement-filter-active" ? "" : "statement-filter-active";
        };

        vm.goTop = function () {
            $ionicScrollDelegate.scrollTop(true);
        };

        vm.goToTopButtonCondition = function () {
            $timeout(function () {
                var position = $ionicScrollDelegate.$getByHandle("handler").getScrollPosition();
                vm.goToTopButton = position ? position.top >= 30 : false;
            }, 500);
        };

        // details functions
        vm.sendContractDetailRequest = function (id) {
            if (id) {
                sessionStorage.setItem("id", id);
                $state.go("transaction-detail");
            }
        };
    }
})();
"use strict";

/**
 * @name profit-table filter
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.statement.filters").filter("StatementDataFilter", StatementDataFilter);

    StatementDataFilter.$inject = ["$filter"];

    function StatementDataFilter(transactions, appID, appIdAllowed) {
        function DataChange(transactions, appID, appIdAllowed) {
            var filtered = [];

            transactions.forEach(function (value, i) {
                var item = transactions[i];
                var itemId = item.app_id;
                if (appID === "allApps" || appID === "tickTradeApp" && itemId === appIdAllowed.toString()) {
                    filtered.push(item);
                }
            });
            return filtered;
        }
        return DataChange;
    }
    return StatementDataFilter;
})();
"use strict";

/**
 * @name accept terms and conditions controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 12/14/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.terms-and-conditions.controllers").controller("TermsAndConditionsController", TermsAndConditions);

    TermsAndConditions.$inject = ["$scope", "$state", "websocketService", "alertService"];

    function TermsAndConditions($scope, $state, websocketService, alertService) {
        var vm = this;
        vm.data = {};
        vm.data.landingCompanyName = localStorage.getItem("landingCompanyName");
        vm.data.linkToTermAndConditions = "https://www.binary.com/" + (localStorage.getItem("language") || "en") + "/terms-and-conditions.html";

        vm.updateUserTermsAndConditions = function () {
            return websocketService.sendRequestFor.TAndCApprovalSend();
        };

        vm.openTermsAndConditions = function () {
            window.open(vm.data.linkToTermAndConditions, "_blank");
        };

        $scope.$on("tnc_approval", function (e, tnc_approval) {
            if (tnc_approval === 1) {
                $state.go("trade");
            }
        });

        $scope.$on("tnc_approval:error", function (e, error) {
            alertService.displayError(error.message);
        });
    }
})();
"use strict";

/**
 * @name proposal service
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/27/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.services").factory("proposalService", Proposal);

    Proposal.$inject = ["$rootScope", "appStateService", "websocketService"];

    function Proposal($rootScope, appStateService, websocketService) {
        var factory = {};

        var proposalSchema = {
            amount: {
                presence: true,
                format: {
                    pattern: /^[0-9]+([.][0-9]+)?$/
                }
            },
            basis: {
                persence: true,
                format: {
                    pattern: /^payout|stake$/
                }
            },
            contract_type: {
                persence: true,
                format: {
                    pattern: /^\w{2,30}$/
                }
            },
            currency: {
                persence: true,
                format: {
                    pattern: /^[A-Z]{3}$/
                }
            },
            duration: {
                persence: true,
                format: {
                    pattern: /^\d+$/
                }
            },
            duration_unit: {
                persence: true,
                format: {
                    pattern: /^d|m|s|h|t$/
                }
            },
            symbol: {
                persence: true,
                format: {
                    pattern: /^\w{2,30}$/
                }
            },
            barrier: {
                persence: false,
                format: {
                    pattern: /^[+-]?\d+\.?\d*$/
                }
            }
        };

        factory.openContractId = '';

        factory.get = function () {
            if (_.isEmpty(localStorage.options)) {
                return create();
            }
            var options = JSON.parse(localStorage.options);
            var proposal = create();
            proposal.symbol = options.underlying.symbol;
            proposal.duration = parseInt(options.tick);
            if (options.tradeType === "Higher/Lower") {
                proposal.barrier = _.isEmpty(options.barrier) ? "" : options.barrier;
            } else {
                proposal.barrier = options.digit;
            }
            if (options.tradeType === 'High/Low Ticks') {
                proposal.selected_tick = options.selected_tick;
            } else {
                proposal.selected_tick = '';
            }
            proposal.tradeType = options.tradeType;
            proposal.basis = options.basis || proposal.basis;
            proposal.currency = sessionStorage.currency || "USD";

            var currencyConfig = appStateService.currenciesConfig[sessionStorage.currency];
            if (currencyConfig && currencyConfig.type === "crypto") {
                proposal.amount = options.cryptoAmount || proposal.amount;
            } else {
                proposal.amount = options.amount || proposal.amount;
            }
            return proposal;
        };

        factory.save = function (options) {
            localStorage.options = JSON.stringify(options);
        };

        factory.setPropertyValue = function (propertyName, value) {
            var options = JSON.parse(localStorage.options);
            options[propertyName] = value;
            localStorage.options = JSON.stringify(options);
            $rootScope.$broadcast("options:updated", options);
        };

        factory.update = function (options) {
            var proposal = factory.get();

            var currencyConfig = appStateService.currenciesConfig[sessionStorage.currency];
            if (currencyConfig && currencyConfig.type === "crypto") {
                var amount = options.amount || proposal.cryptoAmount;
                options.cryptoAmount = amount;
                options.amount = proposal.amount;
                proposal.amount = amount;
            } else {
                proposal.amount = options.amount || proposal.amount;
            }

            proposal.symbol = options.underlying.symbol;
            proposal.duration = parseInt(options.tick);
            if (options.tradeType === "Higher/Lower") {
                proposal.barrier = _.isEmpty(options.barrier) ? "" : options.barrier;
            } else {
                proposal.barrier = options.digit;
            }
            proposal.selected_tick = options.tradeType === "High/Low Ticks" ? options.selected_tick : null;
            proposal.tradeType = options.tradeType;
            proposal.basis = options.basis || proposal.basis;

            factory.save(options);
            return proposal;
        };

        factory.send = function (proposal) {
            delete proposal.tradeType;
            if (validate(proposal)) {
                websocketService.sendRequestFor.proposal(proposal);
                return true;
            }
            return false;
        };

        factory.forget = function (reqId) {
            websocketService.sendRequestFor.forgetProposals(reqId);
        };

        factory.purchase = function (contract) {
            websocketService.sendRequestFor.purchase(contract.id, contract.ask_price);
            factory.forget();
        };

        function create() {
            var proposal = {
                subscribe: 1,
                proposal: 1,
                symbol: null,
                contract_type: null,
                duration: null,
                basis: "payout",
                currency: sessionStorage.currency || "USD",
                amount: isCryptoCurrency() ? 0.005 : 5,
                duration_unit: "t",
                passthrough: null
            };

            return proposal;
        }

        function isCryptoCurrency() {
            var correncyConfig = appStateService.currenciesConfig[sessionStorage.currency];
            if (correncyConfig && correncyConfig.type === 'crypto') {
                return true;
            }
            return false;
        }

        function validate(proposal) {
            var isValidate = true;
            _.forEach(proposal, function (value, key) {
                if (value == null || value === "") {
                    delete proposal[key];
                }
            });

            _.forEach(proposalSchema, function (value, key) {
                if (proposal[key]) {
                    if (!value.format.pattern.test(proposal[key])) {
                        isValidate = false;
                    }
                } else if (proposal[key] === undefined && value.persence) {
                    isValidate = false;
                }
            });
            return isValidate;
        }

        return factory;
    }
})();
"use strict";

/**
 * @name trade controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/27/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.controllers").controller("TradeController", Trade);

    Trade.$inject = ["proposalService"];

    function Trade(proposalService) {
        var vm = this;

        vm.proposal = {};
        vm.purchasedContract = {};

        function init() {
            vm.proposal = proposalService.get();
        }

        init();

        angular.element(document).ready(function () {
            // if (ionic.Platform.isIOS()) {
            //     document.getElementById("trade-container").style.paddingBottom = "20px";
            // }
            if (!ionic.Platform.isWebView()) {
                var tradeContainer = document.getElementById("trade-container");
                if (tradeContainer !== undefined && tradeContainer !== null) {
                    tradeContainer.className = "web-view-trade";
                }
            }
            window.addEventListener("native.keyboardshow", keyboardShowHandler);
            window.addEventListener("native.keyboardhide", keyboardHideHandler);

            function keyboardShowHandler(e) {
                var tradeContainer = document.getElementById("trade-container");
                if (tradeContainer !== undefined && tradeContainer !== null) {
                    tradeContainer.className = "";
                }
            }

            function keyboardHideHandler(e) {
                var tradeContainer = document.getElementById("trade-container");
                if (tradeContainer !== undefined && tradeContainer !== null) {
                    tradeContainer.className = "flexed";
                }
            }
        });
    }
})();
"use strict";

/**
 * @name trade save
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/27/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.services").factory("tradeService", Trade);

    function Trade() {
        var factory = {};

        factory.proposalIsReady = false;

        return factory;
    }
})();
"use strict";

/**
 * @name Trading Times controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 01/24/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trading-times.controllers").controller("TradingTimesController", TradingTimes);

    TradingTimes.$inject = ["$scope", "$filter", "websocketService"];

    function TradingTimes($scope, $filter, websocketService) {
        var vm = this;
        vm.isDataLoaded = false;
        vm.data = {};
        vm.hasError = false;
        vm.now = Math.round(new Date().getTime());
        angular.element(document).ready(function () {
            document.getElementById("date").setAttribute("min", $filter("date")(vm.now, "yyyy-MM-dd"));
            document.getElementById("date").value = $filter("date")(vm.now, "yyyy-MM-dd");
        });

        vm.sendTradingTimes = function () {
            vm.epochDate = vm.data.date || Math.round(new Date().getTime());
            vm.date = $filter("date")(vm.epochDate, "yyyy-MM-dd");
            websocketService.sendRequestFor.tradingTimes(vm.date);
        };

        vm.sendTradingTimes();

        $scope.$on("trading_times:success", function (e, trading_times) {
            vm.tradingTimes = trading_times;
            vm.marketDisplayNames = [];
            var allActiveSymbols = JSON.parse(sessionStorage.getItem('all_active_symbols'));
            vm.activeSymbols = _.groupBy(allActiveSymbols, "market");
            Object.values(vm.activeSymbols).forEach(function (market, j) {
                if (!vm.marketDisplayNames.market) vm.marketDisplayNames.push(market[0].market_display_name);
            });
            $scope.$applyAsync(function () {
                vm.hasError = false;
                vm.data.markets = _.filter(vm.tradingTimes.markets, function (market) {
                    return vm.marketDisplayNames.indexOf(market.name) > -1;
                });
                vm.market = vm.data.markets[0].name;
                vm.isDataLoaded = true;
            });
        });

        $scope.$on("trading_times:error", function (e, error) {
            $scope.$applyAsync(function () {
                vm.isDataLoaded = true;
                vm.hasError = true;
                vm.error = error;
            });
        });

        vm.getTranslationId = function (title) {
            if (title === "Closes early (at 21:00)" || title === "Closes early (at 18:00)") {
                return "trading-times." + title.replace(/[\s]/g, '_').toLowerCase();
            }
            return title;
        };
    }
})();
"use strict";

/**
 * @name transaction-detail controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.transaction-detail.controllers").controller("TransactionDetailController", TransactionDetail);

    TransactionDetail.$inject = ["$scope", "$timeout", "appStateService", "websocketService"];

    function TransactionDetail($scope, $timeout, appStateService, websocketService) {
        var vm = this;
        vm.currency = sessionStorage.getItem("currency");
        vm.fractionalLength = 2;
        var activeSymbols = JSON.parse(sessionStorage.getItem("all_active_symbols"));
        var id = sessionStorage.getItem("id");
        var contractId = parseInt(id);
        var extraParams = {
            req_id: contractId
        };

        var getFractionalLength = function getFractionalLength(floatNumber) {
            var stringNumber = floatNumber.toString();
            var decimalLength = stringNumber.indexOf(".");
            return stringNumber.length - decimalLength - 1;
        };

        var sendDetailsRequest = function sendDetailsRequest() {
            if (appStateService.isLoggedin) {
                websocketService.sendRequestFor.openContract(id, extraParams);
            } else {
                $timeout(sendDetailsRequest, 500);
            }
        };

        $scope.$on("proposal:open-contract", function (e, proposal_open_contract, req_id) {
            var proposalOpenContract = proposal_open_contract;
            var reqId = req_id;

            if (reqId === contractId) {
                var activeSymbol = activeSymbols.find(function (activeSymbol) {
                    return activeSymbol.symbol === proposalOpenContract.underlying;
                });
                var pip = activeSymbol.pip || 0.01;
                vm.fractionalLength = getFractionalLength(pip);
                vm.contract = proposalOpenContract;
                $scope.$apply();
            }
        });

        sendDetailsRequest();
    }
})();
"use strict";

/**
 * @name update controller
 * @author Morteza Tavanarad
 * @contributors []
 * @since 12/26/2015
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.update.controllers").controller("UpdateController", Update);

    Update.$inject = ["$http", "$scope", "languageService"];

    function Update($http, $scope, languageService) {
        var vm = this;
        vm.storeLogo = null;
        vm.lastVersion = null;
        vm.showSpinner = true;
        vm.platform = null;

        vm.openExternal = function (url) {
            window.open(url, "_system");
            return false;
        };

        init();

        function init() {
            getVersions();
        }

        function getVersions() {
            $http({
                method: "GET",
                url: "versions.json"
            }).then(function (response) {
                if (response.data) {
                    $scope.$applyAsync(function () {
                        vm.showSpinner = false;
                        var versions = response.data;
                        vm.lastVersion = versions.pop();
                        generateStoreLogo();
                    });
                }
            }, function (error) {
                vm.versions = null;
            });
        }

        function generateStoreLogo() {
            var language = languageService.read();
            vm.platform = "appstore";
            if (ionic.Platform.isAndroid()) {
                vm.platform = "googleplay";
            }
            vm.storeLogo = "img/" + vm.platform + "/" + language + ".svg";
        }
    }
})();
"use strict";

/**
 * @name accountService
 * @author Massih Hazrati
 * @contributors []
 * @since 10/26/2015
 * @copyright Binary Ltd
 */

angular.module("binary").service("accountService", ["websocketService", "appStateService", "delayService", function (websocketService, appStateService, delayService) {
    var _this = this;

    /**
    * find a {key,value} in an array of objects and return its index
    * returns -1 if not found
    * @param  {Array of Objects} _accounts
    * @param  {String} _key
    * @param  {String, Number, Boolean} _value
    * @return {Number} Index of the found array element
    */

    this.addedAccount = "";
    var findIndex = function findIndex(_accounts, _key, _value) {
        var index = -1;
        _accounts.forEach(function (el, i) {
            if (_accounts[i][_key] === _value) {
                index = i;
            }
        });
        return index;
    };

    /**
    * Check if the 'accounts' localStorage exist
    * @return {Boolean}
    */
    var storageExist = function storageExist() {
        return localStorage.accounts && JSON.parse(localStorage.accounts) instanceof Array;
    };

    /**
    * Returns the list of all accounts
    * @return {Array}
    */
    this.getAll = function () {
        var accounts = storageExist() ? JSON.parse(localStorage.accounts) : [];
        if (accounts.length > 0) {
            accounts = accounts.sort(function (a, b) {
                if (a.currency === null) {
                    return 1;
                } else if (b.currency === null) {
                    return -1;
                } else if (a.currency === b.currency) {
                    return 0;
                } else if (a.currency < b.currency) {
                    return -1;
                }
                return 1;
            });
        }
        return accounts;
    };

    /**
    * Removes the 'accounts' localStorage
    */
    this.removeAll = function () {
        localStorage.removeItem("accounts");
    };

    /**
    * Send a token for validation
    * if '_token' param is not passed, validates the default token
    * @param  {String} _token
    */
    var validate = function validate(_token, extraParams) {
        // Remove the last delay queue of 'symbolsAndAssetIndexUpdate'
        delayService.remove("symbolsAndAssetIndexUpdate");

        if (_token) {
            websocketService.authenticate(_token, extraParams);
        } else {
            var accountList = this.getAll();
            var defaultAccountIndex = findIndex(accountList, "is_default", true);
            // If default account exist
            if (defaultAccountIndex > -1) {
                var token = accountList[defaultAccountIndex].token;
                websocketService.authenticate(token, extraParams);
            }
        }
    };

    this.validate = function (_token, extraParams) {
        if (!_token) {
            var accountList = this.getAll();
            var defaultAccountIndex = findIndex(accountList, "is_default", true);
            // If default account exist
            if (defaultAccountIndex > -1) {
                _token = accountList[defaultAccountIndex].token;
            }
        }

        validate(_token, extraParams);
    };

    /**
    * Add an account to the 'accounts' localStorage
    * @param {Object} _account
    */
    this.add = function (_account) {
        var account = {
            id: _account.loginid,
            token: _account.token,
            currency: _account.currency,
            email: _account.email,
            country: _account.country,
            is_disabled: _account.is_disabled,
            is_ico_only: _account.is_ico_only,
            is_virtual: _account.is_virtual,
            excluded_until: _account.excluded_until,
            landing_company_name: _account.landing_company_name
        };

        var accountList = this.getAll();

        if (_.find(accountList, ["id", account.id])) {
            return;
        }

        accountList.push(account);
        localStorage.accounts = JSON.stringify(accountList);
    };

    /**
    * Removes an account from 'accounts' localStorage
    * Doesn't remove the default account
    * @param  {String} _token
    */
    this.remove = function (_token) {
        var accountList = this.getAll();
        var index = findIndex(accountList, "token", _token);
        // If the token exist and is not the default token
        if (index > -1 && accountList[index].is_default !== true) {
            accountList.splice(index, 1);
            localStorage.accounts = JSON.stringify(accountList);
        }
    };

    /**
    * Set the passed token as the default account
    * @param {String} _token
    */
    this.setDefault = function (_token) {
        var accountList = this.getAll();
        var index = findIndex(accountList, "token", _token);
        // Make sure the token exist
        if (index > -1) {
            accountList.forEach(function (el, i) {
                accountList[i].is_default = accountList[i].token === _token;
            });
            localStorage.accounts = JSON.stringify(accountList);
        }
    };

    /**
    * Check if the default account exist
    * @return {Boolean}
    */
    this.hasDefault = function () {
        var accountList = this.getAll();
        var index = findIndex(accountList, "is_default", true);
        return index > -1;
    };

    /**
    * Returns the default account
    * @return {Object}
    */
    this.getDefault = function () {
        var accountList = this.getAll();
        var index = findIndex(accountList, "is_default", true);
        if (index === -1) {
            return null;
        }
        return accountList[index];
    };

    /**
    * Check if the token/account is unique
    * Only one token for each account is allowed
    * @param  {String}  _id : loginid
    * @return {Boolean}
    */
    this.isUnique = function (_id) {
        var accountList = this.getAll();
        var index = findIndex(accountList, "id", _id);
        return !(index > -1);
    };

    this.checkScope = function (_scope) {
        var scopes = _.concat([], _scope);
        var result = false;

        if (appStateService.isLoggedin && !_.isEmpty(appStateService.scopes)) {
            result = true;
            scopes.some(function (value, index) {
                if (appStateService.scopes.indexOf(value.toLowerCase()) < 0) {
                    result = false;
                    return true;
                }
                return false;
            });
        }
        return result;
    };

    this.getAllloginids = function (_accounts) {
        var allLoginids = [];
        var accounts = _accounts || _this.getAll();
        accounts.forEach(function (account) {
            allLoginids.push(account.id);
        });
        return allLoginids;
    };
}]);
"use strict";

/**
 * @name alertService
 * @author Massih Hazrati
 * @contributors []
 * @since 10/26/2015
 * @copyright Binary Ltd
 */

angular.module("binary").service("alertService", ["$translate", "$ionicPopup", "$rootScope", function ($translate, $ionicPopup, $rootScope) {
    var _this = this;

    var displayAlert = function displayAlert(_title, _message, _button, _callback) {
        $translate(["alert.ok"]).then(function (translation) {
            if (navigator.notification === undefined) {
                var alertPopup = $ionicPopup.alert({
                    title: _title,
                    template: _message,
                    buttons: [{
                        type: "button-positive",
                        text: _button || translation["alert.ok"]
                    }]
                });
                alertPopup.then(_callback);
            } else {
                navigator.notification.alert(_message, _callback, _title, _button || translation["alert.ok"]);
            }
        });
    };

    var displayConfirmation = function displayConfirmation(_title, _message, _buttons, _callback) {
        if (navigator.notification === undefined) {
            var confirmPopup = $ionicPopup.confirm({
                title: _title,
                template: _message,
                buttons: _buttons
            });
            confirmPopup.then(_callback);
        } else {
            navigator.notification.confirm(_message, _callback, _title, _buttons);
        }
    };

    this.displayRealitCheckInterval = function (_title, _class, scope, _template, _buttons, _callback) {
        var showPopup = $ionicPopup.show({
            title: _title,
            cssClass: _class,
            scope: scope,
            templateUrl: _template,
            buttons: _buttons
        });
        showPopup.then(_callback);
    };

    this.displayRealityCheckResult = function (_title, _class, scope, _template, _buttons, _callback) {
        var showPopup = $ionicPopup.show({
            title: _title,
            cssClass: _class,
            scope: scope,
            templateUrl: _template,
            buttons: _buttons
        });
        showPopup.then(_callback);
    };

    this.displayIOSPWAPrompt = function (_title, _class, scope, _template, _buttons, _callback) {
        var showPopup = $ionicPopup.show({
            title: _title,
            cssClass: _class,
            scope: scope,
            templateUrl: _template,
            buttons: _buttons
        });
        showPopup.then(_callback);
        return showPopup;
    };

    this.displayError = function (_message) {
        $translate(["alert.error"]).then(function (translation) {
            displayAlert(translation["alert.error"], _message);
        });
    };

    this.displaySymbolWarning = function (_message, _callback) {
        $translate(["alert.warning", _message]).then(function (translation) {
            displayAlert(translation["alert.warning"], translation[_message]);
        });
    };

    this.accountError = {
        tokenNotValid: function tokenNotValid() {
            $translate(["alert.error", "alert.not_valid"]).then(function (translation) {
                displayAlert(translation["alert.error"], translation["alert.not_valid"]);
                // navigator.notification.alert(translation['alert.not_valid'], null, translation['alert.error'], 'OK');
            });
        },
        tokenNotAuthenticated: function tokenNotAuthenticated(message) {
            $translate(["alert.error", "alert.not_auth"]).then(function (translation) {
                displayAlert(translation["alert.error"], message || translation["alert.not_auth"]);
            });
        },
        tokenNotUnique: function tokenNotUnique() {
            $translate(["alert.error", "alert.not_unique"]).then(function (translation) {
                displayAlert(translation["alert.error"], translation["alert.not_unique"]);
            });
        }
    };

    this.contractError = {
        notAvailable: function notAvailable() {
            $translate(["alert.error", "alert.contract_error"]).then(function (translation) {
                displayAlert(translation["alert.error"], translation["alert.contract_error"]);
            });
        }
    };

    this.optionsError = {
        noTick: function noTick() {
            $translate(["alert.error", "alert.no_tick"]).then(function (translation) {
                displayAlert(translation["alert.error"], translation["alert.no_tick"]);
            });
        }
    };

    this.displayAlert = displayAlert;

    this.confirmAccountRemoval = function (_token) {
        $translate(["alert.remove_token_title", "alert.remove_token_content"]).then(function (translation) {
            displayConfirmation(translation["alert.remove_token_title"], translation["alert.remove_token_content"], ["Yes", "No"], function (res) {
                if (!(typeof res === "boolean")) {
                    if (res === 1) res = true;else res = false;
                }

                if (res) {
                    $rootScope.$broadcast("token:remove", _token);
                }
            });
        });
    };

    this.confirmRemoveAllAccount = function (_callback) {
        $translate(["alert.remove_all_tokens_title", "alert.remove_all_tokens_content", "alert.yes", "alert.no"]).then(function (translation) {
            var buttons = null;
            if (navigator.notification) {
                buttons = [translation["alert.yes"], translation["alert.no"]];
            } else {
                buttons = [{
                    text: translation["alert.no"],
                    onTap: function onTap() {
                        return false;
                    }
                }, {
                    text: translation["alert.yes"],
                    type: "button-positive",
                    onTap: function onTap() {
                        return true;
                    }
                }];
            }
            displayConfirmation(translation["alert.remove_all_tokens_title"], translation["alert.remove_all_tokens_content"], buttons, _callback);
        });
    };

    this.confirmExit = function (_callback) {
        $translate(["app.exit_title", "app.exit_confirmation", "alert.yes", "alert.no"]).then(function (translation) {
            displayConfirmation(translation["app.exit_title"], translation["app.exit_confirmation"], [translation["alert.yes"], translation["alert.no"]], _callback);
        });
    };

    this.showInformation = function (scope, title, templateUrl) {
        var showPopup = $ionicPopup.show({
            title: title,
            cssClass: 'information-popup',
            scope: scope,
            templateUrl: templateUrl,
            buttons: [{
                type: "button-positive",
                text: $translate.instant("alert.ok")
            }]
        });
        return showPopup;
    };

    this.showProfessioanlClientInformation = function (scope) {
        return _this.showInformation(scope, $translate.instant('professional-client.professional_client'), 'js/share/templates/professional-client/professional-client-information.template.html');
    };

    this.showPEPInformation = function (scope) {
        return _this.showInformation(scope, $translate.instant('pep-information.pep'), 'js/share/templates/pep-information/pep-information.template.html');
    };

    this.showTaxInformation = function (scope) {
        return _this.showInformation(scope, $translate.instant('what-is-tax-information.tax_information_title'), 'js/share/templates/tax-information/tax-information.template.html');
    };

    this.displayProfessionalClientConfirmation = function (_title, _class, scope, _template, _buttons) {
        var showPopup = $ionicPopup.show({
            title: _title,
            cssClass: _class,
            scope: scope,
            templateUrl: _template,
            buttons: _buttons
        });
        return showPopup;
    };
}]);
"use strict";

/**
 * @name analyticsService
 * @author Morteza Tavanarad
 * @contributors []
 * @since 07/17/2016
 * @copyright Binary Ltd
 * Send information to all analytics services
 */

angular.module("binary").factory("analyticsService", ["accountService", function (accountService) {
    var factory = {};
    factory.google = {
        addUser: function addUser() {
            var user = accountService.getDefault();
            var userId = user && user.id ? user.id : null;
            window.ga.setUserId(userId);
        },
        trackView: function trackView(_view) {
            if (typeof ga !== "undefined") {
                this.addUser();
                ga.trackView(_view);
            }
        },
        trackEvent: function trackEvent(market, contractType, symbole, payout) {
            if (typeof ga !== "undefined") {
                this.addUser();
                ga.trackEvent(market, contractType, symbole, payout);
            }
        }
    };

    return factory;
}]);
"use strict";

/**
 * @name appStateService
 * @author Morteza Tavanarad
 * @contributors []
 * @since 05/02/2016
 * @copyright Binary Ltd
 * Keeping state of the app in this factory
 */

angular.module("binary").factory("appStateService", function () {
    var factory = {};
    factory.tradeMode = true;
    factory.purchaseMode = false;
    factory.isLoggedin = false;
    factory.scopes = [];
    factory.isChangedAccount = false;
    factory.isRealityChecked = false;
    factory.isPopupOpen = false;
    factory.isProfitTableSet = false;
    factory.profitTableRefresh = false;
    factory.isStatementSet = false;
    factory.statementRefresh = false;
    factory.virtuality = 0;
    factory.newAccountAdded = false;
    factory.isLanguageReady = false;
    factory.passwordChanged = false;
    factory.limitsChange = false;
    factory.realityCheckLogin = false;
    factory.hasAuthenticateMessage = false;
    factory.hasRestrictedMessage = false;
    factory.hasMaxTurnoverMessage = false;
    factory.hasCountryMessage = false;
    factory.hasTnCMessage = false;
    factory.hasTaxInfoMessage = false;
    factory.hasFinancialAssessmentMessage = false;
    factory.hasAgeVerificationMessage = false;
    factory.hasCurrencyMessage = false;
    factory.checkedAccountStatus = false;
    factory.siteStatus = "up";
    factory.modalIsOpen = false;
    factory.currenciesConfig = {};
    factory.balanceSubscribtionId = null;
    factory.accountCurrencyChanged = false;
    factory.selectedCurrency = false;
    factory.upgrade = {};
    factory.redirectedFromAccountsManagemenet = false;
    factory.checkingUpgradeDone = false;
    factory.upgradeableLandingCompanies = [];
    factory.loginFinished = false;
    factory.isMaltainvest = false;

    return factory;
});
"use strict";

/**
 * @name appVersionService
 * @author Morteza Tavanarad
 * @contributors []
 * @since 01/20/2016
 * @copyright Binary Ltd
 */

angular.module("binary").factory("appVersionService", ["$http", function ($http) {
    var appVersion = {};

    function getAppVersion() {
        return $http.get("js/config.json");
    }

    appVersion.getAppVersion = getAppVersion;

    return appVersion;
}]);
"use strict";

/**
 * @name chartService
 * @author Amin Marashi
 * @contributors []
 * @since 11/25/2015
 * @copyright Binary Ltd
 */

angular.module("binary").factory("chartService", ["$rootScope", function ($rootScope) {
    var localHistory = void 0;
    var chartDrawer = void 0;
    var contractCtrls = [];

    /* Define ChartJS Options */
    var reversedIndex = function reversedIndex(i) {
        return chartGlobals.tickCount - 1 - i;
    };

    var distribute = function distribute(i) {
        var distance = Math.ceil(chartGlobals.tickCount / chartGlobals.minTickCount);
        if (reversedIndex(i) % distance === 0) {
            return true;
        }
        return false;
    };

    var chartGlobals = void 0;
    var setChartGlobals = function setChartGlobals() {
        chartGlobals = {
            chartJS: null,
            capacity: 600,
            maxTickCount: 50,
            hideLabelsThreshold: 15,
            tickCount: 15,
            minTickCount: 5,
            chartData: {
                labels: [],
                labelsFilter: function labelsFilter(index) {
                    return !distribute(index);
                },

                datasets: [{
                    strokeColor: "#7cb5ec",
                    pointColor: "#7cb5ec",
                    pointStrokeColor: "#7cb5ec",
                    data: []
                }]
            },
            chartOptions: {
                animation: false,
                bezierCurve: false,
                datasetFill: false,
                showTooltips: false,
                keepAspectRatio: false,
                scaleShowLabels: false,
                scaleFontSize: 10,
                pointDotRadius: 3, // original 4
                datasetStrokeWidth: 2 // original 2
            }
        };
    };
    setChartGlobals();
    /* End of Define ChartJS Options */

    var utils = {
        zeroPad: function zeroPad(num) {
            if (num < 10) {
                return "0" + num;
            }
            return num.toString();
        },
        getTickTime: function getTickTime(tick) {
            var date = new Date(tick * 1000);
            return date.getUTCHours() + ":" + utils.zeroPad(date.getUTCMinutes()) + ":" + utils.zeroPad(date.getUTCSeconds());
        },
        isDefined: function isDefined(obj) {
            if (typeof obj === "undefined" || obj === null) {
                return false;
            }
            return true;
        },
        setObjValue: function setObjValue(obj, attr, value, condition) {
            if (utils.isDefined(obj)) {
                if (utils.isDefined(condition)) {
                    if (condition) {
                        obj[attr] = value;
                    }
                } else if (typeof obj[attr] === "undefined") {
                    obj[attr] = value;
                }
            }
        },
        fractionalLength: function fractionalLength(floatNumber) {
            var stringNumber = floatNumber.toString();
            var decimalLength = stringNumber.indexOf(".");
            return stringNumber.length - decimalLength - 1;
        },
        maxFractionalLength: function maxFractionalLength(floatNumbers) {
            var max = 0;
            floatNumbers.forEach(function (number) {
                max = max < utils.fractionalLength(number) ? utils.fractionalLength(number) : max;
            });
            return max;
        },
        lastDigit: function lastDigit(num) {
            return parseInt(num.toString().slice(-1)[0]);
        },
        average: function average(list) {
            var decimalPointLength = utils.fractionalLength(list[0]) + 1;
            return parseFloat(list.reduce(function (a, b) {
                return a + b;
            }, 0) / list.length).toFixed(decimalPointLength);
        },
        conditions: {
            CALL: function condition(barrier, price) {
                return parseFloat(price) > parseFloat(barrier);
            },
            PUT: function condition(barrier, price) {
                return parseFloat(price) < parseFloat(barrier);
            },
            CALLHL: function condition(barrier, price) {
                // Higher/Lower CALL
                return parseFloat(price) > parseFloat(barrier);
            },
            PUTHL: function condition(barrier, price) {
                // Higher/Lower PUT
                return parseFloat(price) < parseFloat(barrier);
            },
            DIGITMATCH: function condition(barrier, price) {
                return utils.lastDigit(parseInt(barrier)) === utils.lastDigit(price);
            },
            DIGITDIFF: function condition(barrier, price) {
                return utils.lastDigit(parseInt(barrier)) !== utils.lastDigit(price);
            },
            DIGITEVEN: function condition(barrier, price) {
                return utils.lastDigit(price) % 2 === 0;
            },
            DIGITODD: function condition(barrier, price) {
                return utils.lastDigit(price) % 2 !== 0;
            },
            DIGITUNDER: function condition(barrier, price) {
                return utils.lastDigit(price) < parseInt(barrier);
            },
            DIGITOVER: function condition(barrier, price) {
                return utils.lastDigit(price) > parseInt(barrier);
            },
            ASIANU: function condition(barrier, price, priceList) {
                var avg = utils.average(priceList);

                return parseFloat(price) > avg;
            },
            ASIAND: function condition(barrier, price, priceList) {
                var avg = utils.average(priceList);

                return parseFloat(price) < avg;
            },
            TICKHIGH: function condition(barrier, price, priceList, selectedTick) {
                return priceList[selectedTick - 1] && !_.find(priceList, function (val) {
                    return val > priceList[selectedTick - 1];
                });
            },
            TICKLOW: function condition(barrier, price, priceList, selectedTick) {
                return priceList[selectedTick - 1] && !_.find(priceList, function (val) {
                    return val < priceList[selectedTick - 1];
                });
            }
        },
        digitTrade: function digitTrade(contract) {
            if (contract.type.indexOf("DIGIT") === 0) {
                return true;
            }
            return false;
        },
        asianGame: function asianGame(contract) {
            if (contract.type.indexOf("ASIAN") === 0) {
                return true;
            }
            return false;
        },
        higherLowerTrade: function higherLowerTrade(contract) {
            if (["PUTHL", "CALLHL"].indexOf(contract.type) > -1 && !_.isEmpty(contract.barrier)) {
                return true;
            }
            return false;
        },
        highLowTrade: function highLowTrade(contract) {
            if (["TICKLOW", "TICKHIGH"].indexOf(contract.type) > -1) {
                return true;
            }
            return false;
        },
        getRelativeIndex: function getRelativeIndex(absoluteIndex, dataIndex) {
            return absoluteIndex - (chartDrawer.getCapacity() - (chartDrawer.getTickCount() + chartDrawer.getDataIndex()));
        },
        getAbsoluteIndex: function getAbsoluteIndex(relativeIndex, dataIndex) {
            return relativeIndex + (chartDrawer.getCapacity() - (chartDrawer.getTickCount() + chartDrawer.getDataIndex()));
        }
    };

    var Stepper = function Stepper() {
        var tickDistance = 0;
        var startingPosition = 0;
        var startingDataIndex = 0;
        var started = false;
        var previousTime = 0;

        var setStartPosition = function setStartPosition(dataIndex, position) {
            startingPosition = position;
            startingDataIndex = dataIndex;
            started = true;
        };

        var stepCount = function stepCount(dataIndex, position) {
            if (!started) {
                return 0;
            }
            return startingDataIndex + Math.floor((position - startingPosition) / tickDistance) - dataIndex;
        };

        var setDistance = function setDistance(canvas, tickCount) {
            if (canvas !== null) {
                tickDistance = Math.ceil(canvas.offsetWidth / tickCount);
            }
        };

        var getDistance = function getDistance() {
            return tickDistance;
        };

        var isStep = function isStep(e, tickCount) {
            if (e.timeStamp - previousTime > 100) {
                previousTime = e.timeStamp;
                return true;
            }
            return false;
        };

        var stop = function stop() {
            started = false;
        };

        return {
            isStep: isStep,
            stop: stop,
            setDistance: setDistance,
            getDistance: getDistance,
            setStartPosition: setStartPosition,
            stepCount: stepCount
        };
    };

    var LocalHistory = function LocalHistory(capacity) {
        var historyData = [];

        var addTick = function addTick(tick) {
            var options = JSON.parse(localStorage.options);
            var pip = options.underlying.pip;
            var fractionalLength = utils.fractionalLength(pip);
            if (parseInt(tick.epoch) > parseInt(historyData.slice(-1)[0].time)) {
                historyData.push({
                    time: tick.epoch,
                    price: parseFloat(tick.quote).toFixed(fractionalLength)
                });
                historyData.shift();
            }
        };

        var updateHistoryArray = function updateHistoryArray(historyArray, history) {
            var times = history.times;
            var prices = history.prices;
            var compare = function compare(a, b) {
                var timea = parseInt(a.time);
                var timeb = parseInt(b.time);
                if (timea < timeb) {
                    return -1;
                } else if (timea > timeb) {
                    return 1;
                }
                return 0;
            };
            var seenTimes = [];
            times.forEach(function (time, index) {
                if (seenTimes.indexOf(time) < 0) {
                    seenTimes.push(time);
                    historyArray.push({
                        time: time,
                        price: prices[index]
                    });
                }
            });
            times.sort(compare);
        };

        var addHistory = function addHistory(history) {
            historyData = [];
            contractCtrls.forEach(function (contract) {
                contract.removeRegion();
            });
            contractCtrls = [];
            updateHistoryArray(historyData, history);
        };

        var getHistory = function getHistory(dataIndex, count, callback) {
            var end = capacity - dataIndex;
            var start = end - count;
            if (start >= 0) {
                callback(historyData.slice(start, end));
            } else {
                callback([]);
            }
        };

        return {
            getHistory: getHistory,
            addTick: addTick,
            addHistory: addHistory
        };
    };

    var ContractCtrl = function ContractCtrl(contract) {
        var broadcastable = true;
        var tickPriceList = [];

        var setNotBroadcastable = function setNotBroadcastable() {
            return broadcastable = false;
        };

        var getBroadcastable = function getBroadcastable() {
            return broadcastable;
        };

        var isFinished = function isFinished() {
            return utils.isDefined(contract.exitSpot);
        };

        var getContract = function getContract() {
            return contract;
        };

        var resetSpotShowing = function resetSpotShowing() {
            contract.showingEntrySpot = false;
            contract.showingExitSpot = false;
        };

        var hasEntrySpot = function hasEntrySpot() {
            if (utils.isDefined(contract.entrySpotIndex)) {
                return true;
            }
            return false;
        };

        var hasExitSpot = function hasExitSpot() {
            if (utils.isDefined(contract.exitSpotIndex)) {
                return true;
            }
            return false;
        };

        var betweenExistingSpots = function betweenExistingSpots(time) {
            if (hasEntrySpot() && time >= contract.entrySpotTime && (!hasExitSpot() || time <= contract.exitSpot)) {
                return true;
            }
            return false;
        };

        var isSpot = function isSpot(i) {
            if (contract.showingEntrySpot && contract.entrySpotIndex === utils.getAbsoluteIndex(i)) {
                return true;
            }
            if (contract.showingExitSpot && contract.exitSpotIndex === utils.getAbsoluteIndex(i)) {
                return true;
            }
            return false;
        };

        var getEntrySpotPoint = function getEntrySpotPoint(points) {
            var result = void 0;
            if (contract.showingEntrySpot) {
                result = points[utils.getRelativeIndex(contract.entrySpotIndex)];
            }
            return result;
        };

        var getExitSpotPoint = function getExitSpotPoint(points) {
            var result = void 0;
            if (contract.showingExitSpot) {
                result = points[utils.getRelativeIndex(contract.exitSpotIndex)];
            }
            return result;
        };

        var isEntrySpot = function isEntrySpot(time) {
            if (hasEntrySpot()) {
                if (time === contract.entrySpotTime) {
                    return true;
                }
                return false;
            }
            if (time >= contract.startTime) {
                return true;
            }
            return false;
        };

        var isExitSpot = function isExitSpot(time, index) {
            if (hasExitSpot()) {
                if (time === contract.exitSpot) {
                    return true;
                }
                return false;
            }
            if (hasEntrySpot() && index === contract.entrySpotIndex + contract.duration) {
                return true;
            }
            return false;
        };

        var viewSpots = function viewSpots(index, tickTime) {
            if (isEntrySpot(tickTime)) {
                contract.showingEntrySpot = true;
                if (!utils.digitTrade(contract) && !utils.asianGame(contract) && !hasExitSpot()) {
                    chartDrawer.addGridLine({
                        color: "#2E8836",
                        label: "barrier: " + contract.barrier,
                        orientation: "horizontal",
                        type: "barrier",
                        index: index
                    });
                } else if (utils.asianGame(contract) && tickPriceList.length > 0 && !hasExitSpot()) {
                    chartDrawer.addGridLine({
                        color: "#2E8836",
                        label: "Average: " + utils.average(tickPriceList),
                        orientation: "horizontal",
                        type: "average",
                        firstIndex: index,
                        index: index + (tickPriceList.length - 1)
                    });
                }
            }

            if (isExitSpot(tickTime, utils.getAbsoluteIndex(index))) {
                contract.showingExitSpot = true;
            }
        };

        var addSpots = function addSpots(index, tickTime, tickPrice) {
            if (isEntrySpot(tickTime) || betweenExistingSpots(tickTime)) {
                if (isEntrySpot(tickTime)) {
                    var barrier = tickPrice;
                    if (utils.higherLowerTrade(contract)) {
                        contract.offset = contract.offset || contract.barrier;
                        barrier = Number(tickPrice) + Number(contract.offset);
                        barrier = utils.digitTrade(contract) ? contract.barrier : barrier.toFixed(utils.fractionalLength(tickPrice));
                    }
                    utils.setObjValue(contract, "barrier", barrier, !utils.digitTrade(contract));
                    utils.setObjValue(contract, "entrySpotPrice", tickPrice, true);
                    utils.setObjValue(contract, "entrySpotTime", tickTime, !hasEntrySpot());
                    utils.setObjValue(contract, "entrySpotIndex", index, true);
                }

                if (isExitSpot(tickTime, index)) {
                    utils.setObjValue(contract, "exitSpot", tickTime, !hasExitSpot());
                    utils.setObjValue(contract, "exitSpotIndex", index, true);
                }

                // tickPriceList.push(tickPrice);
            }
        };

        var viewRegions = function viewRegions() {
            if (hasEntrySpot()) {
                var color = contract.result === "win" ? "rgba(0, 255, 0, 0.1)" : "rgba(255, 0, 0, 0.1)";
                if (contract.showingExitSpot) {
                    var start = utils.getRelativeIndex(contract.entrySpotIndex);
                    start = start < 0 ? 0 : start;
                    if (!utils.isDefined(contract.region)) {
                        contract.region = {
                            color: color,
                            start: start
                        };
                    } else {
                        contract.region.color = color;
                        contract.region.start = start;
                    }
                    contract.region.end = utils.getRelativeIndex(contract.exitSpotIndex);
                    chartDrawer.addRegion(contract.region);
                } else if (contract.showingEntrySpot) {
                    if (!utils.isDefined(contract.region)) {
                        contract.region = {
                            color: color,
                            start: utils.getRelativeIndex(contract.entrySpotIndex)
                        };
                    } else {
                        contract.region.color = color;
                        contract.region.start = utils.getRelativeIndex(contract.entrySpotIndex);
                    }
                    chartDrawer.addRegion(contract.region);
                } else {
                    chartDrawer.removeRegion(contract.region);
                }
            }
        };

        var addRegions = function addRegions(lastTime, lastPrice) {
            var options = JSON.parse(localStorage.options);
            var pip = options.underlying.pip;
            var fractionalLength = utils.fractionalLength(pip);

            if (hasEntrySpot() && broadcastable) {
                if (tickPriceList.length === 0) {
                    if (contract.entrySpotTime !== lastTime && betweenExistingSpots(lastTime)) {
                        var entrySpotPrice = parseFloat(contract.entrySpotPrice).toFixed(fractionalLength);
                        var barrier = utils.digitTrade(contract) ? contract.barrier : parseFloat(contract.barrier).toFixed(fractionalLength);
                        tickPriceList.push(entrySpotPrice);

                        if (utils.conditions[contract.type](barrier, entrySpotPrice, tickPriceList, contract.selectedTick)) {
                            contract.result = "win";
                        } else {
                            contract.result = "lose";
                        }
                        $rootScope.$broadcast("contract:spot", contract, entrySpotPrice);
                    } else {
                        tickPriceList.push(parseFloat(lastPrice).toFixed(fractionalLength));
                    }
                } else {
                    tickPriceList.push(parseFloat(lastPrice).toFixed(fractionalLength));
                }

                if (betweenExistingSpots(lastTime)) {
                    var _barrier = parseFloat(contract.barrier).toFixed(fractionalLength);
                    var lastPriceFloat = parseFloat(lastPrice).toFixed(fractionalLength);

                    if (utils.conditions[contract.type](_barrier, lastPriceFloat, tickPriceList, contract.selectedTick)) {
                        contract.result = "win";
                    } else {
                        contract.result = "lose";
                    }

                    $rootScope.$broadcast("contract:spot", contract, lastPriceFloat);

                    if (isFinished() && broadcastable) {
                        tickPriceList = [];
                        contractCtrls.forEach(function (contractctrl, index) {
                            var oldContract = contractctrl.getContract();
                            if (contract !== oldContract && !contractctrl.isFinished()) {
                                setNotBroadcastable();
                            }
                        });
                        if (broadcastable) {
                            $rootScope.$broadcast("contract:finished", contract);
                        }
                        setNotBroadcastable();
                    }
                }
            }
        };

        var removeRegion = function removeRegion() {
            chartDrawer.removeRegion(contract.region);
        };

        return {
            getBroadcastable: getBroadcastable,
            setNotBroadcastable: setNotBroadcastable,
            isFinished: isFinished,
            getContract: getContract,
            isSpot: isSpot,
            betweenExistingSpots: betweenExistingSpots,
            resetSpotShowing: resetSpotShowing,
            addSpots: addSpots,
            addRegions: addRegions,
            removeRegion: removeRegion,
            viewSpots: viewSpots,
            viewRegions: viewRegions,
            getEntrySpotPoint: getEntrySpotPoint,
            getExitSpotPoint: getExitSpotPoint
        };
    };

    var ChartDrawer = function ChartDrawer() {
        var dataIndex = 0;
        var canvas = void 0;
        var ctx = void 0;
        var dragging = false;
        var zooming = false;
        var stepper = Stepper();

        var isLastPoint = function isLastPoint(i) {
            if (reversedIndex(i) === 0) {
                return true;
            }
            return false;
        };

        var hideLabels = function hideLabels() {
            if (chartGlobals.tickCount >= chartGlobals.hideLabelsThreshold) {
                return true;
            }
            return false;
        };

        var showingHistory = function showingHistory() {
            if (dataIndex === 0) {
                return false;
            }
            return true;
        };

        var getLabelColor = function getLabelColor(index) {
            var color = "black";
            if (!showingHistory() && isLastPoint(index)) {
                color = "#2E8836";
            }
            contractCtrls.forEach(function (contract) {
                if (contract.isSpot(index)) {
                    color = "#818183";
                }
            });
            return color;
        };

        var getDotColor = function getDotColor(value, index) {
            var color = void 0;
            contractCtrls.forEach(function (contract) {
                if (contract.betweenExistingSpots(value)) {
                    color = "#7cb5ec";
                }
            });
            if (utils.isDefined(color)) {
                return color;
            }
            if (isLastPoint(index) && !showingHistory()) {
                color = "#2E8836";
            } else {
                color = "#7cb5ec";
            }
            return color;
        };

        var drawRegion = function drawRegion(thisChart, region) {
            var height = thisChart.scale.endPoint - thisChart.scale.startPoint + 12; // + 12 to size up the region to the top
            var end = void 0;

            var start = thisChart.datasets[0].points[region.start].x;
            if (utils.isDefined(region.end)) {
                end = thisChart.datasets[0].points[region.end].x;
            } else {
                end = thisChart.datasets[0].points.slice(-1)[0].x;
            }
            if (end < start) {
                return;
            } else if (end === start) {
                start -= 2; // subtract 2 from start to make the region visible when the duration is 1 tick
            }
            var length = end - start || 6; // set the region length to 6 whenever the duration is 1 tick
            ctx.fillStyle = region.color;
            ctx.fillRect(start, thisChart.scale.startPoint - 12, length, height); // begin the region from the top
        };

        var getLabelSize = function getLabelSize(ctx, point) {
            return {
                width: ctx.measureText(point.value).width,
                height: parseInt(ctx.font)
            };
        };

        var overlapping = function overlapping(point1, point2) {
            return point1.s < point2.e && point1.e > point2.s || point2.s < point1.e && point2.e > point1.s;
        };

        var overlapping2d = function overlapping2d(point1, point2) {
            var point1Size = getLabelSize(ctx, point1);
            var point2Size = getLabelSize(ctx, point2);
            var overlappingY = overlapping({
                s: point1.y,
                e: point1.y + point1Size.height
            }, {
                s: point2.y,
                e: point2.y + point2Size.height
            });
            var overlappingX = overlapping({
                s: point1.x,
                e: point1.x + point1Size.width
            }, {
                s: point2.x,
                e: point2.x + point2Size.width
            });
            return overlappingX && overlappingY;
        };

        var findSpots = function findSpots(points) {
            var entries = [];
            var exits = [];
            contractCtrls.forEach(function (contract) {
                var entry = contract.getEntrySpotPoint(points);
                var exit = contract.getExitSpotPoint(points);
                if (utils.isDefined(entry)) {
                    entries.push(entry);
                }
                if (utils.isDefined(exit)) {
                    exits.push(exit);
                }
            });
            return {
                entries: entries,
                exits: exits
            };
        };

        var withoutConflict = function withoutConflict(toShow, point) {
            var result = true;
            toShow.forEach(function (toShowPoint, index) {
                if (overlapping2d(toShowPoint, point)) {
                    result = false;
                }
            });
            return result;
        };

        var toShowLabels = function toShowLabels(points) {
            var toShow = [];
            var spots = findSpots(points);
            // This is our priority: 1. exit spot, 2. entry spot, 3. last value, 4. others (right to left)

            spots.exits.forEach(function (exit, index) {
                toShow.push(exit);
            });

            spots.entries.forEach(function (entry, index) {
                if (withoutConflict(toShow, entry)) {
                    toShow.push(entry);
                }
            });

            var lastPoint = points.slice(-1)[0];
            if (!showingHistory() && withoutConflict(toShow, lastPoint)) {
                toShow.push(lastPoint);
            }
            // add other labels from right to left
            if (!hideLabels()) {
                for (var i = points.length - 1; i >= 0; i--) {
                    if (withoutConflict(toShow, points[i])) {
                        toShow.push(points[i]);
                    }
                }
            }
            toShow.forEach(function (toShowPoint, index) {
                if (!_.isEmpty(toShowPoint)) {
                    toShowPoint.shown = true;
                }
            });
        };

        var drawLabel = function drawLabel(point, index) {
            if (index !== 0 && utils.isDefined(point.shown) && point.shown) {
                ctx.fillStyle = getLabelColor(index);
                ctx.textAlign = "center";
                ctx.textBaseline = "bottom";

                var padding = 0;
                var valueWidth = getLabelSize(ctx, point).width;
                if (isLastPoint(index)) {
                    padding = valueWidth < 45 ? 0 : valueWidth - 45;
                }
                ctx.fillText(point.value, point.x - padding, point.y - 1);
            }
        };

        var drawLastTickLabel = function drawLastTickLabel(point, index) {
            if (index !== 0 && utils.isDefined(point.shown) && point.shown) {
                var marginX = 10;
                var marginY = 30;
                var padding = 5;
                var fontSize = 12;
                ctx.font = ctx.font.replace(/\d+px/, fontSize + "px");
                var value = ctx.measureText(point.value);
                value.height = fontSize;
                ctx.textAlign = "center";
                ctx.textBaseline = "bottom";
                ctx.fillStyle = point.labelFillColor.toString();
                ctx.fillRect(canvas.offsetWidth - (marginX + padding + value.width), canvas.offsetHeight - (marginY + value.height + padding), 2 * padding + value.width, 2 * padding + value.height);
                if (ctx.fillStyle === "#C2C2C2") {
                    ctx.fillStyle = "#000";
                } else {
                    ctx.fillStyle = "#FFF";
                }
                ctx.fillText(point.value, canvas.offsetWidth - (marginX + value.width / 2), canvas.offsetHeight - marginY);
            }
        };

        var drawGridLine = function drawGridLine(thisChart, gridLine) {
            var point = thisChart.datasets[0].points[gridLine.index];
            var scale = thisChart.scale;

            ctx.beginPath();
            if (gridLine.orientation === "vertical") {
                ctx.moveTo(point.x, scale.startPoint + 24);
                ctx.strokeStyle = gridLine.color;
                ctx.fillStyle = gridLine.color;
                ctx.lineTo(point.x, scale.endPoint);
                ctx.stroke();

                ctx.textAlign = "center";
                ctx.fillText(gridLine.label, point.x, scale.startPoint + 12);
            } else if (gridLine.orientation === "horizontal") {
                var yPoint = point.y;
                if (gridLine.type === "average" && gridLine.index !== gridLine.firstIndex) {
                    var firstPoint = thisChart.datasets[0].points[gridLine.firstIndex];
                    yPoint = (firstPoint.y + point.y) / 2;
                }

                ctx.moveTo(scale.startPoint, yPoint);

                ctx.strokeStyle = gridLine.color;
                ctx.fillStyle = gridLine.color;
                ctx.lineTo(thisChart.chart.width, yPoint);
                ctx.stroke();

                ctx.textAlign = "center";
                var labelWidth = ctx.measureText(gridLine.label).width;
                ctx.fillText(gridLine.label, parseInt(labelWidth / 2) + 5, yPoint - 1);
            }
        };

        /* Override ChartJS Defaults */
        Chart.CustomScale = Chart.Scale.extend({
            initialize: function initialize() {
                var longestText = function longestText(ctx, font, arrayOfStrings) {
                    ctx.font = font;
                    var longest = 0;
                    Chart.helpers.each(arrayOfStrings, function (string) {
                        var textWidth = ctx.measureText(string).width;
                        longest = textWidth > longest ? textWidth : longest;
                    });
                    return longest;
                };

                this.calculateXLabelRotation = function () {
                    this.ctx.font = this.font;

                    var lastWidth = this.ctx.measureText(this.xLabels[this.xLabels.length - 1]).width;

                    this.xScalePaddingRight = lastWidth / 2 + 3;

                    this.xLabelRotation = 0;
                    if (this.display) {
                        var originalLabelWidth = longestText(this.ctx, this.font, this.xLabels);
                        this.xLabelWidth = originalLabelWidth;
                    } else {
                        this.xLabelWidth = 0;
                        this.xScalePaddingRight = this.padding;
                    }
                    this.xScalePaddingLeft = 0;
                };
                Chart.Scale.prototype.initialize.apply(this, arguments);
            },
            draw: function draw() {
                var helpers = Chart.helpers;
                var each = helpers.each;
                var aliasPixel = helpers.aliasPixel;
                var ctx = this.ctx;
                var yLabelGap = (this.endPoint - this.startPoint) / this.steps;
                var xStart = Math.round(this.xScalePaddingLeft);
                if (this.display) {
                    ctx.fillStyle = this.textColor;
                    ctx.font = this.font;
                    each(this.yLabels, function (labelString, index) {
                        var yLabelCenter = this.endPoint - yLabelGap * index;
                        var linePositionY = Math.round(yLabelCenter);

                        ctx.textAlign = "right";
                        ctx.textBaseline = "middle";
                        if (this.showLabels) {
                            ctx.fillText(labelString, xStart - 10, yLabelCenter);
                        }
                        ctx.beginPath();
                        if (index > 0) {
                            ctx.lineWidth = this.gridLineWidth;
                            ctx.strokeStyle = this.gridLineColor;
                        } else {
                            ctx.lineWidth = this.lineWidth;
                            ctx.strokeStyle = this.lineColor;
                        }

                        linePositionY += helpers.aliasPixel(ctx.lineWidth);

                        ctx.moveTo(xStart, linePositionY);
                        ctx.lineTo(this.width, linePositionY);
                        ctx.stroke();
                        ctx.closePath();

                        ctx.lineWidth = this.lineWidth;
                        ctx.strokeStyle = this.lineColor;
                        ctx.beginPath();
                        ctx.moveTo(xStart - 5, linePositionY);
                        ctx.lineTo(xStart, linePositionY);
                        ctx.stroke();
                        ctx.closePath();
                    }, this);

                    each(this.xLabels, function (label, index) {
                        var filtered = false;
                        if (typeof this.labelsFilter === "function" && this.labelsFilter(index)) {
                            filtered = true;
                        }
                        var xPos = this.calculateX(index) + aliasPixel(this.lineWidth);
                        var linePos = this.calculateX(index - (this.offsetGridLines ? 0.5 : 0)) + aliasPixel(this.lineWidth);

                        ctx.beginPath();

                        if (index > 0) {
                            ctx.lineWidth = this.gridLineWidth;
                            ctx.strokeStyle = this.gridLineColor;
                        } else {
                            ctx.lineWidth = this.lineWidth;
                            ctx.strokeStyle = this.lineColor;
                        }
                        ctx.moveTo(linePos, this.endPoint);
                        ctx.lineTo(linePos, this.startPoint - 12);
                        ctx.stroke();
                        ctx.closePath();

                        ctx.lineWidth = this.lineWidth;
                        ctx.strokeStyle = this.lineColor;

                        ctx.beginPath();
                        ctx.moveTo(linePos, this.endPoint);
                        if (filtered) {
                            ctx.lineTo(linePos, this.endPoint);
                        } else {
                            ctx.lineTo(linePos, this.endPoint + 5);
                        }
                        ctx.stroke();
                        ctx.closePath();

                        ctx.save();
                        ctx.translate(xPos, this.endPoint + 8);

                        ctx.textAlign = "center";
                        ctx.textBaseline = "top";
                        if (!filtered) {
                            ctx.fillText(label, 0, 0);
                        }
                        ctx.restore();
                    }, this);
                }
            }
        });

        Chart.types.Line.extend({
            name: "LineChartSpots",
            initialize: function initialize(data) {
                this.options.labelsFilter = data.labelsFilter || null;
                Chart.types.Line.prototype.initialize.apply(this, arguments);
            },
            draw: function draw() {
                var dataset = this.datasets[0];
                var thisChart = this;

                dataset.points.forEach(function (point, index) {
                    point.fillColor = getDotColor(chartGlobals.chartData.epochLabels[index], index);
                });

                Chart.types.Line.prototype.draw.apply(this, arguments);
                toShowLabels(dataset.points);
                dataset.points.forEach(function (point, index) {
                    drawLabel(point, index);
                });

                if (utils.isDefined(this.options.regions)) {
                    this.options.regions.forEach(function (region) {
                        drawRegion(thisChart, region);
                    });
                }

                if (utils.isDefined(this.options.gridLines)) {
                    this.options.gridLines.forEach(function (gridLine) {
                        drawGridLine(thisChart, gridLine);
                    });
                }
            },
            buildScale: function buildScale(labels) {
                var helpers = Chart.helpers;
                var self = this;

                var dataTotal = function dataTotal() {
                    var values = [];
                    self.eachPoints(function (point) {
                        values.push(point.value);
                    });
                    return values;
                };
                var scaleOptions = {
                    templateString: this.options.scaleLabel,
                    height: this.chart.height,
                    width: this.chart.width,
                    ctx: this.chart.ctx,
                    textColor: this.options.scaleFontColor,
                    fontSize: this.options.scaleFontSize,
                    labelsFilter: this.options.labelsFilter,
                    fontStyle: this.options.scaleFontStyle,
                    fontFamily: this.options.scaleFontFamily,
                    valuesCount: labels.length,
                    beginAtZero: this.options.scaleBeginAtZero,
                    integersOnly: this.options.scaleIntegersOnly,
                    calculateYRange: function calculateYRange(currentHeight) {
                        var updatedRanges = helpers.calculateScaleRange(dataTotal(), currentHeight, this.fontSize, this.beginAtZero, this.integersOnly);
                        helpers.extend(this, updatedRanges);
                    },

                    xLabels: labels,
                    font: helpers.fontString(this.options.scaleFontSize, this.options.scaleFontStyle, this.options.scaleFontFamily),
                    lineWidth: this.options.scaleLineWidth,
                    lineColor: this.options.scaleLineColor,
                    gridLineWidth: this.options.scaleShowGridLines ? this.options.scaleGridLineWidth : 0,
                    gridLineColor: this.options.scaleShowGridLines ? this.options.scaleGridLineColor : "rgba(0,0,0,0)",
                    padding: this.options.showScale ? 0 : this.options.pointDotRadius + this.options.pointDotStrokeWidth,
                    showLabels: this.options.scaleShowLabels,
                    display: this.options.showScale
                };

                if (this.options.scaleOverride) {
                    helpers.extend(scaleOptions, {
                        calculateYRange: helpers.noop,
                        steps: this.options.scaleSteps,
                        stepValue: this.options.scaleStepWidth,
                        min: this.options.scaleStartValue,
                        max: this.options.scaleStartValue + this.options.scaleSteps * this.options.scaleStepWidth
                    });
                }

                this.scale = new Chart.CustomScale(scaleOptions);
            }
        });
        /* End of Override ChartJS Defaults */

        var destroy = function destroy() {
            if (chartGlobals.chartJS) {
                chartGlobals.chartJS.destroy();
                setChartGlobals();
                canvas = null;
                ctx = null;
                dataIndex = 0;
                dragging = false;
                zooming = false;
                stepper = null;
            }
        };

        var drawChart = function drawChart(chartID) {
            canvas = document.getElementById(chartID);
            if (canvas !== null) {
                ctx = canvas.getContext("2d");
                stepper = Stepper();
                stepper.setDistance(canvas, chartGlobals.tickCount);
            }
        };

        var findRegion = function findRegion(region) {
            if (utils.isDefined(chartGlobals.chartOptions.regions)) {
                return chartGlobals.chartOptions.regions.indexOf(region);
            }
            return -1;
        };

        var addRegion = function addRegion(region) {
            if (!utils.isDefined(chartGlobals.chartOptions.regions)) {
                chartGlobals.chartOptions.regions = [];
            }
            if (findRegion(region) < 0) {
                chartGlobals.chartOptions.regions.push(region);
            }
        };

        var removeRegion = function removeRegion(region) {
            var regionIndex = findRegion(region);
            if (regionIndex >= 0) {
                chartGlobals.chartOptions.regions.splice(regionIndex, 1);
            }
        };

        var dragStart = function dragStart(e) {
            if (!_.isEmpty(stepper)) {
                stepper.setStartPosition(dataIndex, e.center.x);
                dragging = true;
            }
        };

        var dragEnd = function dragEnd(e) {
            if (!_.isEmpty(stepper)) {
                if (!zooming) {
                    move(stepper.stepCount(dataIndex, e.center.x));
                }
                stepper.stop();
                dragging = false;
            }
        };

        var zoomStart = function zoomStart() {
            zooming = true;
        };

        var zoomEnd = function zoomEnd() {
            zooming = false;
        };

        var addGridLine = function addGridLine(gridLine) {
            if (!utils.isDefined(chartGlobals.chartOptions.gridLines)) {
                chartGlobals.chartOptions.gridLines = [];
            }
            chartGlobals.chartOptions.gridLines.push(gridLine);
        };

        var updateChartPoints = function updateChartPoints(times, values) {
            chartGlobals.chartData.labels = [];
            chartGlobals.chartData.epochLabels = times;
            times.forEach(function (time, index) {
                chartGlobals.chartData.labels.push(utils.getTickTime(time));
            });

            chartGlobals.chartData.datasets[0].data = values;
            if (utils.isDefined(chartGlobals.chartJS)) {
                chartGlobals.chartJS.destroy();
            }
            if (utils.isDefined(ctx)) {
                var chartObj = new Chart(ctx);
                chartGlobals.chartJS = chartObj.LineChartSpots(chartGlobals.chartData, chartGlobals.chartOptions);
            }
        };

        // depends on updateContracts call
        var updateChart = function updateChart(ticks) {
            chartGlobals.chartOptions.gridLines = [];
            contractCtrls.forEach(function (contract) {
                contract.resetSpotShowing();
            });
            var times = [];
            var prices = [];

            ticks.forEach(function (tick, index) {
                var tickTime = parseInt(tick.time);
                contractCtrls.forEach(function (contract) {
                    contract.viewSpots(index, tickTime);
                });
                times.push(tickTime);
                prices.push(tick.price);
            });

            contractCtrls.forEach(function (contract) {
                contract.viewRegions();
            });

            updateChartPoints(times, prices);
        };

        var updateContracts = function updateContracts(ticks) {
            var lastTime = void 0;
            var lastPrice = void 0;

            ticks.forEach(function (tick, index) {
                var tickTime = parseInt(tick.time);
                var tickPrice = tick.price;
                contractCtrls.forEach(function (contract) {
                    contract.addSpots(index, tickTime, tickPrice);
                });
                lastTime = parseInt(tick.time);
                lastPrice = tick.price;
            });

            contractCtrls.forEach(function (contract) {
                contract.addRegions(lastTime, lastPrice);
            });
        };

        var addTick = function addTick(tick) {
            if (utils.isDefined(localHistory)) {
                localHistory.addTick(tick);
                localHistory.getHistory(0, chartGlobals.capacity, updateContracts);
                if (dataIndex === 0 && !dragging && !zooming) {
                    localHistory.getHistory(dataIndex, chartGlobals.tickCount, updateChart);
                } else {
                    move(1, false);
                }
            }
        };

        var addHistory = function addHistory(history) {
            if (!utils.isDefined(localHistory)) {
                localHistory = LocalHistory(chartGlobals.capacity);
            }
            localHistory.addHistory(history);
            localHistory.getHistory(0, chartGlobals.capacity, updateContracts);
            localHistory.getHistory(dataIndex, chartGlobals.tickCount, updateChart);
        };

        var addCandles = function addCandles(candles) {};

        var addOhlc = function addOhlc(ohlc) {};

        var zoom = function zoom(direction) {
            var newTickCount = void 0;
            var condition = void 0;
            if (direction === "in") {
                newTickCount = parseInt(chartGlobals.tickCount / 1.2);
                condition = newTickCount > chartGlobals.minTickCount;
            } else if (direction === "out") {
                newTickCount = parseInt(chartGlobals.tickCount * 1.2);
                condition = newTickCount < chartGlobals.maxTickCount;
            } else {
                return;
            }
            if (condition) {
                chartGlobals.tickCount = newTickCount;
                localHistory.getHistory(dataIndex, chartGlobals.tickCount, updateChart);
                stepper.setDistance(canvas, chartGlobals.tickCount);
            }
        };

        var zoomOut = function zoomOut() {
            zoom("out");
        };

        var zoomIn = function zoomIn() {
            zoom("in");
        };

        var move = function move(steps, update) {
            if (steps === 0) {
                return;
            }
            var testDataIndex = dataIndex + steps;
            if (testDataIndex < 0) {
                // overflow
                testDataIndex = 0;
            } else if (testDataIndex >= chartGlobals.capacity - chartGlobals.tickCount) {
                // underflow
                testDataIndex = chartGlobals.capacity - chartGlobals.tickCount - 1;
            }
            if (testDataIndex !== dataIndex) {
                dataIndex = testDataIndex;
                if (!utils.isDefined(update) || update) {
                    localHistory.getHistory(dataIndex, chartGlobals.tickCount, updateChart);
                }
            }
        };

        var drag = function drag(e) {
            if (!_.isEmpty(stepper)) {
                if (!zooming && stepper.isStep(e, chartGlobals.tickCount)) {
                    move(stepper.stepCount(dataIndex, e.center.x));
                }
            }
        };

        var getCapacity = function getCapacity() {
            return chartGlobals.capacity;
        };

        var getTickCount = function getTickCount() {
            return chartGlobals.tickCount;
        };

        var getDataIndex = function getDataIndex() {
            return dataIndex;
        };

        var addContract = function addContract(_contract) {
            if (_contract) {
                if (utils.digitTrade(_contract) || utils.asianGame(_contract) || utils.highLowTrade(_contract)) {
                    _contract.duration -= 1;
                }
                contractCtrls.push(ContractCtrl(_contract));
                dataIndex = 0;
            }
        };

        var historyInterface = {
            addTick: addTick,
            addHistory: addHistory,
            addCandles: addCandles,
            addOhlc: addOhlc
        };

        return {
            dragStart: dragStart,
            dragEnd: dragEnd,
            zoomIn: zoomIn,
            zoomOut: zoomOut,
            zoomStart: zoomStart,
            zoomEnd: zoomEnd,
            dragRight: drag,
            dragLeft: drag,
            getCapacity: getCapacity,
            getTickCount: getTickCount,
            getDataIndex: getDataIndex,
            addContract: addContract,
            historyInterface: historyInterface,
            addGridLine: addGridLine,
            addRegion: addRegion,
            removeRegion: removeRegion,
            drawChart: drawChart,
            destroy: destroy
        };
    };

    var drawChart = function drawChart(chartID) {
        chartDrawer.drawChart(chartID);
    };

    var destroy = function destroy() {
        chartDrawer.destroy();
        contractCtrls.forEach(function (contractctrl, index) {
            contractctrl.setNotBroadcastable();
        });
        localHistory = null;
    };

    chartDrawer = ChartDrawer();

    return {
        destroy: destroy,
        drawChart: drawChart,
        dragStart: chartDrawer.dragStart,
        dragEnd: chartDrawer.dragEnd,
        zoomIn: chartDrawer.zoomIn,
        zoomOut: chartDrawer.zoomOut,
        zoomStart: chartDrawer.zoomStart,
        zoomEnd: chartDrawer.zoomEnd,
        dragRight: chartDrawer.dragRight,
        dragLeft: chartDrawer.dragLeft,
        getCapacity: chartDrawer.getCapacity,
        addContract: chartDrawer.addContract,
        historyInterface: chartDrawer.historyInterface
    };
}]);
"use strict";

/**
 * @name cleanupService
 * @author Morteza Tavanarad
 * @contributors []
 * @since 12/22/2015
 * @copyright Binary Ltd
 *
 */

angular.module("binary").service("cleanupService", ["$translate", "proposalService", function ($translate, proposalService) {
    this.run = function () {
        proposalService.forget();
    };
}]);
"use strict";

/**
 * @name client service
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 10/26/2017
 * @copyright Binary Ltd
 */

angular.module("binary").service("clientService", ["appStateService", function (appStateService) {
    var _this = this;

    this.isLandingCompanyOf = function (targetLandingCompany, accountLandingCompany) {
        return targetLandingCompany === accountLandingCompany;
    };

    this.hasAccountOfLandingCompany = function (accounts, landingCompany) {
        return !!_.find(accounts, function (account) {
            return _this.isLandingCompanyOf(landingCompany, account.landing_company_name);
        });
    };

    this.getAccountType = function (landingCompany) {
        var account_type = void 0;
        if (landingCompany) {
            if (_this.isLandingCompanyOf('virtual', landingCompany)) account_type = 'virtual';else if (_this.isLandingCompanyOf('maltainvest', landingCompany)) account_type = 'financial';else if (_this.isLandingCompanyOf('malta', landingCompany)) account_type = 'gaming';else account_type = 'real';
        }
        return account_type;
    };

    this.isAccountOfType = function (type, landingCompany) {
        var accountType = _this.getAccountType(landingCompany);
        return type === 'virtual' && accountType === 'virtual' || type === 'real' && accountType !== 'virtual' || type === accountType;
    };

    this.landingCompanyValue = function (landingCompany, key, landingCompanyObj) {
        var landingCompanyOfAccount = void 0;
        var landingCompanyObject = landingCompanyObj || JSON.parse(localStorage.getItem('landingCompanyObject'));
        if (_this.isAccountOfType('financial', landingCompany)) {
            landingCompanyOfAccount = landingCompanyObject.financial_company;
        } else if (_this.isAccountOfType('real', landingCompany)) {
            landingCompanyOfAccount = landingCompanyObject.gaming_company;
            if (!landingCompanyOfAccount) {
                landingCompanyOfAccount = landingCompanyObject.financial_company;
            }
        } else {
            var financialCompany = (landingCompanyObject.financial_company || {})[key] || [];
            var gamingCompany = (landingCompanyObject.gaming_company || {})[key] || [];
            landingCompanyOfAccount = financialCompany.concat(gamingCompany);
            return landingCompanyOfAccount;
        }
        return (landingCompanyOfAccount || {})[key];
    };

    // ignore virtual account currency in existing currencies
    this.getExistingCurrencies = function (accounts) {
        var currencies = [];
        _.forIn(accounts, function (account, key) {
            if (!_this.isLandingCompanyOf('virtual', account.landing_company_name) && account.currency.length > 0) {
                currencies.push(account.currency);
            }
        });
        return currencies;
    };

    this.dividedCurrencies = function (currencies) {
        var currencyConfig = appStateService.currenciesConfig;
        var cryptoCurrencies = [];
        var fiatCurrencies = [];
        _.forEach(currencies, function (currency) {
            var isCryptoCurrency = /crypto/i.test(currencyConfig[currency].type);
            if (isCryptoCurrency) {
                cryptoCurrencies.push(currency);
            } else {
                fiatCurrencies.push(currency);
            }
        });
        return {
            cryptoCurrencies: cryptoCurrencies,
            fiatCurrencies: fiatCurrencies
        };
    };

    this.getFractionalDigits = function () {
        var currency = sessionStorage.getItem('currency') || 'USD';
        var currencyConfig = appStateService.currenciesConfig || {};
        return !_.isEmpty(currencyConfig) && currencyConfig[currency] ? currencyConfig[currency].fractional_digits : 2;
    };

    this.groupMT5Accounts = function (accounts) {
        var groupedAccounts = {};
        var demo = [];
        var real = [];
        _.forEach(accounts, function (account) {
            return account.isDemo ? demo.push(account) : real.push(account);
        });
        if (demo.length) {
            groupedAccounts.demo = demo;
        }
        if (real.length) {
            groupedAccounts.real = real;
        }
        return groupedAccounts;
    };
}]);
"use strict";

/**
 * @name delayService
 * @author Amin Marashi
 * @contributors []
 * @since 01/21/2016
 * @copyright Binary Ltd
 *
 */

angular.module("binary").factory("delayService", function () {
    var functions = {};
    var runTimestamps = {};
    var FunctionController = function FunctionController(delayedFunction, args, name) {
        var timeoutId = 0;
        return {
            run: function run(minimumDelay) {
                var runFunc = function runFunc() {
                    runTimestamps[name] = new Date().getTime();
                    delayedFunction.apply(this, args);
                };

                if (minimumDelay !== 0) {
                    timeoutId = setTimeout(function () {
                        runFunc();
                    }, minimumDelay);
                } else {
                    runFunc();
                }
            },
            cancel: function cancel() {
                clearTimeout(timeoutId);
            }
        };
    };
    return {
        update: function update(name, delayedFunction, minimumDelay, args) {
            var now = new Date().getTime();
            if (functions.hasOwnProperty(name)) {
                var remainingTime = minimumDelay - (now - runTimestamps[name]);
                if (remainingTime > 0) {
                    minimumDelay = remainingTime;
                } else {
                    minimumDelay = 0;
                }
                functions[name].cancel();
            } else {
                minimumDelay = 0;
                runTimestamps[name] = now;
            }
            functions[name] = FunctionController(delayedFunction, args, name);
            functions[name].run(minimumDelay);
        },
        remove: function remove(name) {
            if (functions.hasOwnProperty(name)) {
                functions[name].cancel();
                delete functions[name];
                delete runTimestamps[name];
            }
        }
    };
});
"use strict";

/**
 * @name languageService
 * @author Massih Hazrati
 * @contributors []
 * @since 10/26/2015
 * @copyright Binary Ltd
 *
 */

angular.module("binary").service("languageService", ["$rootScope", "$translate", "cleanupService", function ($rootScope, $translate, cleanupService) {
    /**
    * Update default language in local storage
    * Changes the app language
    * @param  {String} _language [description]
    */
    this.update = function (_language) {
        localStorage.language = _language;
        this.set(_language);
    };

    /**
    * Read the language from local storage
    * if exists update the app's language
    */
    this.set = function (_language) {
        var language = localStorage.language || "en";

        if (_language) {
            language = _language;
        }
        cleanupService.run();
        $rootScope.$broadcast("language:updated");
        $translate.use(language);
    };

    this.read = function () {
        var language = localStorage.language;
        return language || "en";
    };

    this.remove = function () {
        localStorage.removeItem("language");
        cleanupService.run();
    };

    var languageConfigs = {
        en: {
            nativeName: 'English'
        },
        de: {
            nativeName: 'Deutsch'
        },
        es: {
            nativeName: 'Español'
        },
        fr: {
            nativeName: 'Français'
        },
        id: {
            nativeName: 'Indonesia'
        },
        it: {
            nativeName: 'Italiano'
        },
        ja: {
            nativeName: '日本語'
        },
        pl: {
            nativeName: 'Polish'
        },
        pt: {
            nativeName: 'Português'
        },
        ru: {
            nativeName: 'Русский'
        },
        th: {
            nativeName: 'Thai'
        },
        vi: {
            nativeName: 'Tiếng Việt'
        },
        zh_cn: {
            nativeName: '简体中文'
        },
        zh_tw: {
            nativeName: '繁體中文'
        }
    };

    var getLanguageNativeName = function getLanguageNativeName(key) {
        var lang = languageConfigs[key];
        return lang ? lang.nativeName : undefined;
    };
    this.getLanguageNativeName = getLanguageNativeName;
}]);
"use strict";

/**
 * @name cleanupService
 * @author Morteza Tavanarad
 * @contributors []
 * @since 12/31/2015
 * @copyright Binary Ltd
 *
 */

angular.module("binary").factory("localStorageService", ["$state", "appStateService", function ($state, appStateService) {
    var service = {};

    /**
    * find a {key,value} in an array of objects and return its index
    * returns -1 if not found
    * @param  {Array of Objects} _accounts
    * @param  {String} _key
    * @param  {String, Number, Boolean} _value
    * @return {Number} Index of the found array element
    */
    var findIndex = function findIndex(_accounts, _key, _value) {
        var index = -1;
        _accounts.forEach(function (el, i) {
            if (_accounts[i][_key] === _value) {
                index = i;
            }
        });
        return index;
    };

    service.removeToken = function removeToken(token) {
        if (localStorage.hasOwnProperty("accounts")) {
            var accounts = JSON.parse(localStorage.accounts);
            var tokenIndex = findIndex(accounts, "token", token);
            if (tokenIndex > -1) {
                accounts.splice(tokenIndex);
                localStorage.accounts = JSON.stringify(accounts);
            }
        }
    };

    service.getDefaultToken = function () {
        if (localStorage.accounts && JSON.parse(localStorage.accounts) instanceof Array) {
            var accounts = JSON.parse(localStorage.accounts);
            var index = findIndex(accounts, "is_default", true);
            if (index > -1) {
                return accounts[index].token;
            }
        }
        return null;
    };

    return service;
}]);
"use strict";

/**
 * @name tradeService
 * @author Massih Hazrati
 * @contributors []
 * @since 10/15/2015
 * @copyright Binary Ltd
 * Handles websocket functionalities
 */

angular.module("binary").service("marketService", ["websocketService", "proposalService", "config", function (websocketService, proposalService, config) {
    var regroup = function regroup(symbols) {
        var groups = {
            index: ["R_100", "R_25", "R_50", "R_75"],
            BEARBULL: ["RDBEAR", "RDBULL"],
            MOONSUN: ["RDMOON", "RDSUN"],
            MARSVENUS: ["RDMARS", "RDVENUS"],
            YANGYIN: ["RDYANG", "RDYIN"]
        };

        var result = [];
        var itemIndices = [];
        Object.keys(groups).forEach(function (key) {
            var tmp = [];
            var first = -1;
            symbols.forEach(function (item, index) {
                if (item.symbol === groups[key][0]) {
                    first = index;
                }
            });
            if (first >= 0) {
                groups[key].forEach(function (item, index) {
                    var itemIndex = -1;
                    symbols.forEach(function (item, i) {
                        if (item.symbol === groups[key][index]) {
                            itemIndex = i;
                        }
                    });
                    if (itemIndex >= 0) {
                        tmp.push(symbols[itemIndex]);
                        itemIndices.push(itemIndex);
                    }
                });
                tmp.sort();
                result = result.concat(tmp);
            }
        });
        symbols.forEach(function (symbol, index) {
            if (itemIndices.indexOf(index) < 0) {
                result.push(symbol);
            }
        });
        return result;
    };

    var reorder = function reorder(symbols) {
        symbols.sort(function (a, b) {
            if (a.display_name > b.display_name) {
                return 1;
            } else if (a.display_name < b.display_name) {
                return -1;
            }
            return 0;
        });
        symbols = regroup(symbols);
        return symbols;
    };

    this.fixOrder = function () {
        if (!sessionStorage.active_symbols || sessionStorage.active_symbols === "null") {
            return;
        }

        var symbols = JSON.parse(sessionStorage.active_symbols);
        Object.keys(symbols).forEach(function (key) {
            symbols[key] = reorder(symbols[key]);
        });
        sessionStorage.active_symbols = JSON.stringify(symbols);
    };

    this.getActiveMarkets = function () {
        if (!sessionStorage.active_symbols || sessionStorage.active_symbols === "null") {
            return [];
        }

        var data = JSON.parse(sessionStorage.active_symbols);
        if (data) {
            return Object.keys(data);
        }

        console.log(data); // eslint-disable-line
        return [];
    };

    // TODO Remove getAllSymbolsForAMarket: This function is not used anymore
    this.getAllSymbolsForAMarket = function (_market) {
        if (!_market || !sessionStorage.active_symbols || !sessionStorage.asset_index) {
            return [];
        }

        var activeSymbols = JSON.parse(sessionStorage.active_symbols)[_market];
        var assetIndex = JSON.parse(sessionStorage.asset_index);
        var indexes = config.assetIndexes;
        var result = [];

        activeSymbols.forEach(function (market) {
            for (var i = 0; i < assetIndex.length; i++) {
                if (market.symbol === assetIndex[i][indexes.symbol]) {
                    var assetContracts = assetIndex[i][indexes.contracts];
                    for (var c = 0; c < assetContracts.length; c++) {
                        if (assetContracts[c][indexes.contractFrom].indexOf("t") !== -1) {
                            market.display_name = assetIndex[i][indexes.displayName];
                            result.push(market);
                            break;
                        }
                    }
                    break; // do not loop through remained assets, since the related asset_index has been found but is not supporting ticks
                }
            }
            // assetIndex.splice(i, 1); // to shorten the list for the next loop
        });

        return result;
    };

    this.getSymbolDetails = function (_symbol) {
        websocketService.sendRequestFor.contractsForSymbol(_symbol);
    };

    this.getDefault = {
        /**
        * Return the default/selected market
        * @return {String} Market Name
        */
        market: function market(_market) {
            var proposal = proposalService.get();
            if (proposal && proposal.passthrough && proposal.passthrough.market && _market[proposal.passthrough.market]) {
                return proposal.passthrough.market;
            }

            // return _market.random ? 'random' : 'forex';
            return _.findKey(_market, function (o) {
                return o;
            });
        },

        /**
        * Return the default/selected symbol
        * @return {String} Symbol Name
        */
        symbol: function symbol(_market, _symbols) {
            var proposal = proposalService.get();
            if (proposal && proposal.passthrough && proposal.passthrough.market && proposal.symbol && proposal.passthrough.market === _market) {
                return proposal.symbol;
            }
            return _symbols[0].symbol;
        },
        tradeType: function tradeType(_tradeTypes) {
            if (_.isEmpty(_tradeTypes)) {
                return null;
            }

            var proposal = proposalService.get();
            var contractType = proposal.contract_type;
            var selectedTradeType = _tradeTypes[0].value;
            _tradeTypes.forEach(function (el, i) {
                if (el.value === contractType) {
                    selectedTradeType = contractType;
                }
            });
            return selectedTradeType;
        },
        tick: function tick() {
            var proposal = proposalService.get();
            return proposal.duration ? proposal.duration : 5;
        },
        digit: function digit() {
            var proposal = proposalService.get();
            return proposal.barrier ? proposal.barrier : 0;
        },
        basis: function basis() {
            var proposal = proposalService.get();
            return proposal.basis ? proposal.basis : "payout";
        },
        amount: function amount() {
            var proposal = proposalService.get();
            if (!isNaN(proposal.amount)) {
                return proposal.amount;
            }
            return 5;
        }
    };

    this.getTradeTypes = function (_symbol) {
        var tradeTypes = config.tradeTypes;
        var finalTradeTypes = [];

        tradeTypes.forEach(function (el, i) {
            Object.keys(_symbol).forEach(function (key, index) {
                if (_symbol.hasOwnProperty(key)) {
                    // Find the tradeType in _symbol list
                    if (el.value === key) {
                        var hasTicks = false;
                        // Loop through all _symbols of a trade type
                        for (var j = 0; j < _symbol[key].length; j++) {
                            var minDuration = _symbol[key][j].min_contract_duration;
                            if (minDuration && minDuration.toString().match(/^\d+t$/)) {
                                hasTicks = true;
                            }
                        }
                        if (hasTicks) {
                            finalTradeTypes.push(el);
                        }
                    }
                }
            });
        });

        return finalTradeTypes;
    };

    this.removeActiveSymbols = function () {
        sessionStorage.active_symbols = null;
    };

    this.removeAssetIndex = function () {
        sessionStorage.asset_index = null;
    };

    this.hasActiveSymobols = function () {
        if (!sessionStorage.active_symbols) return false;
        return JSON.parse(sessionStorage.active_symbols);
    };

    this.hasAssetIndex = function () {
        if (!sessionStorage.asset_index) return false;
        return JSON.parse(sessionStorage.asset_index);
    };
}]);
"use strict";

/**
 * @name notificationService
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 05/03/2017
 * @copyright Binary Ltd
 */

angular.module("binary").service("notificationService", function () {
    var _this = this;

    this.notices = [];

    this.emptyNotices = function () {
        _this.notices = [];
    };

    this.messages = {
        authenticateMessage: {
            title: "account_authentication",
            text: "please_authenticate",
            link: "authentication"
        },
        ageVerificationMessage: {
            title: "account_age_verification",
            text: "needs_age_verification",
            link: "contact"
        },
        restrictedMessage: {
            title: "account_restriction",
            text: "please_contact",
            link: "contact"
        },
        countryNotSetMessage: {
            title: "account_country",
            text: "set_country",
            link: "profile"
        },
        riskAssessmentMessage: {
            title: "financial_assessment_not_completed",
            text: "complete_financial_assessment",
            link: "financial-assessment"
        },
        taxInformationMessage: {
            title: "tax_information",
            text: "complete_profile",
            link: "profile"
        },
        termsAndConditionsMessage: {
            title: "tnc",
            text: "accept_tnc",
            link: "terms-and-conditions"
        },
        maxTurnoverLimitNotSetMessage: {
            title: "max_turnover_limit",
            text: "set_max_turnover_limit",
            link: "self-exclusion"
        },
        currencyNotSetMessage: {
            title: "account_currency",
            text: "choose_account_currency",
            link: "set-currency"
        }
    };
});
"use strict";

/**
 * @name session-storage service
 * @author Morteza Tavanarad
 * @contributors []
 * @since 03/24/2017
 * @copyright Binary Ltd
 *
 */

(function () {
    angular.module("binary").factory("sessionStorageService", SessionStorage);

    function SessionStorage() {
        var factory = {};

        factory.getItem = function (itemName) {
            var item = sessionStorage.getItem(itemName);
            if (_.isEmpty(item) || item === "undefined") {
                return null;
            }
            return item;
        };

        return factory;
    }
})();
"use strict";

/**
 * @name supportedLanguagesService
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 06/05/2019
 * @copyright Binary Ltd
 */

angular.module("binary").service("supportedLanguagesService", function () {
  var _this = this;

  this.supportedLanguages = ["en"];

  this.setSupportedLanguages = function (langs) {
    return _this.supportedLanguages = langs;
  };
});
"use strict";

/**
 * @name tableStateService
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 05/02/2016
 * @copyright Binary Ltd
 * Keeping state of the app in this factory
 */

angular.module("binary").factory("tableStateService", function () {
    var factory = {};
    factory.dateType = "allTime";
    factory.dateFrom = "";
    factory.dateTo = "";
    factory.currentPage = 0;
    factory.appID = "allApps";
    factory.batchNum = 0;
    factory.batchLimit = 0;
    factory.batchSize = 20;
    factory.completedGroup = true;
    factory.statementDateType = "allTime";
    factory.statementDateFrom = "";
    factory.statementDateTo = "";
    factory.statementCurrentPage = 0;
    factory.statementAppID = "allApps";
    factory.statementBatchNum = 0;
    factory.statementBatchLimit = 0;
    factory.statementBatchSize = 20;
    factory.statementCompletedGroup = true;

    return factory;
});
"use strict";

/**
 * @name utils service
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/17/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.services").factory("utilsService", Utils);

    Utils.$inject = ["$rootScope"];

    function Utils($rootScope) {
        var factory = {};

        factory.spinnerLogo = {
            start: function start() {
                $rootScope.$broadcast("spinner-logo:start");
            },
            stop: function stop() {
                $rootScope.$broadcast("spinner-logo:stop");
            }
        };

        return factory;
    }
})();
"use strict";

/**
 * @name validation service
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 10/15/2017
 * @copyright Binary Ltd
 */

angular.module("binary").factory("validationService", ["clientService", function (clientService) {
    var validationService = {};

    var getFrctionalDigits = function getFrctionalDigits() {
        return clientService.getFractionalDigits();
    };
    var getFloatNumberRegex = function getFloatNumberRegex() {
        return new RegExp("^\\d+(\\.\\d{0," + validationService.fractionalDigits + "})?$");
    };
    var getValidateFloatNumber = function getValidateFloatNumber(floatNumberRegex) {
        return function (val) {
            return validator(val, floatNumberRegex);
        }();
    };

    validationService.fractionalDigits = getFrctionalDigits();

    var validateGeneralRegex = /[`~!@#$%^&*)(_=+[}{\]\\/";:?><|]+/;
    var validateAddressRegex = /[`~!$%^&*_=+[}{\]\\"?><|]+/;
    var validatePostcodeRegex = /^([a-zA-Z\d-\s])*$/;
    var validatePhoneRegex = /^\+?((-|\s)*[0-9])*$/;
    var validateTaxIdentificationNumberRegex = /^[\w-]{0,20}$/;
    var passwordRegex = /(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]+/;
    var mailRegex = /^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63}$/;
    var tokenRegex = /^\w{8,128}$/;
    var floatNumberRegex = getFloatNumberRegex();
    var integerRegex = /^\d+$/;
    /* eslint-disable */
    var validator = function validator(val, regexPattern, reverse) {
        return {
            test: function test(val) {
                return reverse ? !regexPattern.test(val) : regexPattern.test(val);
            }
        };
    };
    /* eslint-enable */

    validationService.validateGeneral = function (val) {
        return validator(val, validateGeneralRegex, true);
    }();
    validationService.validateAddress = function (val) {
        return validator(val, validateAddressRegex, true);
    }();
    validationService.validatePostcode = function (val) {
        return validator(val, validatePostcodeRegex);
    }();
    validationService.validatePhone = function (val) {
        return validator(val, validatePhoneRegex);
    }();
    validationService.validateTaxIdentificationNumber = function (val) {
        return validator(val, validateTaxIdentificationNumberRegex);
    }();
    validationService.validatePassword = function (val) {
        return validator(val, passwordRegex);
    }();
    validationService.validateMail = function (val) {
        return validator(val, mailRegex);
    }();
    validationService.validateToken = function (val) {
        return validator(val, tokenRegex);
    }();

    validationService.validateFloatNumber = getValidateFloatNumber(floatNumberRegex);
    validationService.validateIntegerNumber = function (val) {
        return validator(val, integerRegex);
    }();

    validationService.length = {
        name: {
            min: 2,
            max: 30
        },
        tin: {
            max: 20
        },
        address: {
            max: 70
        },
        city: {
            max: 35
        },
        postcode: {
            max: 20
        },
        phone: {
            min: 8,
            max: 35
        },
        secret_answer: {
            min: 4,
            max: 50
        },
        password: {
            min: 6,
            max: 25
        },
        selfExclusionLimits: {
            max: 20
        },
        selfExclusionOpenPositions: {
            max: 4
        },
        selfExclusionSessionDuration: {
            max: 5
        }
    };

    validationService.reset = function () {
        validationService.fractionalDigits = getFrctionalDigits();
        floatNumberRegex = getFloatNumberRegex();
        validationService.validateFloatNumber = getValidateFloatNumber(floatNumberRegex);
    };

    return validationService;
}]);
"use strict";

/**
 * @name websocketService
 * @author Massih Hazrati
 * @contributors []
 * @since 10/15/2015
 * @copyright Binary Ltd
 * Handles websocket functionalities
 */

angular.module("binary").factory("websocketService", ["$ionicLoading", "$ionicPlatform", "$rootScope", "$state", "$translate", "alertService", "appStateService", "localStorageService", "clientService", "config", "notificationService", "supportedLanguagesService", function ($ionicLoading, $ionicPlatform, $rootScope, $state, $translate, alertService, appStateService, localStorageService, clientService, config, notificationService, supportedLanguagesService) {
    var dataStream = "";
    var messageBuffer = [];

    var addExtraParams = function addExtraParams(data, extraParams) {
        if (_.isEmpty(extraParams)) {
            return data;
        }

        Object.keys(extraParams).forEach(function (key, index) {
            if (extraParams.hasOwnProperty(key)) {
                data[key] = extraParams[key];
            }
        });

        return data;
    };

    var waitForConnection = function waitForConnection(callback, isAuthonticationRequest) {
        if (dataStream && dataStream.readyState === 3) {
            init();
            if (!isAuthonticationRequest) {
                setTimeout(function () {
                    waitForConnection(callback);
                }, 1000);
            }
        } else if (dataStream && dataStream.readyState === 1) {
            callback();
        } else if (!(dataStream instanceof WebSocket)) {
            init();
            if (!isAuthonticationRequest) {
                setTimeout(function () {
                    waitForConnection(callback);
                }, 1000);
            }
        } else {
            setTimeout(function () {
                waitForConnection(callback);
            }, 1000);
        }
    };

    var sendMessage = function sendMessage(_data) {
        var token = localStorageService.getDefaultToken();

        $ionicPlatform.ready(function () {
            waitForConnection(function () {
                dataStream.send(JSON.stringify(_data));
            }, _data.hasOwnProperty("authorize") && token);
        });
    };

    var getAppId = function getAppId() {
        return window.localStorage.getItem('config.app_id') || config.app_id;
    };

    var getSocketURL = function getSocketURL() {
        var server_url = window.localStorage.getItem('config.server_url');
        var wsUrl = server_url ? "wss://" + server_url + "/websockets/v3" : config.wsUrl;
        return wsUrl;
    };

    var getFPofURL = function getFPofURL(url) {
        if (_.isEmpty(url)) {
            return null;
        }

        var result = /(binaryqa\d{2}.com)/.exec(url);

        if (!_.isEmpty(result)) {
            var bareUrl = "www." + result[1];

            var matchedCert = _.find(config.qaMachinesCertFP, function (c) {
                return c.url.indexOf(bareUrl) > -1;
            });

            if (matchedCert) {
                return matchedCert.fp;
            }
        }

        return config.serverCertFP;
    };

    var init = function init(forced) {
        forced = forced || false;
        var language = localStorage.language || "en";

        if (dataStream && dataStream.readyState !== 3 && !forced) {
            return;
        } else if (dataStream && dataStream.readyState !== 0) {
            dataStream.close();
        }

        dataStream = null;

        appStateService.isLoggedin = false;

        var onFailed = function onFailed() {
            $rootScope.$broadcast("connection:error", true);
        };

        var onSuccess = function onSuccess() {

            dataStream = new WebSocket(wsUrl + "?app_id=" + appId + "&l=" + language);

            dataStream.onopen = function () {
                // Authorize the default token if it's exist
                var token = localStorageService.getDefaultToken();
                if (token) {
                    var data = {
                        authorize: token,
                        passthrough: {
                            type: "reopen-connection"
                        }
                    };
                    sendMessage(data);
                }

                console.log("socket is opened"); // eslint-disable-line
                $rootScope.$broadcast("connection:ready");
            };

            dataStream.onmessage = function (message) {
                receiveMessage(message);
            };

            dataStream.onclose = function (e) {
                console.log("socket is closed ", e); // eslint-disable-line
                init();
                console.log("socket is reopened"); // eslint-disable-line
                appStateService.isLoggedin = false;
                $rootScope.$broadcast("connection:reopened");
            };

            dataStream.onerror = function (e) {
                if (e.target.readyState === 3) {
                    $rootScope.$broadcast("connection:error");
                }
                appStateService.isLoggedin = false;
            };
        };

        var appId = getAppId();
        var wsUrl = getSocketURL();
        var fp = getFPofURL(wsUrl);

        if (window.plugins && window.plugins.sslCertificateChecker) {
            window.plugins.sslCertificateChecker.check(onSuccess, onFailed, "https://" + wsUrl.slice(6), fp);
        } else {
            onSuccess();
        }
    };

    $rootScope.$on("language:updated", function () {
        init(true);

        // Fetch asset_indes and active_symbols in order to update text in selected language.
        sessionStorage.removeItem('asset_index');
        sessionStorage.removeItem('active_symbols');
        websocketService.sendRequestFor.assetIndex();
        websocketService.sendRequestFor.symbols();
    });

    var websocketService = {};
    websocketService.authenticate = function (_token, extraParams) {
        extraParams = null || extraParams;
        appStateService.isLoggedin = false;

        var data = {
            authorize: _token
        };

        addExtraParams(data, extraParams);

        sendMessage(data);
    };

    websocketService.logout = function (error) {
        websocketService.sendRequestFor.logout();
        localStorage.removeItem("accounts");
        websocketService.sendRequestFor.forgetProposals();
        sessionStorage.active_symbols = null;
        sessionStorage.asset_index = null;
        appStateService.isRealityChecked = false;
        appStateService.isChangedAccount = false;
        appStateService.isPopupOpen = false;
        appStateService.isLoggedin = false;
        sessionStorage.removeItem("start");
        sessionStorage.removeItem("_interval");
        sessionStorage.removeItem("realityCheckStart");
        localStorage.removeItem("termsConditionsVersion");
        localStorage.removeItem("landingCompanyObject");
        localStorage.removeItem("landingCompany");
        localStorage.removeItem("landingCompanyName");
        appStateService.profitTableRefresh = true;
        appStateService.statementRefresh = true;
        sessionStorage.removeItem("countryParams");
        websocketService.closeConnection();
        appStateService.passwordChanged = false;
        appStateService.limitsChange = false;
        appStateService.realityCheckLogin = false;
        appStateService.hasAuthenticateMessage = false;
        appStateService.hasRestrictedMessage = false;
        appStateService.hasMaxTurnoverMessage = false;
        appStateService.hasCountryMessage = false;
        appStateService.hasTnCMessage = false;
        appStateService.hasTaxInfoMessage = false;
        appStateService.hasFinancialAssessmentMessage = false;
        appStateService.hasAgeVerificationMessage = false;
        appStateService.hasCountryMessage = false;
        appStateService.hasCurrencyMessage = false;
        appStateService.checkedAccountStatus = false;
        appStateService.accountCurrencyChanged = false;
        appStateService.selectedCurrency = false;
        notificationService.emptyNotices();
        appStateService.checkingUpgradeDone = false;
        appStateService.loginFinished = false;
        appStateService.isMaltainvest = false;

        if (error) {
            $translate(["alert.error", "alert.ok"]).then(function (translation) {
                alertService.displayAlert(translation["alert.error"], error, translation["alert.ok"], function () {
                    $state.go("signin");
                });
            });
        } else {
            $state.go("signin");
        }
    };

    websocketService.sendRequestFor = {
        websiteStatus: function websiteStatus(subscribe) {
            subscribe = subscribe || false;
            var data = {
                website_status: 1,
                subscribe: subscribe ? 1 : 0
            };
            sendMessage(data);
        },
        symbols: function symbols() {
            var data = {
                active_symbols: "brief"
            };
            sendMessage(data);
        },
        assetIndex: function assetIndex() {
            var data = {
                asset_index: 1
            };
            sendMessage(data);
        },
        currencies: function currencies() {
            var data = {
                payout_currencies: 1
            };
            sendMessage(data);
        },
        contractsForSymbol: function contractsForSymbol(_symbol) {
            var data = {
                contracts_for: _symbol
            };
            sendMessage(data);
        },
        ticksForSymbol: function ticksForSymbol(_symbol) {
            var data = {
                ticks: _symbol
            };
            sendMessage(data);
        },
        forgetAll: function forgetAll(_stream) {
            var data = {
                forget_all: _stream
            };
            sendMessage(data);
        },
        forgetStream: function forgetStream(_id) {
            var data = {
                forget: _id
            };
            sendMessage(data);
        },
        forgetProposals: function forgetProposals(reqId) {
            var data = {
                forget_all: "proposal",
                req_id: reqId
            };
            sendMessage(data);
        },
        forgetTicks: function forgetTicks() {
            var data = {
                forget_all: "ticks"
            };
            sendMessage(data);
        },
        proposal: function proposal(_proposal) {
            sendMessage(_proposal);
        },
        purchase: function purchase(_proposalId, price) {
            var data = {
                buy: _proposalId,
                price: price || 0
            };
            sendMessage(data);
        },
        balance: function balance() {
            var data = {
                balance: 1,
                subscribe: 1
            };
            sendMessage(data);
        },
        portfolio: function portfolio() {
            var data = {
                portfolio: 1
            };
            sendMessage(data);
        },
        profitTable: function profitTable(params, req_id) {
            var data = {
                profit_table: 1
            };

            addExtraParams(data, params);

            sendMessage(data);
        },
        ticksHistory: function ticksHistory(data) {
            // data is the whole JSON convertable object parameter for the ticks_history API call
            if (data.ticks_history) {
                sendMessage(data);
            }
        },
        openContract: function openContract(contractId, extraParams) {
            var data = {};
            data.proposal_open_contract = 1;

            if (contractId) {
                data.contract_id = contractId;
            }

            addExtraParams(data, extraParams);

            sendMessage(data);
        },
        sellExpiredContract: function sellExpiredContract() {
            var data = {
                sell_expired: 1
            };

            sendMessage(data);
        },
        landingCompanyDetails: function landingCompanyDetails(company) {
            var data = {
                landing_company_details: company
            };
            sendMessage(data);
        },
        realityCheck: function realityCheck() {
            var data = {
                reality_check: 1
            };
            sendMessage(data);
        },
        accountOpening: function accountOpening(verifyEmail) {
            var data = {
                verify_email: verifyEmail,
                type: "account_opening"
            };
            sendMessage(data);
        },
        residenceListSend: function residenceListSend() {
            var data = {
                residence_list: 1
            };
            sendMessage(data);
        },
        newAccountVirtual: function newAccountVirtual(verificationCode, clientPassword, residence) {
            var data = {
                new_account_virtual: "1",
                verification_code: verificationCode,
                client_password: clientPassword,
                residence: residence
            };
            sendMessage(data);
        },
        accountSetting: function accountSetting() {
            var data = {
                get_settings: 1
            };
            sendMessage(data);
        },
        setAccountSettings: function setAccountSettings(data) {
            data.set_settings = 1;

            sendMessage(data);
        },
        landingCompanySend: function landingCompanySend(company, reqId) {
            var data = {
                landing_company: company
            };
            if (reqId) {
                data.req_id = reqId;
            }
            sendMessage(data);
        },
        statesListSend: function statesListSend(countryCode) {
            var data = {
                states_list: countryCode
            };
            sendMessage(data);
        },
        createRealAccountSend: function createRealAccountSend(params) {
            var data = {
                new_account_real: "1"
            };
            addExtraParams(data, params);
            sendMessage(data);
        },
        createMaltainvestAccountSend: function createMaltainvestAccountSend(params) {
            var data = {
                new_account_maltainvest: "1"
            };
            addExtraParams(data, params);
            sendMessage(data);
        },
        statement: function statement(params) {
            var data = {
                statement: 1
            };

            addExtraParams(data, params);

            sendMessage(data);
        },
        ping: function ping() {
            var data = {
                ping: 1
            };
            sendMessage(data);
        },
        setSelfExclusion: function setSelfExclusion(params) {
            var data = {
                set_self_exclusion: 1
            };

            addExtraParams(data, params);

            sendMessage(data);
        },
        getSelfExclusion: function getSelfExclusion() {
            var data = {
                get_self_exclusion: 1
            };

            sendMessage(data);
        },
        TAndCApprovalSend: function TAndCApprovalSend() {
            var data = {
                tnc_approval: 1
            };
            sendMessage(data);
        },
        changePassword: function changePassword(_oldPassword, _newPassword) {
            var data = {
                change_password: "1",
                old_password: _oldPassword,
                new_password: _newPassword
            };
            sendMessage(data);
        },
        getFinancialAssessment: function getFinancialAssessment() {
            var data = {
                get_financial_assessment: 1
            };
            sendMessage(data);
        },
        setFinancialAssessment: function setFinancialAssessment(params) {
            var data = {
                set_financial_assessment: 1
            };

            addExtraParams(data, params);
            sendMessage(data);
        },
        tradingTimes: function tradingTimes(_date) {
            var data = {
                trading_times: _date
            };
            sendMessage(data);
        },
        getAccountStatus: function getAccountStatus() {
            var data = {
                get_account_status: 1
            };
            sendMessage(data);
        },
        accountLimits: function accountLimits() {
            var data = {
                get_limits: 1
            };
            sendMessage(data);
        },
        logout: function logout() {
            var data = {
                logout: 1
            };

            sendMessage(data);
        },
        mt5LoginList: function mt5LoginList() {
            var data = {
                mt5_login_list: 1
            };

            sendMessage(data);
        },
        mt5GetSettings: function mt5GetSettings(login) {
            var data = {
                mt5_get_settings: 1,
                login: login
            };

            sendMessage(data);
        },
        setAccountCurrency: function setAccountCurrency(currency) {
            var data = {
                set_account_currency: currency
            };

            sendMessage(data);
        }
    };
    websocketService.closeConnection = function () {
        if (dataStream) {
            dataStream.close();
        }
    };

    var receiveMessage = function receiveMessage(_response) {
        var message = JSON.parse(_response.data);

        if (message) {
            if (message.error) {
                if (["InvalidToken", "AccountDisabled", "DisabledClient"].indexOf(message.error.code) > -1) {
                    websocketService.logout(message.error.message);

                    // hide ionicLoading if some component show it to receive auth message.
                    $ionicLoading.hide();

                    return;
                }
            }

            var messageType = message.msg_type;
            switch (messageType) {
                case "authorize":
                    if (message.authorize) {
                        message.authorize.token = message.echo_req.authorize;
                        window._trackJs.userId = message.authorize.loginid;
                        appStateService.isLoggedin = true;
                        appStateService.virtuality = message.authorize.is_virtual;
                        localStorage.landingCompanyName = message.authorize.landing_company_fullname;
                        localStorage.landingCompany = message.authorize.landing_company_name;
                        appStateService.scopes = message.authorize.scopes;
                        appStateService.upgradeableLandingCompanies = message.authorize.upgradeable_landing_companies || [];
                        appStateService.isMaltainvest = clientService.isLandingCompanyOf('maltainvest', message.authorize.landing_company_name);
                        // update accounts from account list whenever authorize is received
                        var accounts = !_.isEmpty(localStorage.getItem('accounts')) && JSON.parse(localStorage.getItem('accounts'));
                        var accountList = message.authorize.account_list;
                        if (accounts && accounts.length && accountList) {
                            accounts.forEach(function (account, idx) {
                                var acc = _.find(accountList, function (a) {
                                    return a.loginid === account.id;
                                });
                                account.country = message.authorize.country || '';
                                accounts[idx] = _.assign(account, acc);
                            });
                            localStorage.setItem('accounts', JSON.stringify(accounts));
                        }

                        if (_.isEmpty(message.authorize.currency)) {
                            websocketService.sendRequestFor.currencies();
                        } else {
                            sessionStorage.currency = message.authorize.currency;
                        }
                        appStateService.loginFinished = true;

                        $rootScope.$broadcast("authorize", message.authorize, message.req_id, message.passthrough);
                    } else {
                        var errorMessage = "Unexpected Error!";
                        if (message.hasOwnProperty("error")) {
                            localStorageService.removeToken(message.echo_req.authorize);
                            errorMessage = message.error.message;
                        }
                        $rootScope.$broadcast("authorize", false, errorMessage);
                        appStateService.isLoggedin = false;
                    }
                    break;
                case "website_status":
                    if (message.hasOwnProperty("website_status")) {
                        appStateService.currenciesConfig = message.website_status.currencies_config;
                        $rootScope.$broadcast("website_status", message.website_status);
                        localStorage.termsConditionsVersion = message.website_status.terms_conditions_version;
                        var supportedLanguages = message.website_status.supported_languages;
                        if (supportedLanguages.length) {
                            supportedLanguagesService.setSupportedLanguages(message.website_status.supported_languages);
                            $rootScope.$broadcast("supported_languages");
                        }
                    } else if (message.hasOwnProperty("error")) {
                        trackJs.track(message.error.code + ": " + message.error.message);
                    }
                    break;
                case "active_symbols":
                    {
                        var markets = message.active_symbols;
                        var groupedMarkets = _.groupBy(markets, "market");
                        var openMarkets = {};
                        Object.keys(groupedMarkets).forEach(function (key, index) {
                            if (groupedMarkets.hasOwnProperty(key)) {
                                if (groupedMarkets[key][0].exchange_is_open === 1) {
                                    openMarkets[key] = groupedMarkets[key];
                                }
                            }
                        });
                        // if ( !sessionStorage.hasOwnProperty('active_symbols') || sessionStorage.active_symbols != JSON.stringify(openMarkets) ) {
                        sessionStorage.active_symbols = JSON.stringify(openMarkets);
                        sessionStorage.all_active_symbols = JSON.stringify(message.active_symbols);
                        $rootScope.$broadcast("symbols:updated", openMarkets);
                        // }
                        break;
                    }
                case "asset_index":
                    // if ( !sessionStorage.hasOwnProperty('asset_index') || sessionStorage.asset_index != JSON.stringify(message.asset_index) ) {
                    sessionStorage.asset_index = JSON.stringify(message.asset_index);
                    $rootScope.$broadcast("assetIndex:updated");
                    // }
                    break;
                case "payout_currencies":
                    $rootScope.$broadcast("currencies", message.payout_currencies);
                    break;
                case "proposal":
                    if (message.proposal) {
                        $rootScope.$broadcast("proposal", message.proposal, message.req_id);
                    } else if (message.error) {
                        $rootScope.$broadcast("proposal:error", message.error, message.req_id);
                    }
                    break;
                case "contracts_for":
                    {
                        var symbol = message.echo_req.contracts_for;
                        if (message.error) {
                            trackJs.track(message.error.code + ": " + message.error.message + " - " + symbol);
                            break;
                        }
                        var groupedSymbol = _.groupBy(message.contracts_for.available, "contract_category");
                        $rootScope.$broadcast("symbol", groupedSymbol);
                        break;
                    }
                case "buy":
                    if (message.error) {
                        $rootScope.$broadcast("purchase:error", message.error);
                        alertService.displayError(message.error.message);
                    } else {
                        $rootScope.$broadcast("purchase", message);
                    }
                    break;
                case "balance":
                    if (!message.error) {
                        $rootScope.$broadcast("balance", message.balance);
                    }
                    break;
                case "tick":
                    $rootScope.$broadcast("tick", message);
                    break;
                case "history":
                    $rootScope.$broadcast("history", message);
                    break;
                case "candles":
                    $rootScope.$broadcast("candles", message);
                    break;
                case "ohlc":
                    $rootScope.$broadcast("ohlc", message);
                    break;
                case "portfolio":
                    $rootScope.$broadcast("portfolio", message.portfolio);
                    break;
                case "profit_table":
                    if (message.profit_table) {
                        $rootScope.$broadcast("profit_table:update", message.profit_table, message.req_id);
                    } else if (message.error) {
                        $rootScope.$broadcast("profit_table:error", message.error.message);
                    }
                    break;
                case "sell_expired":
                    $rootScope.$broadcast("sell:expired", message.sell_expired);
                    break;
                case "proposal_open_contract":
                    $rootScope.$broadcast("proposal:open-contract", message.proposal_open_contract, message.req_id);
                    break;
                case "landing_company_details":
                    if (message.landing_company_details) {
                        $rootScope.$broadcast("landing_company_details", message.landing_company_details);
                    } else if (message.error) {
                        $rootScope.$broadcast("landing_company_details:error", message.error.message);
                    }
                    break;
                case "reality_check":
                    $rootScope.$broadcast("reality_check", message.reality_check);
                    break;
                case "verify_email":
                    if (message.verify_email) {
                        $rootScope.$broadcast("verify_email", message.verify_email);
                    } else if (message.error) {
                        $rootScope.$broadcast("verify_email:error", message.error.details);
                    }
                    break;
                case "residence_list":
                    $rootScope.$broadcast("residence_list", message.residence_list);
                    break;
                case "new_account_virtual":
                    if (message.new_account_virtual) {
                        $rootScope.$broadcast("new_account_virtual", message.new_account_virtual);
                    } else if (message.error) {
                        $rootScope.$broadcast("new_account_virtual:error", message.error);
                    }
                    break;
                case "get_settings":
                    if (message.get_settings) {
                        $rootScope.$broadcast("get_settings", message.get_settings);
                    } else if (message.error) {
                        $rootScope.$broadcast("get_settings:error", message.error.message);
                    }
                    break;
                case "landing_company":
                    if (message.landing_company) {
                        localStorage.setItem('landingCompanyObject', JSON.stringify(message.landing_company));
                        $rootScope.$broadcast("landing_company", message.landing_company, message.req_id);
                    } else if (message.error) {
                        $rootScope.$broadcast("landing_company:error", message.error.message);
                    }
                    break;
                case "states_list":
                    $rootScope.$broadcast("states_list", message.states_list);
                    break;
                case "new_account_real":
                    if (message.new_account_real) {
                        $rootScope.$broadcast("new_account_real", message.new_account_real);
                    } else if (message.error) {
                        $rootScope.$broadcast("new_account_real:error", message.error);
                    }
                    break;
                case "new_account_maltainvest":
                    if (message.new_account_maltainvest) {
                        $rootScope.$broadcast("new_account_maltainvest", message.new_account_maltainvest);
                    } else if (message.error) {
                        $rootScope.$broadcast("new_account_maltainvest:error", message.error);
                    }
                    break;
                case "statement":
                    if (message.statement) {
                        $rootScope.$broadcast("statement:update", message.statement, message.req_id);
                    } else if (message.error) {
                        $rootScope.$broadcast("statement:error", message.error.message);
                    }
                    break;
                case "get_self_exclusion":
                    if (message.get_self_exclusion) {
                        $rootScope.$broadcast("get-self-exclusion", message.get_self_exclusion);
                    } else if (message.error) {
                        $rootScope.$broadcast("get-self-exclusion:error", message.error.message);
                    }
                    break;
                case "set_self_exclusion":
                    if (message.set_self_exclusion) {
                        $rootScope.$broadcast("set-self-exclusion", message.set_self_exclusion);
                    } else if (message.error) {
                        $rootScope.$broadcast("set-self-exclusion:error", message.error.message);
                    }
                    break;
                case "set_settings":
                    if (message.set_settings) {
                        $rootScope.$broadcast("set-settings", message.set_settings);
                    } else if (message.error) {
                        $rootScope.$broadcast("set-settings:error", message.error);
                    }
                    break;
                case "tnc_approval":
                    if (message.tnc_approval) {
                        $rootScope.$broadcast("tnc_approval", message.tnc_approval);
                    } else if (message.error) {
                        $rootScope.$broadcast("tnc_approval:error", message.error);
                    }
                    break;
                case "change_password":
                    if (message.change_password) {
                        $rootScope.$broadcast("change_password:success", message.change_password);
                    } else if (message.error) {
                        $rootScope.$broadcast("change_password:error", message.error);
                    }
                    break;
                case "get_financial_assessment":
                    if (message.get_financial_assessment) {
                        $rootScope.$broadcast("get_financial_assessment:success", message.get_financial_assessment);
                    } else if (message.error) {
                        $rootScope.$broadcast("get_financial_assessment:error", message.error);
                    }
                    break;
                case "set_financial_assessment":
                    if (message.set_financial_assessment) {
                        $rootScope.$broadcast("set_financial_assessment:success", message.set_financial_assessment);
                    } else if (message.error) {
                        $rootScope.$broadcast("set_financial_assessment:error", message.error);
                    }
                    break;
                case "get_account_status":
                    if (message.get_account_status) {
                        $rootScope.$broadcast("get_account_status", message.get_account_status);
                    } else if (message.error) {
                        trackJs.track(message.error.code + ": " + message.error.message);
                    }
                    break;
                case "get_limits":
                    if (message.get_limits) {
                        $rootScope.$broadcast("get_limits", message.get_limits);
                    } else if (message.error) {
                        $rootScope.$broadcast("get_limits:error", message.error);
                    }
                    break;
                case "trading_times":
                    if (message.trading_times) {
                        $rootScope.$broadcast("trading_times:success", message.trading_times);
                    } else if (message.error) {
                        $rootScope.$broadcast("trading_times:error", message.error);
                    }
                    break;
                case "forget_all":
                    $rootScope.$broadcast("forget_all", message.req_id);
                    break;
                case "mt5_login_list":
                    if (message.mt5_login_list) {
                        $rootScope.$broadcast("mt5_login_list:success", message.mt5_login_list);
                        localStorage.setItem("mt5LoginList", message.mt5_login_list);
                    }
                    break;
                case "mt5_get_settings":
                    if (message.mt5_get_settings) {
                        $rootScope.$broadcast("mt5_get_settings:success", message.mt5_get_settings);
                    }
                    break;
                case "set_account_currency":
                    if (message.set_account_currency && message.set_account_currency === 1) {
                        $rootScope.$broadcast("set_account_currency:success", message.echo_req.set_account_currency);
                    } else if (message.error) {
                        $rootScope.$broadcast("set_account_currency:error", message.error);
                    }
                    break;
                default:
            }
        }
    };

    websocketService.getServerURL = localStorage.getItem('config.server_url') || config.serverUrl;

    return websocketService;
}]);
"use strict";

/**
 * @name accounts controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/15/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.accounts.controllers").controller("AccountsController", Accounts);

    Accounts.$inject = ["$scope", "$rootScope", "$state", "$ionicSideMenuDelegate", "accountService", "appStateService", "websocketService", "notificationService", "validationService"];

    function Accounts($scope, $rootScope, $state, $ionicSideMenuDelegate, accountService, appStateService, websocketService, notificationService, validationService) {
        var vm = this;
        var updatingAccount = false;

        var init = function init() {
            vm.accounts = accountService.getAll();
            var defaultAccount = accountService.getDefault();
            if (defaultAccount == null) {
                vm.selectedAccount = null;
            } else {
                vm.selectedAccount = accountService.getDefault().token;
            }
        };

        $scope.$watch(function () {
            return appStateService.accountCurrencyChanged;
        }, function () {
            if (appStateService.accountCurrencyChanged === true) {
                vm.accounts = accountService.getAll();
                appStateService.accountCurrencyChanged = false;
            }
        });

        var updateSymbols = function updateSymbols() {
            // Wait untile the login progress is finished
            if (!appStateService.isLoggedin) {
                setTimeout(updateSymbols, 500);
            } else {
                websocketService.sendRequestFor.symbols();
                websocketService.sendRequestFor.assetIndex();
            }
        };

        init();

        vm.updateAccount = function (_selectedAccount) {
            updatingAccount = true;
            appStateService.loginFinished = false;
            accountService.setDefault(_selectedAccount);
            accountService.validate();
            updateSymbols();
            websocketService.sendRequestFor.forgetStream(appStateService.balanceSubscribtionId);
            appStateService.isChangedAccount = true;
            sessionStorage.removeItem("start");
            sessionStorage.removeItem("_interval");
            sessionStorage.removeItem("realityCheckStart");
            appStateService.isProfitTableSet = false;
            appStateService.isStatementSet = false;
            appStateService.profitTableRefresh = true;
            appStateService.statementRefresh = true;
            sessionStorage.removeItem("countryParams");
            appStateService.isPopupOpen = false;
            appStateService.realityCheckLogin = false;
            $ionicSideMenuDelegate.toggleLeft();
            appStateService.limitsChange = true;
            appStateService.hasAuthenticateMessage = false;
            appStateService.hasRestrictedMessage = false;
            appStateService.hasMaxTurnoverMessage = false;
            appStateService.hasCountryMessage = false;
            appStateService.hasTnCMessage = false;
            appStateService.hasTaxInfoMessage = false;
            appStateService.hasFinancialAssessmentMessage = false;
            appStateService.hasAgeVerificationMessage = false;
            appStateService.hasCurrencyMessage = false;
            appStateService.checkedAccountStatus = false;
            notificationService.emptyNotices();
            appStateService.checkingUpgradeDone = false;
        };

        $scope.$on("authorize", function (e, authorize) {
            if (authorize && appStateService.newAccountAdded) {
                var account = _.find(authorize.account_list, function (acc) {
                    return acc.loginid === authorize.loginid;
                });
                account = _.assign(authorize, account);
                accountService.add(account);
                appStateService.newAccountAdded = false;
                accountService.setDefault(authorize.token);
                vm.updateAccount(authorize.token);
                vm.accounts = accountService.getAll();
                vm.selectedAccount = authorize.token;
                appStateService.virtuality = authorize.is_virtual;
                accountService.addedAccount = "";
                var selectedCurrency = appStateService.selectedCurrency || '';
                validationService.reset();

                if (!authorize.currency && !selectedCurrency) {
                    $state.go("set-currency");
                } else if (!authorize.currency && selectedCurrency) {
                    websocketService.sendRequestFor.setAccountCurrency(selectedCurrency);
                } else {
                    $state.go("trade");
                }
            } else if (authorize && updatingAccount) {
                validationService.reset();
            }
        });

        $scope.$on('set_account_currency:success', function (e, currency) {
            var accounts = accountService.getAll();
            for (var i = 0; i < accounts.length; i++) {
                if (accounts[i].is_default === true) {
                    accounts[i].currency = currency;
                    break;
                }
            }
            localStorage.accounts = JSON.stringify(accounts);
            localStorage.setItem("accounts", JSON.stringify(accounts));
            appStateService.accountCurrencyChanged = true;
            $rootScope.$broadcast("currency:changed", currency);
            validationService.reset();
            $state.go("trade");
        });
    }
})();
"use strict";

/**
 * @name accounts directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/15/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.accounts.directives").directive("bgAccounts", Accounts);

    function Accounts() {
        var directive = {
            restrict: "E",
            templateUrl: "js/share/components/accounts/accounts.template.html",
            controller: "AccountsController",
            controllerAs: "vm",
            bindToContoller: true,
            scope: {}
        };

        return directive;
    }
})();
"use strict";

/**
 * @name balance controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/15/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.balance.controllers").controller("BalanceController", Balance);

    Balance.$inject = ["$scope", "appStateService", "websocketService"];

    function Balance($scope, appStateService, websocketService) {
        var vm = this;
        vm.balance = null;

        $scope.$on("authorize", function (e, response, requestId, pathtrough) {
            $scope.$applyAsync(function () {
                vm.balance = {
                    currency: response.currency,
                    balance: response.balance,
                    loginid: response.loginid
                };
                sessionStorage.setItem("balance", vm.balance.balance);

                getBalance();
            });
        });

        $scope.$on("balance", function (e, response) {
            $scope.$applyAsync(function () {
                vm.balance = response;
                appStateService.balanceSubscribtionId = response.id || null;
            });
        });

        $scope.$on("language:updated", function (e) {
            websocketService.sendRequestFor.forgetAll("balance");
            vm.balance = null;
            getBalance();
        });

        function getBalance() {
            websocketService.sendRequestFor.balance();
        }

        $scope.$on('currency:changed', function (e, currency) {
            getBalance();
            vm.balance.currency = currency;
        });

        getBalance();
    }
})();
"use strict";

/**
 * @name balance directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/15/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.balance.directives").directive("bgBalance", Balance);

    Balance.$inject = ["websocketService"];

    function Balance(websocketService) {
        var directive = {
            restrict: "E",
            templateUrl: "js/share/components/balance/balance.template.html",
            controller: "BalanceController",
            controllerAs: "vm",
            bindToController: true,
            scope: {
                proposal: "=?"
            },
            link: link
        };

        function link(scope, element, attributes, vm) {
            scope.$on("$destroy", function () {
                if (vm.balance && vm.balance.id) {
                    websocketService.sendRequestFor.forgetStream(vm.balance.id);
                }
            });
        }

        return directive;
    }
})();
"use strict";

/**
		 * @name app version controller
		 * @author Nazanin Reihani Haghighi
		 * @contributors []
		 * @since 12/19/2016
		 * @copyright Binary Ltd
		 */

(function () {
    angular.module("binary.share.components.app-version.controllers").controller("AppVersionController", AppVersion);

    AppVersion.$inject = ["$scope", "$ionicPlatform", "appVersionService"];

    function AppVersion($scope, $ionicPlatform, appVersionService) {
        var vm = this;
        vm.appVersion = '0.0.0';
        $ionicPlatform.ready(function () {
            $scope.$applyAsync(function () {
                if (window.cordova) {
                    cordova.getAppVersion(function (version) {
                        vm.appVersion = version;
                        window._trackJs.version = vm.appVersion;
                    }, function (err) {
                        // console.log(err);
                    });
                } else {
                    appVersionService.getAppVersion().success(function (data) {
                        vm.appVersion = data.version;
                        window._trackJs.version = vm.appVersion;
                    }).error(function (data) {
                        vm.appVersion = "0.0.0";
                        window._trackJs.version = vm.appVersion;
                    });
                }
            });
        });
    }
})();
"use strict";

/**
 * @name app version directive
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 12/19/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.app-version.directives").directive("bgAppVersion", AppVersion);

    function AppVersion() {
        var directive = {
            restrict: "E",
            templateUrl: "js/share/components/app-version/app-version.template.html",
            controller: "AppVersionController",
            controllerAs: "vm",
            bindToController: true,
            scope: {}
        };
        return directive;
    }
})();
"use strict";

/**
 * @name big number Controller
 * @author Morteza Tavanarad
 * @contributors []
 * @since 06/09/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.big-number.directives").directive("bgBigNumber", BigNumber);

    BigNumber.$inject = [];

    function BigNumber() {
        var directive = {
            restrict: "A",
            require: "?ngModel",
            link: link
        };

        function link(scope, element, attr, ctrl) {
            if (ctrl) {
                ctrl.$formatters.push(function (modelValue) {
                    if (angular.isDefined(modelValue) && _.isEmpty(modelValue.toString())) {
                        return null;
                    }
                    return modelValue;
                });

                ctrl.$parsers.push(function (viewValue) {
                    if (!viewValue) {
                        return null;
                    }
                    return viewValue;
                });

                var minVal = void 0;
                var maxVal = void 0;

                if (angular.isDefined(attr.min) || attr.ngMin) {
                    ctrl.$validators.min = function (value) {
                        return ctrl.$isEmpty(value) || angular.isUndefined(minVal) || value >= parseFloat(minVal);
                    };

                    attr.$observe("min", function (val) {
                        minVal = val;
                        ctrl.$validate();
                    });
                }

                if (angular.isDefined(attr.max) || attr.ngMax) {
                    ctrl.$validators.max = function (value) {
                        return ctrl.$isEmpty(value) || angular.isUndefined(maxVal) || value <= parseFloat(maxVal);
                    };

                    attr.$observe("max", function (val) {
                        maxVal = val;
                        ctrl.$validate();
                    });
                }
            }
        }

        return directive;
    }
})();
"use strict";

/**
 * @name Check User Status controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 02/15/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.check-user-status.controllers").controller("CheckUserStatusController", CheckUserStatus);

    CheckUserStatus.$inject = ["$scope", "$timeout", "websocketService", "appStateService", "accountService", "notificationService", "clientService"];

    function CheckUserStatus($scope, $timeout, websocketService, appStateService, accountService, notificationService, clientService) {
        var vm = this;
        var isMaltainvest = false;
        var isCR = false;
        var isMalta = false;
        var isIom = false;
        var isVirtual = false;
        var websiteTncStatus = '';
        var clientTncStatus = '';
        var currentAccount = {};
        var mt5LoginList = [];
        var status = {};
        var notificationMessages = notificationService.messages;

        var isLandingCompanyOf = function isLandingCompanyOf(targetLandingCompany, accountLandingCompany) {
            return clientService.isLandingCompanyOf(targetLandingCompany, accountLandingCompany);
        };

        // check type of account
        var checkAccountType = function checkAccountType(landingCompany) {
            isMaltainvest = isLandingCompanyOf('maltainvest', landingCompany);
            isMalta = isLandingCompanyOf('malta', landingCompany);
            isCR = isLandingCompanyOf('costarica', landingCompany) || isLandingCompanyOf('svg', landingCompany);
            isIom = isLandingCompanyOf('iom', landingCompany);
            isVirtual = isLandingCompanyOf('virtual', landingCompany);
        };

        var getAccountInfo = function getAccountInfo() {
            currentAccount = accountService.getDefault();
            if (!_.isEmpty(currentAccount) && appStateService.loginFinished) {
                currencyStatus(currentAccount.currency);
                checkAccountType(currentAccount.landingCompany);
                websocketService.sendRequestFor.getAccountStatus();
                websocketService.sendRequestFor.getSelfExclusion();
                websocketService.sendRequestFor.accountSetting();
                if (currentAccount.excluded_until && !appStateService.hasRestrictedMessage) {
                    appStateService.hasRestrictedMessage = true;
                    notificationService.notices.push(notificationMessages.restrictedMessage);
                }
            } else {
                $timeout(getAccountInfo, 1000);
            }
        };

        $scope.$on('mt5_login_list:success', function (e, mt5_login_list) {
            mt5LoginList = mt5_login_list;
            riskAssessmentStatus(status);
        });

        $scope.$on("authorize", function (e, authorize) {
            if (!appStateService.checkedAccountStatus) {
                init();
            }
        });

        // in case the authorize response is passed before the execution of this controller
        var init = function init() {
            if (appStateService.isLoggedin && !appStateService.checkedAccountStatus) {
                appStateService.checkedAccountStatus = true;
                getAccountInfo();
            }
        };

        init();

        var riskAssessmentStatus = function riskAssessmentStatus(status) {
            var isHighRisk = status.risk_classification === "high";
            var hasRiskAssessment = isMaltainvest ? status.indexOf("financial_assessment_not_complete") > -1 || status.indexOf("trading_experience_not_complete") : isHighRisk && status.indexOf("financial_assessment_not_complete") > -1;
            var mt5HasRiskAssessment = mt5LoginList.length > 0 && (status.indexOf("financial_assessment_not_complete") > -1 || status.indexOf("trading_experience_not_complete"));
            if ((hasRiskAssessment || mt5HasRiskAssessment) && !appStateService.hasRiskAssessmentMessage) {
                appStateService.hasRiskAssessmentMessage = true;
                notificationService.notices.push(notificationMessages.riskAssessmentMessage);
            }
        };

        var taxInformationStatus = function taxInformationStatus(status) {
            if (isMaltainvest && status.indexOf("crs_tin_information") < 0 && !appStateService.hasTaxInfoMessage) {
                appStateService.hasTaxInfoMessage = true;
                notificationService.notices.push(notificationMessages.taxInformationMessage);
            }
        };

        var termsAndConditionsStatus = function termsAndConditionsStatus() {
            if (!appStateService.virtuality && !appStateService.hasTnCMessage && clientTncStatus && websiteTncStatus && clientTncStatus !== websiteTncStatus) {
                appStateService.hasTnCMessage = true;
                notificationService.notices.push(notificationMessages.termsAndConditionsMessage);
                // we run the digest cycle to call $watch in notifications in this case
                // because it can be changed from BE anytime (User is subscribed to website status)
                $scope.$apply();
            }
        };

        var authenticateStatus = function authenticateStatus(promptClientToAuthenticate) {
            if (promptClientToAuthenticate === 1 && !appStateService.hasAuthenticateMessage) {
                appStateService.hasAuthenticateMessage = true;
                notificationService.notices.push(notificationMessages.authenticateMessage);
            }
        };

        var ageVerificationStatus = function ageVerificationStatus(status) {
            var ageVerified = status.indexOf("age_verification") > -1;
            if (!ageVerified && (isMaltainvest || isMalta || isIom)) {
                if (!appStateService.hasAgeVerificationMessage) {
                    appStateService.hasAgeVerificationMessage = true;
                    notificationService.notices.push(notificationMessages.ageVerificationMessage);
                }
            }
        };

        var unwelcomeStatus = function unwelcomeStatus(status) {
            var unwelcomed = status.indexOf("unwelcome") > -1;
            if (unwelcomed && (isMalta || isMaltainvest || isIom || isCR)) {
                if (!appStateService.hasRestrictedMessage) {
                    appStateService.hasRestrictedMessage = true;
                    notificationService.notices.push(notificationMessages.restrictedMessage);
                }
            }
        };

        var cashierStatus = function cashierStatus(status) {
            var cashierLocked = status.indexOf("cashier_locked") > -1;
            if (cashierLocked && (isMalta || isMaltainvest || isIom || isCR)) {
                if (!appStateService.hasRestrictedMessage) {
                    appStateService.hasRestrictedMessage = true;
                    notificationService.notices.push(notificationMessages.restrictedMessage);
                }
            }
        };

        var withdrawalStatus = function withdrawalStatus(status) {
            var withdrawalLocked = status.indexOf("withdrawal_locked") > -1;
            if (withdrawalLocked && (isMalta || isMaltainvest || isIom || isCR)) {
                if (!appStateService.hasRestrictedMessage) {
                    appStateService.hasRestrictedMessage = true;
                    notificationService.notices.push(notificationMessages.restrictedMessage);
                }
            }
        };

        var maxTurnoverLimitStatus = function maxTurnoverLimitStatus(get_self_exclusion) {
            var maxTurnoverLimitSet = get_self_exclusion.hasOwnProperty("max_30day_turnover");
            if (isIom && !maxTurnoverLimitSet && !appStateService.hasMaxTurnoverMessage) {
                appStateService.hasMaxTurnoverMessage = true;
                notificationService.notices.push(notificationMessages.maxTurnoverLimitNotSetMessage);
            } else if (isIom && maxTurnoverLimitSet && appStateService.hasMaxTurnoverMessage) {
                // in update of self exclusion
                reload();
            }
        };

        var residenceStatus = function residenceStatus(get_settings) {
            var countryCode = get_settings.country_code;
            if (countryCode == null && appStateService.virtuality && !appStateService.hasCountryMessage) {
                appStateService.hasCountryMessage = true;
                notificationService.notices.push(notificationMessages.countryNotSetMessage);
            }
        };

        var currencyStatus = function currencyStatus(currency) {
            if (currency === "" || currency === null || _.trim(currency).length === 0) {
                //    user has no currency
                if (!appStateService.hasCurrencyMessage) {
                    appStateService.hasCurrencyMessage = true;
                    notificationService.notices.push(notificationMessages.currencyNotSetMessage);
                }
            }
        };

        $scope.$on("get_account_status", function (e, get_account_status) {
            if (get_account_status.hasOwnProperty("status")) {
                status = get_account_status.status;
                authenticateStatus(get_account_status.prompt_client_to_authenticate);
                taxInformationStatus(status);
                ageVerificationStatus(status);
                unwelcomeStatus(status);
                cashierStatus(status);
                withdrawalStatus(status);
                websocketService.sendRequestFor.mt5LoginList();
            }
        });

        // get terms and onditions
        $scope.$on("get_settings", function (e, get_settings) {
            if (get_settings) {
                clientTncStatus = get_settings.client_tnc_status;
                termsAndConditionsStatus();
                residenceStatus(get_settings);
            }
        });

        $scope.$on('website_status', function (e, website_status) {
            if (website_status && websiteTncStatus !== website_status.terms_conditions_version) {
                websiteTncStatus = website_status.terms_conditions_version;
                termsAndConditionsStatus();
            }
        });

        $scope.$on("get-self-exclusion", function (e, get_self_exclusion) {
            maxTurnoverLimitStatus(get_self_exclusion);
        });

        //  reload on update
        $scope.$on("set-settings", function (e, response) {
            reload();
        });

        $scope.$on("tnc_approval", function (e, tnc_approval) {
            if (tnc_approval === 1) {
                reload();
            }
        });

        $scope.$on("set_financial_assessment:success", function (e, set_financial_assessment) {
            reload();
        });

        $scope.$on("currency:changed", function () {
            reload();
        });

        var reload = function reload() {
            appStateService.hasAuthenticateMessage = false;
            appStateService.hasRestrictedMessage = false;
            appStateService.hasMaxTurnoverMessage = false;
            appStateService.hasCountryMessage = false;
            appStateService.hasTnCMessage = false;
            appStateService.hasTaxInfoMessage = false;
            appStateService.hasRiskAssessmentMessage = false;
            appStateService.hasAgeVerificationMessage = false;
            appStateService.hasCurrencyMessage = false;
            appStateService.checkedAccountStatus = false;
            notificationService.emptyNotices();
            init();
        };
    }
})();
"use strict";

/**
 * @name Check User Status directive
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 02/15/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.check-user-status.directives").directive("bgCheckUserStatus", CheckUserStatus);

    function CheckUserStatus() {
        var directive = {
            restrict: "E",
            templateUrl: "js/share/components/check-user-status/check-user-status.template.html",
            controller: "CheckUserStatusController",
            controllerAs: "vm",
            bindToController: true,
            scope: {}
        };
        return directive;
    }
})();
"use strict";

/**
 * @name Connection Lost Controller
 * @author Morteza Tavanarad
 * @contributors []
 * @since 12/19/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.connectivity.controllers").controller("ConnectionLostController", ConnectionLost);

    ConnectionLost.$inject = ["$scope"];

    function ConnectionLost($scope) {
        var vm = this;

        vm.showMessage = false;

        $scope.$on("connection:ready", function (e) {
            $scope.$applyAsync(function () {
                vm.showMessage = false;
            });
        });

        $scope.$on("connection:error", function (e, isSSLFailed) {
            $scope.$applyAsync(function () {
                vm.showMessage = true;

                if (isSSLFailed) {
                    vm.message = 'app.ssl_cert_failed';
                } else {
                    vm.message = 'app.connection_error';
                }
            });
        });
    }
})();
"use strict";

/**
 * @name Connection Lost directive
 * @author Morteza Tavanarad
 * @contributors []
 * @since 12/19/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.connectivity.directives").directive("bgConnectionLost", ConnectionLost);

    function ConnectionLost() {
        var directive = {
            restrict: "E",
            templateUrl: "js/share/components/connectivity/connection-lost.template.html",
            controller: "ConnectionLostController",
            controllerAs: "vm",
            scope: {}
        };

        return directive;
    }
})();
"use strict";

/**
 * @name Connectivity Controller
 * @author Morteza Tavanarad
 * @contributors []
 * @since 10/22/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.connectivity.controllers").controller("ConnectivityController", Connectivity);

    Connectivity.$inject = ["$scope", "$state", "$cordovaNetwork", "$ionicPlatform"];

    function Connectivity($scope, $state, $cordovaNetwork, $ionicPlatform) {
        var vm = this;

        vm.isOffline = function () {
            if (ionic.Platform.isWebView()) {
                return !$cordovaNetwork.isOnline();
            }
            return !navigator.onLine;
        };

        vm.isOnline = function () {
            if (ionic.Platform.isWebView()) {
                return $cordovaNetwork.isOnline();
            }
            return navigator.onLine;
        };

        function startWatchingNetwork() {
            if (ionic.Platform.isWebView()) {
                $scope.$on("$cordovaNetwork:online", function (e, networkState) {
                    $state.go("home");
                });

                $scope.$on("$cordovaNetwork:offline", function (e, netwrorkState) {
                    $state.go("no-connection");
                });
            } else {
                window.addEventListener("online", function (e) {
                    $state.go("home");
                }, false);

                window.addEventListener("offline", function (e) {
                    $state.go("no-connection");
                }, false);
            }
        }

        function init() {
            startWatchingNetwork();
        }

        $ionicPlatform.ready(function () {
            init();

            $scope.$on("$stateChangeSuccess", function (e, current) {
                if (!vm.isOnline()) {
                    $state.go("no-connection");
                }
            });
        });
    }
})();
"use strict";

/**
 * @name Connectivity Directive
 * @author Morteza Tavanarad
 * @contributors []
 * @since 10/22/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.connectivity.directives").directive("bgConnectivity", Connectivity);

    function Connectivity() {
        var directive = {
            restrict: "E",
            controller: "ConnectivityController",
            controllerAs: "vm",
            bindToController: true,
            scope: {}
        };

        return directive;
    }
})();
"use strict";

/**
 * @name header controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/08/2016
 * @copyright Binary Ltd
 * Application Header
 */

(function () {
    angular.module("binary.share.components").controller("HeaderController", Header);

    Header.$inject = ["$scope", "$state", "$ionicHistory", "$ionicSideMenuDelegate", "appStateService", "clientService"];

    function Header($scope, $state, $ionicHistory, $ionicSideMenuDelegate, appStateService, clientService) {
        var vm = this;
        vm.hideMenuButton = false;
        vm.hideBalance = false;
        vm.disableMenuButton = false;
        vm.disableBackButton = false;
        vm.showBack = false;
        $ionicSideMenuDelegate.canDragContent(false);
        $ionicHistory.backView(null);
        vm.ios = ionic.Platform.isIOS();
        vm.android = ionic.Platform.isAndroid();
        vm.isMaltainvest = appStateService.isMaltainvest;

        vm.toggleSideMenu = function () {
            if (appStateService.tradeMode || !appStateService.purchaseMode) {
                $ionicSideMenuDelegate.toggleLeft();
            }
        };

        $scope.$watch(function () {
            return appStateService.purchaseMode;
        }, function () {
            vm.disableMenuButton = appStateService.purchaseMode;
        });

        $scope.$watch(function () {
            return appStateService.passwordChanged;
        }, function () {
            vm.disableBackButton = appStateService.passwordChanged;
        });

        $scope.$on("$stateChangeSuccess", function (ev, to, toParams, from, fromParams) {
            vm.to = to;
            vm.from = from;
            vm.hideBalance = false;
            if (["transaction-detail", "language", "profile", "self-exclusion", "change-password", "trading-times", "asset-index", "limits", "financial-assessment", "terms-and-conditions", "authentication"].indexOf(vm.to.name) > -1) {
                vm.hideMenuButton = true;
                vm.showBack = true;
            } else if (["mt5-web"].indexOf(vm.to.name) > -1) {
                vm.hideBalance = true;
            } else if (["contact"].indexOf(vm.to.name) > -1) {
                if (["authentication", "notifications"].indexOf(vm.from.name) > -1) {
                    vm.hideMenuButton = true;
                    vm.showBack = true;
                } else {
                    vm.hideMenuButton = false;
                    vm.showBack = false;
                }
            } else if (["real-account-opening", "maltainvest-account-opening"].indexOf(vm.to.name) > -1 && appStateService.redirectedFromAccountsManagemenet) {
                if (["accounts-management"].indexOf(vm.from.name) > -1) {
                    vm.hideMenuButton = true;
                    vm.showBack = true;
                }
            } else {
                if (vm.from.name === "statement" && vm.to.name !== "transaction-detail" && document.getElementsByClassName("reality-check").length > 0) {
                    $(".popup-container").addClass("popup-showing");
                    $("body").addClass("popup-open");
                    $(".backdrop").addClass("visible");
                }
                vm.hideMenuButton = false;
                vm.showBack = false;
                if (vm.from.name === "profit-table") {
                    appStateService.isProfitTableSet = false;
                }
                if (vm.from.name === "statement") {
                    appStateService.isStatementSet = false;
                }
            }
        });

        $scope.$on('authorize', function (e, authorize) {
            if (authorize) {
                vm.isMaltainvest = clientService.isLandingCompanyOf('maltainvest', authorize.landing_company_name);
            }
        });

        // back button function
        vm.goToPrevPage = function () {
            if (vm.to.detailed) {
                $state.go("trade");
            } else {
                $state.go(vm.from);
                if (vm.to.name === 'real-account-opening' || vm.to.name === 'maltainvest-account-opening') {
                    appStateService.selectedCurrency = false;
                    appStateService.redirectedFromAccountsManagemenet = false;
                }
            }
        };
    }
})();
"use strict";

/**
 * @name header directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/07/2016
 * @copyright Binary Ltd
 * Application Header
 */

(function () {
    angular.module("binary.share.components").directive("bgHeader", Header);

    function Header() {
        var directive = {
            link: link,
            templateUrl: "js/share/components/header/header.template.html",
            retrict: "A",
            controller: "HeaderController",
            controllerAs: "vm",
            bindToController: true,
            scope: {
                spinLogo: "="
            }
        };

        function link() {}

        return directive;
    }
})();
'use strict';

/**
 * @name iOS PWA Prompt Controller
 * @author Morteza Tavanarad
 * @contributors []
 * @since 03/11/2018
 * @copyright Binary Ltd
 */

(function () {
    angular.module('binary.share.components.ios-pwa-prompt.controllers').controller('IosPwaPromptController', PWAPrompt);

    PWAPrompt.$inject = ['$scope', '$translate', 'alertService'];

    function PWAPrompt($scope, $translate, alertService) {

        var vm = this;
        vm.icon = '<i class="icon ion-ios-upload-outline"></i>';

        vm.showPrompt = function () {
            $translate(['ios-pwa-prompt.title', 'ios-pwa-prompt.close']).then(function (translation) {
                var popup = alertService.displayIOSPWAPrompt(translation['ios-pwa-prompt.title'], 'ios-paw-prompt', $scope, 'js/share/components/ios-pwa-prompt/ios-pwa-prompt.template.html', [{
                    text: translation['ios-pwa-prompt.close'],
                    type: 'button-default',
                    onTap: function onTap(e) {
                        popup.close();
                    }
                }]);
            });

            localStorage.setItem('lastSeenIOSPWAPrompt', new Date().getTime());
        };

        vm.checkToShowPrompt = function () {
            if (window.navigator.standalone) {
                return false;
            }

            var lastSeen = localStorage.getItem('lastSeenIOSPWAPrompt') || null;
            var diffDays = lastSeen ? (new Date().getTime() - lastSeen) / (86400 * 1000) : 0;
            var isApple = /IPHONE|IPAD|IPOD/i.test(navigator.appVersion);

            return isApple && isSafari() && (diffDays === 0 || diffDays >= 14);
        };

        vm.init = function () {
            if (vm.checkToShowPrompt()) {
                vm.showPrompt();
            }
        };

        vm.init();

        function isSafari() {
            var ua = window.navigator.userAgent;

            var isNotSafari = /chrome|ucbrowser|fxios|crios/i.test(ua);

            if (!isNotSafari && /safari/i.test(ua)) {
                return true;
            }

            return false;
        }
    }
})();
'use strict';

/**
 * @name iOS PWA Prompt Directive
 * @author Morteza Tavanarad
 * @contributors []
 * @since 03/11/2018
 * @copyright Binary Ltd
 */

(function () {
    angular.module('binary.share.components.ios-pwa-prompt.directives').directive('iosPwaPrompt', PWAPrompt);

    function PWAPrompt() {
        var directive = {
            restrict: 'E',
            controller: 'IosPwaPromptController',
            controllerAs: 'vm',
            bindToController: true,
            scope: {}
        };

        return directive;
    }
})();
"use strict";

/**
 * @name language-list directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 10/13/2016
 * @copyright Binary Ltd
 * Application Header
 */

(function () {
    angular.module("binary.share.components.language.directives").directive("bgLanguageList", LanguageList);

    function LanguageList() {
        var directive = {
            restrict: "E",
            templateUrl: "js/share/components/language/language-list.template.html",
            controller: "LanguageController",
            controllerAs: "vm",
            scope: {}
        };

        return directive;
    }
})();
"use strict";

/**
 * @name language directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 * Application Header
 */

(function () {
    angular.module("binary.share.components.language.controllers").controller("LanguageController", Language);

    Language.$inject = ["$scope", "config", "languageService", "supportedLanguagesService", "websocketService", "appStateService"];

    function Language($scope, config, languageService, supportedLanguagesService, websocketService, appStateService) {
        var vm = this;
        vm.languages = [];
        vm.appSupportedLanguages = [];
        vm.languagesList = [];
        vm.isLanguageReady = false;
        vm.showSpinner = false;
        vm.ios = ionic.Platform.isIOS();
        vm.android = ionic.Platform.isAndroid();

        var init = function init() {
            var supportedLanguages = supportedLanguagesService.supportedLanguages;
            vm.appSupportedLanguages = config.appSupportedLanguages;
            _.forEach(vm.appSupportedLanguages, function (value) {
                vm.value = value.toUpperCase();
                if (supportedLanguages.indexOf(vm.value) > -1) {
                    var LanguageCode = vm.value.toLowerCase();
                    var languageNativeName = languageService.getLanguageNativeName(LanguageCode);
                    vm.languages.push({
                        id: LanguageCode,
                        title: languageNativeName
                    });
                }
            });

            if (vm.languages.length) {
                vm.isLanguageReady = true;
                appStateService.isLanguageReady = true;
            }
        };

        $scope.$on('authorize', function (e, authorize) {
            vm.showSpinner = false;
        });

        $scope.$on('supported_languages', init);

        vm.language = languageService.read();

        vm.changeLanguage = function (language) {
            vm.language = language || vm.language;
            languageService.update(vm.language);
            vm.showSpinner = true;
        };

        init();
    }
})();
"use strict";

/**
 * @name language directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 * Application Header
 */

(function () {
    angular.module("binary.share.components.language.directives").directive("language", Language);

    function Language() {
        var directive = {
            restrict: "E",
            templateUrl: "js/share/components/language/language.template.html",
            controller: "LanguageController",
            controllerAs: "vm",
            scope: {},
            bindToController: true
        };

        return directive;
    }
})();
"use strict";

/**
 * @name logout controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/15/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.logout.controllers").controller("LogoutController", Logout);

    Logout.$inject = ["websocketService", "alertService"];

    function Logout(websocketService, alertService) {
        var vm = this;
        vm.logout = function (res) {
            alertService.confirmRemoveAllAccount(function (res) {
                if (typeof res !== "boolean") {
                    if (res === 1) res = true;else res = false;
                }

                if (res) {
                    websocketService.logout();
                }
            });
        };
    }
})();
"use strict";

/**
 * @name logout directive
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.logout.directives").directive("bgLogout", Logout);

    function Logout() {
        var directive = {
            restrict: "E",
            templateUrl: "js/share/components/logout/logout.template.html",
            controller: "LogoutController",
            controllerAs: "vm",
            bindToController: true,
            scope: {}
        };
        return directive;
    }
})();
"use strict";

(function () {
    angular.module("binary.share.components.long-press.directives").directive("onLongPress", LongPress);

    LongPress.$inject = ["$timeout", "$interval"];

    function LongPress($timeout, $interval) {
        var directive = {
            restrict: "A",
            link: link
        };

        function link(scope, elm, attrs) {
            var timer = 0;
            var interval = attrs.interval ? Number(attrs.interval) : 300;
            scope.longPress = false;

            var startPress = function startPress(evt) {
                evt.stopPropagation();
                evt.preventDefault();
                // Locally scoped variable that will keep track of the long press
                scope.longPress = true;

                if (attrs.repetitive && attrs.repetitive === "true") {
                    // run the function befor repeating in the interval
                    scope.$eval(attrs.onLongPress);

                    timer = $interval(function () {
                        if (scope.longPress) {
                            // If the touchend event hasn't fired,
                            // apply the function given in on the element's on-long-press attribute
                            scope.$eval(attrs.onLongPress);
                        }
                    }, interval);
                } else {
                    // We'll set a timeout for 600 ms for a long press
                    timer = $timeout(function () {
                        if (scope.longPress) {
                            // If the touchend event hasn't fired,
                            // apply the function given in on the element's on-long-press attribute
                            scope.$eval(attrs.onLongPress);
                        }
                    }, interval);
                }
            };

            var endPress = function endPress(evt) {
                // Prevent the onLongPress event from firing
                scope.longPress = false;

                if (attrs.repetitive && attrs.repetitive === "true") {
                    $interval.cancel(timer);
                } else {
                    $timeout.cancel(timer);
                }

                timer = undefined;

                // If there is an on-touch-end function attached to this element, apply it
                if (attrs.onTouchEnd) {
                    scope.$apply(function () {
                        scope.$eval(attrs.onTouchEnd);
                    });
                }
            };

            elm.bind("touchstart", startPress);
            elm.bind("touchend", endPress);
            elm.bind("mousedown", startPress);
            elm.bind("mouseup", endPress);
        }

        return directive;
    }
})();
"use strict";

/**
 * @name Notification Icon controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 05/03/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.notification-icon.controllers").controller("NotificationIconController", NotificationIcon);

    NotificationIcon.$inject = ["$scope", "$state", "$ionicHistory", "notificationService", "appStateService"];

    function NotificationIcon($scope, $state, $ionicHistory, notificationService, appStateService) {
        var vm = this;
        $scope.$watch(function () {
            return notificationService.notices;
        }, function () {
            vm.notices = notificationService.notices;
        });

        $scope.$watch(function () {
            return appStateService.purchaseMode;
        }, function () {
            vm.disableMenuButton = appStateService.purchaseMode;
        });

        vm.goToNotifications = function () {
            if ($state.current.name === "notifications") {
                $ionicHistory.goBack();
            } else {
                $state.go("notifications");
            }
        };
    }
})();
"use strict";

/**
 * @name Notification Icon directive
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 05/03/2017
 * @copyright Binary Ltd
 * Application NotificationIcon
 */

(function () {
    angular.module("binary.share.components.notification-icon.directives").directive("bgNotificationIcon", NotificationIcon);

    function NotificationIcon() {
        var directive = {
            restrict: "E",
            templateUrl: "js/share/components/notification-icon/notification-icon.template.html",
            controller: "NotificationIconController",
            controllerAs: "vm",
            scope: {},
            bindToController: true
        };

        return directive;
    }
})();
"use strict";

/**
 * @name number directive
 * @author Morteza Tavanarad
 * @contributors []
 * @since 12/02/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.number.directives").directive("bgNumber", BgNumber);

    function BgNumber() {
        var directive = {
            restrict: "A",
            require: "?ngModel",
            link: link
        };

        function link(scope, element, attrs, ngModel) {
            if (ngModel) {
                // remove all default angular's validator for input[number]
                ngModel.$formatters = [];
                ngModel.$parsers = [];

                ngModel.$formatters.push(function (modelValue) {
                    if (ngModel.$isEmpty(modelValue)) {
                        return null;
                    }
                    return modelValue;
                });

                ngModel.$parsers.push(function (viewValue) {
                    if (ngModel.$isEmpty(viewValue)) {
                        return null;
                    }
                    return viewValue;
                });
            }
        }

        return directive;
    }
})();
"use strict";

/**
 * @name ping controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 * Application Header
 */

(function () {
    angular.module("binary.share.components.ping.controllers").controller("PingController", Ping);

    Ping.$inject = ["$timeout", "appStateService", "websocketService"];

    function Ping($timeout, appStateService, websocketService) {
        function init() {
            ping();
        }

        function ping() {
            if (appStateService.isLoggedin) {
                websocketService.sendRequestFor.ping();
            }

            $timeout(ping, 60000);
        }

        init();
    }
})();
"use strict";

/**
 * @name ping directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 * Application Header
 */

(function () {
    angular.module("binary.share.components.ping.directives").directive("ping", Ping);

    function Ping() {
        var directive = {
            restrict: "E",
            controller: "PingController",
            controllerAs: "vm",
            scope: {}
        };

        return directive;
    }
})();
"use strict";

/**
 * @name reality-check controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.reality-check.controllers").controller("RealityCheckController", RealityCheck);

    RealityCheck.$inject = ["$scope", "$timeout", "$translate", "$state", "websocketService", "appStateService", "alertService"];

    function RealityCheck($scope, $timeout, $translate, $state, websocketService, appStateService, alertService) {
        var vm = this;
        var landingCompanyName = void 0;
        vm.integerError = false;

        var setInSessions = function setInSessions(key, val) {
            return sessionStorage.setItem(key, val);
        };
        var getFromSessions = function getFromSessions(key) {
            return sessionStorage.getItem(key);
        };
        var removeFromSessions = function removeFromSessions(key) {
            return sessionStorage.removeItem(key);
        };

        var hasRealityCheck = function hasRealityCheck() {
            // if not asked the interval from user and the start time of reality check popups are not set in sessionStorage
            if (!appStateService.isRealityChecked && _.isEmpty(sessionStorage._interval) === true) {
                realityCheck();
            } else if (!appStateService.isRealityChecked && !_.isEmpty(sessionStorage.start)) {
                // if not asked the interval from user and the start time of reality check popups are set in sessionStorage
                // happens when user refresh the browser
                appStateService.isRealityChecked = true;
                // calculate the difference between time of last popup and current time
                var timeGap = getFromSessions("start");
                var thisTime = new Date().getTime();
                // if the difference above is smaller than the interval set the period for popup timeout to remained time
                if (getFromSessions("_interval") * 60000 - (thisTime - timeGap) > 0) {
                    var period = getFromSessions("_interval") * 60000 - (thisTime - timeGap);
                    vm.realityCheckTimeout = $timeout(getRealityCheck, period);
                }
            } else if (!_.isEmpty(sessionStorage._interval)) {
                // if user did not refresh the app and the interval is set
                var _period = getFromSessions("_interval") * 60000;
                vm.realityCheckTimeout = $timeout(getRealityCheck, _period);
            }
        };

        var makePopupHidden = function makePopupHidden() {
            $(".popup-container").removeClass("popup-showing");
            $("body").removeClass("popup-open");
            $(".backdrop").removeClass("visible");
        };

        $scope.$on("authorize", function (e, authorize) {
            vm.sessionLoginId = authorize.loginid;
            if (!appStateService.realityCheckLogin) {
                appStateService.realityCheckLogin = true;
                // check if user is not already authorized, account is real money account  & is not changed in app
                if (!appStateService.isRealityChecked && authorize.is_virtual === 0 && !appStateService.isChangedAccount) {
                    landingCompanyName = authorize.landing_company_name;
                    websocketService.sendRequestFor.landingCompanyDetails(landingCompanyName);
                } else if (appStateService.isRealityChecked && appStateService.isChangedAccount && authorize.is_virtual === 1) {
                    // check if user is already authorized, account changed and is virtual money account
                    $timeout.cancel(vm.realityCheckTimeout);
                    appStateService.isChangedAccount = false;
                    appStateService.isRealityChecked = true;
                    if (!_.isEmpty(sessionStorage.realityCheckStart)) {
                        removeFromSessions('realityCheckStart');
                    }
                    if (!_.isEmpty(sessionStorage.start)) {
                        removeFromSessions('start');
                    }
                } else if (appStateService.isRealityChecked && appStateService.isChangedAccount && authorize.is_virtual === 0) {
                    // check if account is changed and is real money account
                    if (vm.realityCheckTimeout) {
                        $timeout.cancel(vm.realityCheckTimeout);
                    }
                    if (!_.isEmpty(sessionStorage.realityCheckStart)) {
                        removeFromSessions('realityCheckStart');
                    }
                    if (!_.isEmpty(sessionStorage.start)) {
                        removeFromSessions('start');
                    }
                    appStateService.isRealityChecked = false;
                    landingCompanyName = authorize.landing_company_name;
                    websocketService.sendRequestFor.landingCompanyDetails(landingCompanyName);
                    appStateService.isChangedAccount = false;
                } else if (!appStateService.isRealityChecked && appStateService.isChangedAccount && authorize.is_virtual === 0) {
                    if (vm.realityCheckTimeout) {
                        $timeout.cancel(vm.realityCheckTimeout);
                    }
                    if (!_.isEmpty(sessionStorage.realityCheckStart)) {
                        removeFromSessions('realityCheckStart');
                    }
                    if (!_.isEmpty(sessionStorage.start)) {
                        removeFromSessions('start');
                    }
                    appStateService.isRealityChecked = false;
                    landingCompanyName = authorize.landing_company_name;
                    websocketService.sendRequestFor.landingCompanyDetails(landingCompanyName);
                    appStateService.isChangedAccount = false;
                }
            }
        });

        $scope.$on("landing_company_details", function (e, landingCompanyDetails) {
            if (landingCompanyDetails.has_reality_check === 1) hasRealityCheck();
        });

        var realityCheck = function realityCheck() {
            appStateService.isRealityChecked = true;
            vm.data = {};
            vm.data.interval = 60;
            if (!appStateService.isPopupOpen) {
                appStateService.isPopupOpen = true;
                alertService.displayRealitCheckInterval($translate.instant("reality-check.title"), "reality-check get-interval", $scope, "js/share/components/reality-check/interval-popup.template.html", [{
                    text: $translate.instant("reality-check.continue"),
                    type: "button-positive",
                    onTap: function onTap(e) {
                        if (vm.data.interval <= 60 && vm.data.interval >= 10 && !vm.integerError) {
                            setInSessions('_interval', vm.data.interval);
                            vm.data.start_interval = new Date().getTime();
                            setInSessions('start', vm.data.start_interval);
                            hasRealityCheck();
                            appStateService.isPopupOpen = false;
                            setInSessions("realityCheckStart", Date.now());
                        } else {
                            e.preventDefault();
                        }
                    }
                }]);
            }
        };

        var getLastInterval = function getLastInterval() {
            removeFromSessions("_interval");
            setInSessions('_interval', vm.data.interval);
        };

        $scope.$on("reality_check", function (e, reality_check) {
            alertRealityCheck(reality_check);
        });

        var getRealityCheck = function getRealityCheck() {
            return websocketService.sendRequestFor.realityCheck();
        };

        var sessionTime = function sessionTime() {
            vm.realityCheckItems.start_time = getFromSessions('realityCheckStart');
            vm.now = Date.now();
            var duration = vm.now - vm.realityCheckItems.start_time;
            vm.realityCheckItems.days = Math.floor(duration / 864e5);
            var hour = duration - vm.realityCheckItems.days * 864e5;
            vm.realityCheckItems.hours = Math.floor(hour / 36e5);
            var min = duration - (vm.realityCheckItems.days * 864e5 + vm.realityCheckItems.hours * 36e5);
            vm.realityCheckItems.minutes = Math.floor(min / 60000);
        };

        vm.logout = function () {
            alertService.confirmRemoveAllAccount(function (res) {
                if (typeof res !== "boolean") {
                    if (res === 1) res = true;else res = false;
                }
                if (res) {
                    websocketService.logout();
                } else {
                    appStateService.isPopupOpen = false;
                    hasRealityCheck();
                }
            });
        };

        var alertRealityCheck = function alertRealityCheck(reality_check) {
            removeFromSessions("start");
            vm.realityCheckItems = reality_check;
            if (vm.sessionLoginId === vm.realityCheckItems.loginid && !appStateService.isPopupOpen) {
                sessionTime();
                vm.data = {};
                vm.data.interval = parseInt(getFromSessions("_interval"));
                $timeout.cancel(vm.realityCheckTimeout);
                appStateService.isPopupOpen = true;
                alertService.displayRealityCheckResult($translate.instant("reality-check.title"), "reality-check result-popup", $scope, "js/share/components/reality-check/reality-check-result.template.html", [{
                    text: $translate.instant("reality-check.logout"),
                    type: "button-secondary",
                    onTap: function onTap() {
                        vm.logout();
                    }
                }, {
                    text: $translate.instant("reality-check.view_statement"),
                    type: "button-positive",
                    onTap: function onTap(e) {
                        $state.go("statement");
                        makePopupHidden();
                        e.preventDefault();
                    }
                }, {
                    text: $translate.instant("reality-check.continue"),
                    type: "button-positive",
                    onTap: function onTap(e) {
                        if (vm.data.interval <= 60 && vm.data.interval >= 10 && !vm.integerError) {
                            if (vm.sessionLoginId === vm.realityCheckItems.loginid) {
                                getLastInterval(vm.data.interval);
                                vm.data.start_interval = new Date().getTime();
                                setInSessions('start', vm.data.start_interval);
                                hasRealityCheck();
                                appStateService.isPopupOpen = false;
                            }
                        } else {
                            e.preventDefault();
                        }
                    }
                }]);
            }
        };

        $scope.$watch("vm.data.interval", function () {
            vm.integerError = appStateService.isPopupOpen && !(Math.floor(vm.data.interval) === vm.data.interval && $.isNumeric(vm.data.interval));
        });
    }
})();
"use strict";

/**
 * @name reality-check directive
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.reality-check.directives").directive("bgRealityCheck", RealityCheck);

    function RealityCheck() {
        var directive = {
            restrict: "E",
            templateUrl: "js/share/components/reality-check/reality-check.template.html",
            controller: "RealityCheckController",
            controllerAs: "vm",
            bindToController: true,
            scope: {}
        };
        return directive;
    }
})();
"use strict";

/**
 * @name bgRegexValidate directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 11/02/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.regex-validate.directives").directive("bgRegexValidate", Validate);

    function Validate() {
        var directive = {
            restrict: "A",
            link: link,
            require: "ngModel",
            scope: {
                regex: "=bgRegexValidate"
            }
        };

        return directive;

        function link(scope, elements, attrs, ngModel) {
            scope.$watch(function () {
                return ngModel.$viewValue;
            }, function (newVal, oldVal) {
                if (_.isEmpty(scope.regex) || _.isEmpty(ngModel.$viewValue)) {
                    return;
                }

                var regex = RegExp(scope.regex);

                if (!regex.test(ngModel.$viewValue)) {
                    ngModel.$setViewValue(oldVal);
                    ngModel.$render();
                } else {
                    ngModel.$setViewValue(regex.exec(ngModel.$viewValue)[0]);
                    ngModel.$render();
                }
            });
        }
    }
})();
"use strict";

/**
 * @name Service Outage Page Controller
 * @author Morteza Tavanarad
 * @contributors []
 * @since 05/06/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.service-outage.controllers").controller("ServiceOutagePageController", ServiceOutage);

    ServiceOutage.$inject = ["$stateParams"];

    function ServiceOutage($stateParams) {
        var vm = this;

        vm.message = $stateParams.message;
    }
})();
"use strict";

/**
 * @name Service Outage Controller
 * @author Morteza Tavanarad
 * @contributors []
 * @since 05/06/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.service-outage.controllers").controller("ServiceOutageController", ServiceOutage);

    ServiceOutage.$inject = ["$scope", "$state", "appStateService", "websocketService"];

    function ServiceOutage($scope, $state, appStateService, websocketService) {
        $scope.$on("website_status", function (e, message) {
            if (message.site_status && message.site_status === "up" && appStateService.siteStatus === "down") {
                appStateService.siteStatus = message.site_status;
                $state.go("trade");
            } else if (message.site_status && message.site_status === "down") {
                appStateService.siteStatus = message.site_status;
                $state.go("outage", { message: message.message });
            }
        });

        $scope.$on("$stateChangeStart", function (e, toState, toParams, fromState, fromParams, options) {
            if (appStateService.siteStatus === "down") {
                if (fromState.name === "outage" || toState.name !== "outage") {
                    e.preventDefault();
                }
            }
        });

        init();

        function init() {
            websocketService.sendRequestFor.websiteStatus(true);
        }
    }
})();
"use strict";

/**
 * @name Service Outage directive
 * @author Morteza Tavanarad
 * @contributors []
 * @since 05/06/2017
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.service-outage.directives").directive("bgServiceOutage", ServiceOutage);

    function ServiceOutage() {
        var directive = {
            restrict: "E",
            scope: {},
            controller: "ServiceOutageController"
        };

        return directive;
    }
})();
"use strict";

/**
 * @name side-menu directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/08/2016
 * @copyright Binary Ltd
 * Application Side Menu
 */

(function () {
    angular.module("binary.share.components").directive("bgSideMenu", SideMenu);

    function SideMenu() {
        var directive = {
            link: link,
            templateUrl: "js/share/components/side-menu/side-menu.template.html",
            retrict: "A",
            scope: {}
        };

        function link() {}

        return directive;
    }
})();
"use strict";

/**
 * @name spinner-logo controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/17/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.spinner-logo.controllers").controller("SpinnerLogoController", SpinnerLogo);

    SpinnerLogo.$inject = ["$scope"];

    function SpinnerLogo($scope) {
        var vm = this;
        vm.start = false;

        $scope.$on("spinner-logo:start", function () {
            vm.start = true;
        });

        $scope.$on("spinner-logo:stop", function () {
            vm.start = false;
        });
    }
})();
"use strict";

/**
 * @name spinner-logo direcvtive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/17/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.spinner-logo.directives").directive("bgSpinnerLogo", SpinnerLogo);

    function SpinnerLogo() {
        var directive = {
            restrict: "E",
            templateUrl: "js/share/components/spinner-logo/spinner-logo.template.html",
            replace: true,
            controller: "SpinnerLogoController",
            controllerAs: "vm",
            bindToController: true,
            scope: {}
        };

        return directive;
    }
})();
"use strict";

/**
 * @name updater module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 12/20/2015
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.updater.controllers").controller("UpdaterController", Updater);

    Updater.$inject = ["$ionicPlatform"];

    function Updater($ionicPlatform) {
        $ionicPlatform.ready(function () {
            if (window.codePush) {
                window.codePush.sync();
            }
        });
    }
})();
"use strict";

/**
 * @name updater directive
 * @author Morteza Tavanarad
 * @contributors []
 * @since 12/26/2015
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.share.components.updater.directives").directive("bgUpdater", Updater);

    function Updater() {
        var directive = {
            restrict: "E",
            controller: "UpdaterController",
            controllerAs: "vm",
            scope: {}
        };

        return directive;
    }
})();
"use strict";

/**
 * @name Oauth Controller
 * @author Morteza Tavanarad
 * @contributors []
 * @since 8/13/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.signin.components.oauth").controller("OauthController", Oauth);

    Oauth.$inject = ["$scope", "$ionicLoading", "config", "websocketService", "alertService", "accountService", "languageService"];

    function Oauth($scope, $ionicLoading, config, websocketService, alertService, accountService, languageService) {
        var vm = this;

        var accounts = [];

        var authenticate = function authenticate(_token) {
            // Validate the token
            if (_token && _token.length === 32) {
                $ionicLoading.show();
                websocketService.authenticate(_token);
            } else {
                alertService.accountError.tokenNotValid();
            }
        };

        var handleUrl = function handleUrl(url) {
            accounts = getAccountsFromUrl(url);
            if (accounts.length > 0) {
                authenticate(accounts[0].token);
            }
        };

        window.onmessage = function (_message) {
            if (_message.data && _message.data.url) {
                handleUrl(_message.data.url);
            }
        };

        $scope.$on("authorize", function (e, response) {
            if (response) {
                var accountList = response.account_list;
                accounts.forEach(function (value, index) {
                    if (index > 0) {
                        var account = accounts[index];
                        account.email = response.email;
                        account.country = response.country;
                        if (accountList) {
                            var acc = _.find(accountList, function (a) {
                                return a.loginid === account.loginid;
                            });
                            account = _.assign(account, acc);
                        }
                        accountService.add(account);
                    }
                });
            }
            $ionicLoading.hide();
        });

        vm.init = function () {
            if (!_.isEmpty(vm.accountTokens)) {
                handleUrl(vm.accountTokens);
            }
        };

        vm.signin = function () {
            var serverUrl = localStorage.getItem('config.server_url');
            var oauthUrl = serverUrl ? "https://" + serverUrl + "/oauth2/authorize" : config.oauthUrl;
            var appId = localStorage.getItem('config.app_id') || config.app_id;
            var oauthWindowUrl = oauthUrl + "?app_id=" + appId + "&l=" + languageService.read();

            var windowTarget = '_system';

            if (window.navigator.standalone) {
                windowTarget = '_self';
            }

            var authWindow = window.open(oauthWindowUrl, windowTarget, "location=no,toolbar=no");

            $(authWindow).on("loadstart", function (e) {
                var url = e.originalEvent.url;

                if (getErrorFromUrl(url).length > 0) {
                    authWindow.close();
                    return;
                }

                accounts = getAccountsFromUrl(url);
                if (accounts && accounts.length) {
                    authWindow.close();

                    authenticate(accounts[0].token);
                }
            });
        };

        function getAccountsFromUrl(_url) {
            var regex = /acct\d+=(\w+)&token\d+=(\w{2}-\w{29})(&cur\d+=(\w{2,3}))?/g;
            var result = null;
            var accounts = [];

            do {
                result = regex.exec(_url);
                if (result) {
                    accounts.push({
                        loginid: result[1],
                        token: result[2],
                        currency: result[4] ? result[4] : null
                    });
                }
            } while (result);
            return accounts;
        }

        function getErrorFromUrl(_url) {
            var regex = /error=(\w+)/g;
            var result = null;
            var error = [];

            do {
                result = regex.exec(_url);
                if (result) {
                    error.push(result[1]);
                }
            } while (result);

            return error;
        }

        vm.init();
    }
})();
"use strict";

/**
 * @name Oauth directive
 * @author Morteza Tavanarad
 * @contributors []
 * @since 8/13/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.signin.components.oauth").directive("oauth", Oauth);

    function Oauth() {
        var directive = {
            restrict: "E",
            scope: { accountTokens: "=" },
            templateUrl: "js/pages/sign-in/components/oauth/oauth.template.html",
            controller: "OauthController",
            controllerAs: "vm",
            bindToController: true
        };

        return directive;
    }
})();
"use strict";

/**
 * @name chart controller
 * @author Morteza Tavanarad
 * @contributors []
 * @since 08/29/2015
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.chart.controllers").controller("ChartController", Chart);

    Chart.$inject = ["$scope", "chartService", "websocketService", "proposalService"];

    function Chart($scope, chartService, websocketService, proposalService) {
        var vm = this;
        vm.addedContracts = [];

        $scope.$on("$destroy", function (e, value) {
            websocketService.sendRequestFor.forgetTicks();
            chartService.destroy();
        });

        $scope.$on("proposal:open-contract", function (e, contract, req_id) {
            if (contract && proposalService.openContractId === req_id) {
                var contractId = vm.purchasedContract.contractId;
                if (vm.addedContracts.indexOf(contractId) > -1) return;
                if (typeof contractId === "string" && !_.isEmpty(contractId) || contractId) {
                    if (contract.contract_id.toString() === contractId.toString()) {
                        vm.addedContracts.push(contractId);
                        chartService.addContract({
                            startTime: contract.date_start + 1,
                            duration: parseInt(vm.proposal.duration),
                            type: vm.proposal.tradeType === "Higher/Lower" ? contract.contract_type + "HL" : contract.contract_type,
                            selectedTick: vm.proposal.tradeType === "High/Low Ticks" ? vm.proposal.selected_tick : null,
                            barrier: vm.proposal.barrier
                        });
                    }
                }
            }
        });

        $scope.$on("tick", function (e, feed) {
            if (feed && feed.echo_req.ticks_history === vm.proposal.symbol) {
                chartService.historyInterface.addTick(feed.tick);
            } else {
                websocketService.sendRequestFor.forgetStream(feed.tick.id);
            }
        });

        $scope.$on("history", function (e, feed) {
            if (feed && feed.echo_req.ticks_history === vm.proposal.symbol) {
                chartService.historyInterface.addHistory(feed.history);
            }
        });

        $scope.$on("candles", function (e, feed) {
            if (feed) {
                chartService.historyInterface.addCandles(feed.candles);
            }
        });

        $scope.$on("ohlc", function (e, feed) {
            if (feed) {
                chartService.historyInterface.addOhlc(feed.ohlc);
            }
        });

        $scope.$on("connection:ready", function (e) {
            sendTickHistoryRequest();
        });

        $scope.$watch(function () {
            return vm.proposal.symbol;
        }, function (newValue, oldValue) {
            if (vm.proposal.symbol) {
                // && newValue !== oldValue){
                sendTickHistoryRequest();
            }
        });

        function init() {
            var chartId = "tradeChart";

            vm.chartDragLeft = chartService.dragLeft;
            vm.chartDragRight = chartService.dragRight;
            vm.chartTouch = chartService.dragStart;
            vm.chartRelease = chartService.dragEnd;
            vm.chartPinchIn = chartService.zoomOut;
            vm.chartPinchOut = chartService.zoomIn;
            vm.chartPinchStart = chartService.zoomStart;
            vm.chartPinchEnd = chartService.zoomEnd;

            chartService.drawChart(chartId);
            sendTickHistoryRequest();
        }

        function sendTickHistoryRequest() {
            if (_.isEmpty(vm.proposal.symbol)) {
                return;
            }

            var symbol = vm.proposal.symbol;
            websocketService.sendRequestFor.forgetTicks();
            websocketService.sendRequestFor.ticksHistory({
                ticks_history: symbol,
                end: "latest",
                count: chartService.getCapacity(),
                subscribe: 1
            });
        }

        init();
    }
})();
"use strict";

/**
 * @name chart directive
 * @author Morteza Tavanarad
 * @contributors []
 * @since 08/29/2015
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.chart.directives").directive("bgChart", Chart);

    function Chart() {
        var directive = {
            restrict: "E",
            templateUrl: "js/pages/trade/components/chart/chart.template.html",
            controller: "ChartController",
            controllerAs: "vm",
            bindToController: true,
            scope: {
                proposal: "=",
                purchasedContract: "="
            }
        };

        return directive;
    }
})();
"use strict";

/**
 * @name digit-result controller
 * @author Morteza Tavanarad
 * @contributors []
 * @since 10/01/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.chart.controllers").controller("DigitResultController", Result);

    Result.$inject = ["$scope"];

    function Result($scope) {
        var vm = this;

        vm.spots = [];
        vm.reset = true;
        vm.counter = 0;

        $scope.$on("contract:spot", function (e, contract, lastPrice) {
            if (vm.reset) {
                // vm.spots = new Array(contract.duration+1).fill().map((e, i) => { return {}});
                vm.spots = new Array(contract.duration + 1);
                for (var i = 0; i < vm.spots.length; i++) {
                    vm.spots[i] = {};
                }
                vm.reset = false;
                vm.counter = 0;
            }

            var localContract = _.clone(contract);

            $scope.$applyAsync(function () {
                vm.spots[vm.counter++] = {
                    result: localContract.result,
                    value: lastPrice.toString().slice(-1)
                };
            });
        });

        $scope.$on("contract:finished", function (e, contract) {
            vm.reset = true;
        });
    }
})();
"use strict";

/**
 * @name digit-result directive
 * @author Morteza Tavanarad
 * @contributors []
 * @since 10/01/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.chart.directives").directive("bgDigitResult", Result);

    function Result() {
        var directive = {
            restrict: "E",
            templateUrl: "js/pages/trade/components/chart/digit-result.template.html",
            controller: "DigitResultController",
            controllerAs: "vm",
            bindToController: true,
            scope: {}
        };

        return directive;
    }
})();
"use strict";

/**
 * @name tick result controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 06/30/2018
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.chart.controllers").controller("TickResultController", TickResult);

    TickResult.$inject = ["$scope"];

    function TickResult($scope) {
        var vm = this;

        vm.spots = [];
        vm.reset = true;
        vm.counter = 0;
        vm.selectedTick = 0;

        $scope.$on("contract:spot", function (e, contract, lastPrice) {
            if (vm.reset) {
                vm.spots = new Array(contract.duration + 1);
                _.map(vm.spots, function (val, i) {
                    vm.spots[i] = {};
                });
                vm.reset = false;
                vm.counter = 0;
            }
            var localContract = _.clone(contract);

            $scope.$applyAsync(function () {
                vm.selectedTick = contract.selectedTick - 1;
                if (vm.counter < vm.spots.length) {
                    vm.spots[vm.counter++] = {
                        result: localContract.result,
                        value: lastPrice
                    };
                }
            });
        });

        $scope.$on("contract:finished", function (e, contract) {
            vm.reset = true;
        });
    }
})();
"use strict";

/**
 * @name tick result directive
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 06/30/2018
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.chart.directives").directive("bgTickResult", TickResult);

    function TickResult() {
        var directive = {
            restrict: "E",
            templateUrl: "js/pages/trade/components/chart/tick-result.template.html",
            controller: "TickResultController",
            controllerAs: "vm",
            bindToController: true,
            scope: {}
        };

        return directive;
    }
})();
"use strict";

/**
 * @name longcode controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 09/27/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.longcode.controllers").controller("LongcodeController", Longcode);

    function Longcode() {
        var vm = this;
    }
})();
"use strict";

/**
 * @name longcode direciive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 09/27/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.longcode.directives").directive("bgLongcode", Longcode);

    function Longcode() {
        var direciive = {
            restrict: "E",
            templateUrl: "js/pages/trade/components/longcode/longcode.template.html",
            controller: "LongcodeController",
            controllerAs: "vm",
            bindToController: true,
            scope: {
                purchasedContract: "="
            }
        };

        return direciive;
    }
})();
"use strict";

/**
 * @name barrier controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 09/19/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.options.controllers").controller("BarrierController", Barrier);

    Barrier.$inject = ['proposalService'];

    function Barrier(proposalService) {
        var vm = this;
        var pattern = /[+,-]\d+(\.\d{1,5})?|\d+(\.\d{1,5})?/;
        vm.regex = "^([+,-]?(\\d+)?(\\.)?\\d*)$";

        vm.changeBarrier = function () {
            proposalService.setPropertyValue('barrier', vm.proposal.barrier);
        };
    }
})();
"use strict";

/**
 * @name barrier directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 09/19/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.options.directives").directive("bgBarrier", Barrier);

    function Barrier() {
        var directive = {
            restrict: "E",
            templateUrl: "js/pages/trade/components/options/barrier.template.html",
            controller: "BarrierController",
            controllerAs: "vm",
            bindToController: true,
            scope: {
                proposal: "="
            }
        };

        return directive;
    }
})();
"use strict";

/**
 * @name digits controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/26/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.options.controllers").controller("DigitsController", Digits);

    Digits.$inject = [];

    function Digits() {
        var vm = this;

        vm.digits = [];

        vm.selectDigit = function (digit) {
            vm.select()(digit);
        };

        function init() {
            var tradeTypes = JSON.parse(sessionStorage.tradeTypes)[vm.tradeType];
            vm.digits = _.union(tradeTypes[0].last_digit_range, tradeTypes[1].last_digit_range);
        }

        init();
    }
})();
"use strict";

/**
 * @name digits directvie
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/26/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.options.directives").directive("bgDigits", Digits);

    function Digits() {
        var directive = {
            restrict: "E",
            templateUrl: "js/pages/trade/components/options/digits.template.html",
            controller: "DigitsController",
            controllerAs: "vm",
            bindToController: true,
            scope: {
                select: "&",
                tradeType: "="
            }
        };

        return directive;
    }
})();
"use strict";

/**
 * @name markets controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/20/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.options.controllers").controller("MarketsController", Markets);

    Markets.$inject = ["$scope", "websocketService"];

    function Markets($scope, websocketService) {
        var vm = this;
        vm.markets = {};

        function init() {
            if (_.isEmpty(sessionStorage.markets)) {
                setTimeout(init, 500);
                return;
            }

            $scope.$applyAsync(function () {
                vm.markets = JSON.parse(sessionStorage.markets);
            });
        }

        vm.selectMarket = function (market) {
            vm.select()(market);
        };

        init();
    }
})();
"use strict";

/**
 * @name markets directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/20/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.options.directives").directive("bgMarkets", Markets);

    function Markets() {
        var directive = {
            restrict: "E",
            templateUrl: "js/pages/trade/components/options/markets.template.html",
            controller: "MarketsController",
            controllerAs: "vm",
            bindToController: true,
            scope: {
                select: "&"
            }
        };

        return directive;
    }
})();
"use strict";

/**
 * @name markets controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/20/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.options.services").factory("marketsService", Markets);

    Markets.$inject = ["sessionStorageService"];

    function Markets(sessionStorageService) {
        var factory = {};
        var assetIndex = [];

        var ASSETINDEXES = {
            symbol: 0,
            displayName: 1,
            contracts: 2,
            contractName: 0,
            contractDisplayName: 1,
            contractFrom: 2,
            contractTo: 3
        };

        factory.getMarketByIndex = function (index) {
            if (!_.isEmpty(sessionStorage.markets)) {
                var markets = JSON.parse(sessionStorage.markets || null);
                var keys = Object.keys(markets);
                return markets[keys[index]];
            }
            return null;
        };

        factory.findTickMarkets = function () {
            var activeSymbols = JSON.parse(sessionStorageService.getItem("active_symbols"));
            assetIndex = JSON.parse(sessionStorageService.getItem("asset_index"));

            var markets = {};

            _.forEach(activeSymbols, function (value, key) {
                var underlying = [];

                value.forEach(function (v, i) {
                    if (isSupportTick(value[i].symbol)) {
                        underlying.push(value[i]);
                    }
                });

                if (underlying.length > 0) {
                    markets[key] = {
                        displayName: value[0].market_display_name,
                        underlying: underlying
                    };
                }
            });

            sessionStorage.markets = JSON.stringify(markets);

            return markets;
        };

        function isSupportTick(symbol) {
            var symbolIndex = _.findIndex(assetIndex, function (value) {
                return value[ASSETINDEXES.symbol] === symbol;
            });

            if (symbolIndex > -1) {
                var tickUnderlying = _.findIndex(assetIndex[symbolIndex][ASSETINDEXES.contracts], function (value) {
                    return value[ASSETINDEXES.contractFrom].indexOf("t") > -1;
                });

                return tickUnderlying > -1;
            }

            return false;
        }

        return factory;
    }
})();
"use strict";

/**
 * @name options controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/21/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.options.controllers").controller("OptionsController", Options);

    Options.$inject = ["$scope", "$ionicModal", "marketsService", "optionsService", "proposalService", "tradeService", "tradeTypesService", "websocketService", "appStateService"];

    function Options($scope, $ionicModal, marketsService, optionsService, proposalService, tradeService, tradeTypesService, websocketService, appStateService) {
        var vm = this;

        vm.showOptions = false;
        vm.marketsClosed = false;

        vm.SECTIONS = {
            OVERVIEW1: 0,
            OVERVIEW2: 1,
            UNDERLYINGS: 2,
            MARKETS: 3,
            TRADETYPES: 4,
            TICKS: 5,
            DIGITS: 6,
            SELECTEDTICK: 7
        };

        vm.options = {
            market: null,
            underlying: null,
            tradeType: null,
            tick: null,
            digit: null,
            selected_tick: null
        };

        vm.section1 = vm.SECTIONS.OVERVIEW1; // vm.options.market ? vm.SECTIONS.OVERVIEW : vm.SECTIONS.MARKETS;
        vm.section2 = vm.SECTIONS.OVERVIEW2;

        $scope.$on("symbols:updated", function (e, openMarkets) {
            if (_.isEmpty(openMarkets)) {
                vm.showOptions = false;
                vm.marketsClosed = true;
                vm.proposal = {};
            } else {
                vm.showOptions = true;
                websocketService.sendRequestFor.assetIndex();
            }
        });

        $scope.$on("assetIndex:updated", function (e) {
            var markets = marketsService.findTickMarkets();
            vm.marketsLength = markets ? _.keys(markets).length : 0;
            if (!_.isEmpty(vm.options.market) && _.find(markets, ["displayName", vm.options.market.displayName])) {
                vm.selectMarket(vm.options.market);
            } else {
                vm.selectMarket(marketsService.getMarketByIndex(0));
            }
        });

        $scope.$on("symbol", function (e, groupSymbols) {
            sessionStorage.groupSymbols = JSON.stringify(groupSymbols);
            var tradeTypes = tradeTypesService.findTickContracts(groupSymbols);
            vm.tradeTypesLength = tradeTypes ? _.keys(tradeTypes).length : 0;
            $scope.$applyAsync(function () {
                vm.options.tradeType = Object.keys(tradeTypes).indexOf(vm.options.tradeType) > -1 ? vm.options.tradeType || Object.keys(tradeTypes)[0] : Object.keys(tradeTypes)[0];
                vm.options.tick = vm.options.tick || tradeTypes[vm.options.tradeType][0].min_contract_duration.slice(0, -1);
                vm.options.digit = tradeTypes[vm.options.tradeType][0].last_digit_range ? vm.options.digit || tradeTypes[vm.options.tradeType][0].last_digit_range[0] : null;
                vm.options.barrier = tradeTypes[vm.options.tradeType][0].barriers > 0 ? vm.options.barrier || tradeTypes[vm.options.tradeType][0].barrier : null;
                vm.options.selected_tick = vm.options.tradeType === 'High/Low Ticks' ? vm.options.selected_tick || vm.options.tick : null;
                var min = parseInt(tradeTypes[vm.options.tradeType][0].min_contract_duration.slice(0, -1));
                var max = parseInt(tradeTypes[vm.options.tradeType][0].max_contract_duration.slice(0, -1));
                vm.tickRangeLength = min && max ? _.range(min, max + 1).length : 0;
                updateProposal();
                tradeService.proposalIsReady = true;
            });
        });

        $scope.$on("authorize", function (e, response) {
            vm.proposal.currency = response.currency;
        });

        $scope.$on("options:updated", function (e, options) {
            vm.options = options;
        });

        $ionicModal.fromTemplateUrl("js/pages/trade/components/options/options-modal.html", {
            scope: $scope
        }).then(function (modal) {
            vm.modalCtrl = modal;
        });

        vm.closeModal = function () {
            vm.section1 = vm.SECTIONS.OVERVIEW1;
            vm.section2 = vm.SECTIONS.OVERVIEW2;
            hideModal();
        };

        vm.setSection = function (id, section) {
            switch (section) {
                case vm.SECTIONS.MARKETS:
                    {
                        var markets = JSON.parse(sessionStorage.markets || "{}");
                        if (Object.keys(markets).length <= 1) {
                            return;
                        }
                        break;
                    }
                case vm.SECTIONS.UNDERLYINGS:
                    {
                        if (vm.options.market.underlying.length <= 1) {
                            return;
                        }
                        break;
                    }
                case vm.SECTIONS.TRADETYPES:
                    {
                        var tradeTypes = JSON.parse(sessionStorage.tradeTypes || "{}");
                        if (Object.keys(tradeTypes).length <= 1) {
                            return;
                        }
                        break;
                    }
                case vm.SECTIONS.TICKS:
                    {
                        if (vm.tickRangeLength <= 1) {
                            return;
                        }
                        break;
                    }
                default:
                    break;
            }

            if (id === 1) {
                vm.section2 = vm.SECTIONS.OVERVIEW2;
                vm.section1 = section;
            } else if (id === 2) {
                vm.section1 = vm.SECTIONS.OVERVIEW1;
                vm.section2 = section;
            }

            vm.modalCtrl.show();
            appStateService.modalIsOpen = true;
        };

        vm.selectMarket = function (market) {
            if (market) {
                vm.options.market = market;
                vm.options.underlying = !_.isEmpty(vm.options.underlying) && _.findIndex(market.underlying, ["symbol", vm.options.underlying.symbol]) > -1 ? vm.options.underlying : market.underlying[0];
                sessionStorage.removeItem("tradeTypes");
                websocketService.sendRequestFor.contractsForSymbol(vm.options.underlying.symbol);
                vm.section1 = vm.SECTIONS.OVERVIEW1;
                updateProposal();
            }
            hideModal();
        };

        vm.selectUnderlying = function (underlying) {
            vm.options.underlying = underlying;
            vm.options.barrier = null;
            sessionStorage.removeItem("tradeTypes");
            websocketService.sendRequestFor.contractsForSymbol(underlying.symbol);
            vm.section1 = vm.SECTIONS.OVERVIEW1;
            updateProposal();
            hideModal();
        };

        vm.selectTradeType = function (tradeType) {
            vm.options.tradeType = tradeType;
            tradeType = JSON.parse(sessionStorage.tradeTypes)[tradeType][0];
            vm.options.tick = vm.options.tradeType === 'High/Low Ticks' ? tradeType.min_contract_duration.slice(0, -1) : vm.options.tick || tradeType.min_contract_duration.slice(0, -1);
            vm.options.digit = tradeType.last_digit_range ? vm.options.digit || tradeType.last_digit_range[0] : null;
            vm.options.barrier = tradeType.barriers > 0 && !_.isEmpty(tradeType.barrier) ? vm.options.barrier || tradeType.barrier : null;
            vm.options.selected_tick = vm.options.tradeType === 'High/Low Ticks' ? vm.options.selected_tick || parseInt(vm.options.tick) : null;
            var min = parseInt(tradeType.min_contract_duration.slice(0, -1));
            var max = parseInt(tradeType.max_contract_duration.slice(0, -1));
            vm.tickRangeLength = min && max ? _.range(min, max + 1).length : 0;
            vm.section2 = vm.SECTIONS.OVERVIEW2;
            updateProposal();
            hideModal();
        };

        vm.selectTick = function (tick) {
            vm.options.tick = tick;
            vm.section2 = vm.SECTIONS.OVERVIEW2;
            updateProposal();
            hideModal();
        };

        vm.selectDigit = function (digit) {
            vm.options.digit = digit;
            vm.options.barrier = null;
            vm.section2 = vm.SECTIONS.OVERVIEW2;
            updateProposal();
            hideModal();
        };

        vm.selectSelectedTick = function (tick) {
            vm.options.selected_tick = tick;
            vm.options.barrier = null;
            vm.section2 = vm.SECTIONS.OVERVIEW2;
            updateProposal();
            hideModal();
        };

        vm.getLanguageId = function (title) {
            return title ? "options." + title.replace(/[\s,/]/g, '_').toLowerCase() : title;
        };

        function init() {
            var options = optionsService.get();
            if (!_.isEmpty(options)) {
                vm.options = options;
                // vm.selectMarket(vm.options.market);
                updateProposal();
            }
            websocketService.sendRequestFor.symbols();
        }

        function updateProposal() {
            $scope.$applyAsync(function () {
                vm.proposal = proposalService.update(vm.options);
            });
        }

        function hideModal() {
            if (vm.modalCtrl) {
                vm.modalCtrl.hide();
                appStateService.modalIsOpen = false;
            }
        }

        init();
    }
})();
"use strict";

/**
 * @name options directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/21/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.options.directives").directive("bgOptions", Options);

    function Options() {
        var directive = {
            restrict: "E",
            templateUrl: "js/pages/trade/components/options/options.template.html",
            controller: "OptionsController",
            controllerAs: "vm",
            bindToController: true,
            scope: {
                proposal: "="
            }
        };

        return directive;
    }
})();
"use strict";

/**
 * @name options service
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/31/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.options.services").factory("optionsService", Options);

    function Options() {
        var factory = {};

        factory.get = function () {
            if (_.isEmpty(localStorage.options)) {
                return null;
            }

            return JSON.parse(localStorage.options);
        };

        factory.set = function (options) {
            if (!_.isEmpty(options)) {
                localStorage.options = JSON.stringify(options);
                return true;
            }

            return false;
        };

        return factory;
    }
})();
"use strict";

/**
 * @name selected tick controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 06/23/2018
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.options.controllers").controller("SelectedTickController", SelectedTick);

    SelectedTick.$inject = [];

    function SelectedTick() {
        var vm = this;

        vm.selectableTicksRange = [];

        vm.selectSelectedTick = function (selectedTick) {
            vm.select()(selectedTick);
        };

        var init = function init() {
            if (!_.isEmpty(sessionStorage.tradeTypes)) {
                var tick = vm.tick ? parseInt(vm.tick) : 0;
                vm.selectableTicksRange = _.range(1, tick + 1);
            } else {
                setTimeout(init, 5);
            }
        };

        init();
    }
})();
"use strict";

/**
 * @name selected tick directvie
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 06/23/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.options.directives").directive("bgSelectedTick", SelectedTick);

    function SelectedTick() {
        var directive = {
            restrict: "E",
            templateUrl: "js/pages/trade/components/options/selected-tick.template.html",
            controller: "SelectedTickController",
            controllerAs: "vm",
            bindToController: true,
            scope: {
                select: "&",
                tick: "="
            }
        };

        return directive;
    }
})();
"use strict";

/**
 * @name ticks directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/26/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.options.controllers").controller("TicksController", Ticks);

    Ticks.$inject = [];

    function Ticks() {
        var vm = this;

        var min = 0;
        var max = 0;
        vm.tickRange = [];

        vm.selectTick = function (tick) {
            vm.select()(tick);
        };

        var getTickValue = function getTickValue(tick) {
            return tick.slice(0, -1);
        };

        var init = function init() {
            if (!_.isEmpty(sessionStorage.tradeTypes)) {
                var tradeType = JSON.parse(sessionStorage.tradeTypes)[vm.tradeType][0];
                min = parseInt(getTickValue(tradeType.min_contract_duration));
                max = parseInt(getTickValue(tradeType.max_contract_duration));
                vm.tickRange = _.range(min, max + 1);
            } else {
                setTimeout(init, 5);
            }
        };

        init();
    }
})();
"use strict";

/**
 * @name ticks directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/26/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.options.directives").directive("bgTicks", Ticks);

    function Ticks() {
        var directive = {
            restrict: "E",
            templateUrl: "js/pages/trade/components/options/ticks.template.html",
            controller: "TicksController",
            controllerAs: "vm",
            bindToController: true,
            scope: {
                select: "&",
                tradeType: "="
            }
        };

        return directive;
    }
})();
"use strict";

/**
 * @name trayeTypes directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/24/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.options.controllers").controller("TradeTypesController", TradeTypes);

    TradeTypes.$inject = [];

    function TradeTypes() {
        var vm = this;

        vm.tradeTypes = {};
        vm.supportedTradeTypes = [];

        vm.selectTradeType = function (tradeType) {
            vm.select()(tradeType);
        };

        vm.getLanguageId = function (title) {
            return "options." + title.replace(/[\s,/]/g, '_').toLowerCase();
        };

        function init() {
            vm.tradeTypes = JSON.parse(sessionStorage.tradeTypes);
        }

        init();
    }
})();
"use strict";

/**
 * @name trayeTypes directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/24/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.options.directives").directive("bgTradetypes", TradeTypes);

    function TradeTypes() {
        var directive = {
            restrict: "E",
            templateUrl: "js/pages/trade/components/options/trade-types.template.html",
            controller: "TradeTypesController",
            controllerAs: "vm",
            bindToController: true,
            scope: {
                select: "&"
            }
        };

        return directive;
    }
})();
"use strict";

/**
 * @name trayeTypes service
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/24/2016
 * @copyright Binary Ltd
 */

(function () {
    TradeTypes.$inject = ["config"];
    angular.module("binary.pages.trade.components.options.services").factory("tradeTypesService", TradeTypes);

    function TradeTypes(config) {
        var directive = {};
        var supportedTradeTypes = config.supportedTradeTypes;

        directive.findTickContracts = function (contracts) {
            var tradeTypes = {};
            _.forEach(contracts, function (value, key) {
                var contracts = [];

                value.forEach(function (v, i) {
                    if (value[i].expiry_type === "tick") {
                        contracts.push(value[i]);
                    }
                });

                if (contracts.length > 0) {
                    tradeTypes[key] = contracts;
                }
            });

            var groupedTradeTypes = {};
            _.forEach(tradeTypes, function (value, key) {
                if (value.length === 2) {
                    groupedTradeTypes[value[0].contract_category_display] = value;
                } else {
                    for (var i = 0; i < value.length; i += 2) {
                        var name = value[i].contract_category_display;
                        if (value[i].contract_category === "callput") {
                            if (_.isEmpty(value[i].barrier)) {
                                name = "Rise/Fall";
                            } else {
                                name = "Higher/Lower";
                            }
                        } else {
                            name += " " + value[i].contract_display.capitalize() + "/" + value[i + 1].contract_display.capitalize();
                        }

                        groupedTradeTypes[name] = [value[i], value[i + 1]];
                    }
                }
            });

            var supportedGroupedTradeTypes = {};
            _.forIn(groupedTradeTypes, function (value, key) {
                if (_.includes(supportedTradeTypes, key)) {
                    supportedGroupedTradeTypes[key] = value;
                }
            });
            sessionStorage.tradeTypes = JSON.stringify(supportedGroupedTradeTypes);
            return supportedGroupedTradeTypes;
        };

        return directive;
    }
})();
"use strict";

/**
 * @name underlyings controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/25/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.options.controllers").controller("UnderlyingsController", Underlying);

    Underlying.$inject = [];

    function Underlying() {
        var vm = this;
        vm.underlyings = [];

        vm.selectUnderlying = function (underlying) {
            vm.select()(underlying);
        };

        function init() {
            vm.underlyings = vm.market.underlying;
        }

        init();
    }
})();
"use strict";

/**
 * @name underlyings directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/25/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.options.directives").directive("bgUnderlyings", Underlying);

    function Underlying() {
        var directive = {
            restrict: "E",
            templateUrl: "js/pages/trade/components/options/underlyings.template.html",
            controller: "UnderlyingsController",
            controllerAs: "vm",
            bindToController: true,
            scope: {
                market: "=",
                select: "&"
            }
        };

        return directive;
    }
})();
"use strict";

/**
 * @name payout controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/27/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.payout.controllers").controller("PayoutController", Payout);

    Payout.$inject = ["$scope", "appStateService", "proposalService"];

    function Payout($scope, appStateService, proposalService) {
        var vm = this;
        vm.amount = vm.proposal.amount;
        vm.isIOS = ionic.Platform.isIOS();
        vm.marketsClosed = false;

        setCurrecyPattern();

        $scope.$watch(function () {
            return vm.proposal.amount;
        }, function (newVal, oldVal) {
            if (newVal !== vm.amount) {
                vm.amount = newVal;
            }
        });

        $scope.$on("authorize", function (e, account) {
            setCurrecyPattern(account.currency);
        });

        vm.changePayoutType = function () {
            if (vm.proposal.basis === "payout") {
                vm.proposal.basis = "stake";
            } else {
                vm.proposal.basis = "payout";
            }
            proposalService.setPropertyValue("basis", vm.proposal.basis);
        };

        vm.changeAmount = function () {
            if (_.isEmpty(vm.amount) || vm.amount === "NaN" || Number(vm.amount) === 0) {
                vm.proposal.amount = vm.amount;
            } else {
                if (/^\.\d+$/.test(vm.amount)) {
                    vm.amount = "0" + vm.amount;
                }
                vm.proposal.amount = +vm.amount;
            }
            proposalService.setPropertyValue("amount", vm.proposal.amount);
        };

        vm.add = function () {
            vm.amount = Number(vm.amount) + 1;
        };

        vm.subtract = function () {
            vm.amount = Number(vm.amount) - 1 >= 1 ? Number(vm.amount) - 1 : 1;
        };

        vm.stopLongPress = function () {
            vm.proposal.amount = +vm.amount;
            proposalService.setPropertyValue("amount", vm.proposal.amount);
        };

        $scope.$on("symbols:updated", function (e, openMarkets) {
            if (_.isEmpty(openMarkets)) {
                vm.marketsClosed = true;
            } else {
                vm.marketsClosed = false;
            }
        });

        function init() {}

        function setCurrecyPattern(currency) {
            if (_.isEmpty(currency)) {
                currency = sessionStorage.currency;
            }
            var currencyConfig = appStateService.currenciesConfig[currency];
            $scope.$applyAsync(function () {
                vm.regex = "^(\\d*\\.?\\d{0," + (currencyConfig ? currencyConfig.fractional_digits : 2) + "})";
                vm.amount = new RegExp(vm.regex).exec(vm.amount)[0];
            });
            return vm.regex;
        }

        init();
    }
})();
"use strict";

/**
 * @name payout directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/27/2016
 * @copyright Binary Ltd
 */

(function () {
    angular.module("binary.pages.trade.components.payout.directives").directive("bgPayout", Payout);

    function Payout() {
        var directive = {
            restrict: "E",
            templateUrl: "js/pages/trade/components/payout/payout.template.html",
            controller: "PayoutController",
            controllerAs: "vm",
            bindToController: true,
            scope: {
                proposal: "="
            }
        };

        return directive;
    }
})();
"use strict";

/**
 * @name contract-summary controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 09/07/2016
 * @copyright binary ltd
 */

(function () {
    angular.module("binary.pages.trade.components.purchase.controllers").controller("ContractSummaryController", Summary);

    Summary.$inject = ['$scope', 'appStateService'];

    function Summary($scope, appStateService) {
        var vm = this;
        vm.currencyType = 'fiat';
        var currency = sessionStorage.getItem('currency');
        var currencyConfig = appStateService.currenciesConfig[currency];

        if (currencyConfig) {
            vm.currencyType = currencyConfig.type;
        }

        $scope.$watch(function () {
            return vm.proposal;
        }, function () {
            currency = sessionStorage.getItem('currency');
            currencyConfig = appStateService.currenciesConfig[currency];
            if (currencyConfig) {
                vm.currencyType = currencyConfig.type;
            }
        });
    }
})();
"use strict";

/**
 * @name contract-summary directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 09/07/2016
 * @copyright binary ltd
 */

(function () {
    angular.module("binary.pages.trade.components.purchase.directives").directive("bgContractSummary", Summary);

    function Summary() {
        var directive = {
            restrict: "E",
            templateUrl: "js/pages/trade/components/purchase/contract-summary.template.html",
            controller: "ContractSummaryController",
            controllerAs: "vm",
            bindToController: true,
            scope: {
                proposal: "=",
                purchasedContract: "="
            }
        };

        return directive;
    }
})();
"use strict";

/**
 * @name purchase controller
 * @author morteza tavnarad
 * @contributors []
 * @since 08/27/2016
 * @copyright binary ltd
 */

(function () {
    angular.module("binary.pages.trade.components.purchase.controllers").controller("PurchaseController", Purchase);

    Purchase.$inject = ["$scope", "$timeout", "analyticsService", "accountService", "appStateService", "proposalService", "websocketService", "$ionicLoading"];

    function Purchase($scope, $timeout, analyticsService, accountService, appStateService, proposalService, websocketService, $ionicLoading) {
        var vm = this;
        var forgetRequestId = 0;

        vm.longcode = [];
        vm.contracts = [];
        vm.proposalResponses = [];
        vm.inPurchaseMode = false;
        vm.showSummary = false;
        vm.purchasedContractIndex = -1;
        vm.currencyType = "fiat";
        vm.isContractFinished = false;

        $scope.$watch(function () {
            return vm.proposal;
        }, function (newValue, oldValue) {
            if (_.isEqual(newValue, oldValue) && vm.proposalResponses.length > 0) {
                return;
            }

            if (vm.proposalResponses.length > 0) {
                $scope.$applyAsync(function () {
                    vm.proposalResponses[0].isReceiving = true;
                    vm.proposalResponses[1].isReceiving = true;
                });
            }

            var currencyConfig = appStateService.currenciesConfig[vm.proposal.currency];
            if (currencyConfig) {
                vm.currencyType = currencyConfig.type;
            }

            proposalUpdated();
        }, true);

        $scope.$on("appState:tradeMode", function (e) {
            vm.showSummary = !appStateService.tradeMode;
        });

        $scope.$on("proposal", function (e, proposal, reqId) {
            if ([1, 2].indexOf(reqId) > -1) {
                $scope.$applyAsync(function () {
                    vm.proposalResponses[reqId - 1] = proposal;
                    vm.proposalResponses[reqId - 1].hasError = false;
                    vm.proposalResponses[reqId - 1].isReceiving = false;
                    vm.longcode[reqId - 1] = proposal.longcode;
                });
            }

            if (vm.isContractFinished) {
                // Unlock view to navigate
                appStateService.purchaseMode = false;
                vm.inPurchaseMode = false;
            }
        });

        $scope.$on("proposal:error", function (e, error, reqId) {
            if ([1, 2].indexOf(reqId) > -1 && error.code !== "AlreadySubscribed") {
                $scope.$applyAsync(function () {
                    vm.proposalResponses[reqId - 1] = error;
                    vm.proposalResponses[reqId - 1].hasError = true;
                });
                $timeout(vm.autoSizeText, 1000);
            }
        });

        $scope.$on("purchase", function (e, response) {
            if (!_.isEmpty(response.buy)) {
                vm.showSummary = true;
                $scope.$applyAsync(function () {
                    vm.purchasedContract = {
                        contractId: response.buy.contract_id,
                        longcode: response.buy.longcode,
                        payout: vm.proposalResponses[vm.purchasedContractIndex].payout,
                        cost: response.buy.buy_price,
                        balance: response.buy.balance_after,
                        transactionId: response.buy.transaction_id,
                        profit: parseFloat(vm.proposalResponses[vm.purchasedContractIndex].payout) - parseFloat(response.buy.buy_price)
                    };
                });
                var req_id = Date.now();
                proposalService.openContractId = req_id;
                websocketService.sendRequestFor.openContract(response.buy.contract_id, { req_id: req_id, subscribe: 1 });
            }
        });

        $scope.$on("purchase:error", function (e, error) {
            vm.inPurchaseMode = false;
            vm.showSummary = false;
            appStateService.tradeMode = true;
            appStateService.purchaseMode = false;
            vm.purchasedContractIndex = -1;
            sendProposal();
        });

        $scope.$on("contract:finished", function (e, contract) {
            if (contract.exitSpot) {
                if (contract.result === "win") {
                    vm.purchasedContract.buyPrice = vm.purchasedContract.cost;
                    vm.purchasedContract.profit = vm.purchasedContract.profit;
                    vm.purchasedContract.finalPrice = parseFloat(vm.purchasedContract.buyPrice) + parseFloat(vm.purchasedContract.profit);
                    websocketService.sendRequestFor.openContract();
                } else if (contract.result === "lose") {
                    vm.purchasedContract.buyPrice = vm.purchasedContract.cost;
                    vm.purchasedContract.loss = vm.purchasedContract.cost;
                    vm.purchasedContract.finalPrice = parseFloat(vm.purchasedContract.buyPrice) + parseFloat(vm.purchasedContract.loss);
                }
                vm.purchasedContract.result = contract.result === "lose" ? "loss" : contract.result;

                var proposal = vm.contracts[vm.purchasedContractIndex];

                // Send statistic to Google Analytics
                analyticsService.google.trackEvent(proposal.market, proposal.contract_type, proposal.underlying_symbol, vm.purchasedContract.payout);

                vm.isContractFinished = true;
                sendProposal();
            }
        });

        $scope.$on("forget_all", function (e, req_id) {
            if (req_id !== forgetRequestId) {
                return;
            }
            var proposal1 = _.clone(vm.proposal);
            proposal1.contract_type = vm.contracts[0].contract_type;
            proposal1.req_id = 1;

            var proposal2 = _.clone(vm.proposal);
            proposal2.contract_type = vm.contracts[1].contract_type;
            proposal2.req_id = 2;

            if (vm.proposalResponses.length > 0) {
                $scope.$applyAsync(function () {
                    vm.proposalResponses[0].isReceiving = proposalService.send(proposal1);
                    vm.proposalResponses[1].isReceiving = proposalService.send(proposal2);
                });
            } else {
                proposalService.send(proposal1);
                proposalService.send(proposal2);
            }
        });

        $scope.$on("$destroy", function (e) {
            proposalService.forget();
        });

        vm.getImageUrl = function (contractType) {
            return "img/trade-icon/" + contractType.toLowerCase() + ".svg";
        };

        vm.purchase = function (contractIndex) {
            $scope.$applyAsync(function () {
                vm.isContractFinished = false;
                vm.inPurchaseMode = true;
                vm.purchasedContractIndex = contractIndex;
                appStateService.purchaseMode = true;
                appStateService.tradeMode = false;
            });
            proposalService.purchase(vm.proposalResponses[contractIndex]);
        };

        vm.backToTrade = function () {
            vm.showSummary = false;
            appStateService.tradeMode = true;
            appStateService.purchaseMode = false;
            vm.purchasedContractIndex = -1;
        };

        vm.showLongcode = function (id) {
            return $ionicLoading.show({ template: vm.longcode[id], noBackdrop: true, duration: 2500 });
        };

        function init() {
            vm.user = accountService.getDefault();
            if (_.isEmpty(vm.contracts)) {
                setTimeout(init, 500);
            }
            // sendProposal();
        }

        function sendProposal() {
            forgetRequestId = new Date().getTime();

            proposalService.forget(forgetRequestId);

            // Proposal will be sent when the result of proposal-forget received. Lines:141-156
            // This changes has been done to prevent subscribtion issue
            // `You're already subscribed`
        }

        function proposalUpdated() {
            if (!_.isEmpty(sessionStorage.tradeTypes)) {
                var tradeTypes = JSON.parse(sessionStorage.tradeTypes);
                vm.contracts = tradeTypes[vm.proposal.tradeType];

                if (!_.isEmpty(vm.contracts) && vm.contracts[0].underlying_symbol === vm.proposal.symbol) {
                    sendProposal();
                }
            } else {
                setTimeout(proposalUpdated, 5);
            }
        }

        vm.autoSizeText = function () {
            var el = void 0;
            var _i = void 0;
            var _len = void 0;
            var _results = [];
            var elements = document.getElementsByClassName("resize");
            if (elements.length < 0) {
                return null;
            }
            for (_i = 0, _len = elements.length; _i < _len; _i++) {
                el = elements[_i];
                _results.push(function (el) {
                    var _results1 = [];
                    var resizeText = function resizeText() {
                        var elNewFontSize = parseInt($(el).css("font-size").slice(0, -2)) - 1 + "px";
                        return $(el).css("font-size", elNewFontSize);
                    };
                    while (el.scrollHeight > el.offsetHeight) {
                        _results1.push(resizeText());
                    }
                    return _results1;
                }(el));
            }
            return _results;
        };

        init();
    }
})();
"use strict";

/**
 * @name purchase directive
 * @author morteza tavnarad
 * @contributors []
 * @since 08/27/2016
 * @copyright binary ltd
 */

(function () {
    angular.module("binary.pages.trade.components.purchase.directives").directive("bgPurchase", Purchase);

    function Purchase() {
        var directive = {
            restrict: "E",
            templateUrl: "js/pages/trade/components/purchase/purchase.template.html",
            controller: "PurchaseController",
            controllerAs: "vm",
            bindToController: true,
            scope: {
                proposal: "=",
                purchasedContract: "=",
                showSummary: "=inPurchaseMode"
            }
        };

        return directive;
    }
})();